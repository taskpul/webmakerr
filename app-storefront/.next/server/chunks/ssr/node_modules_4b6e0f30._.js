module.exports = [
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable import/no-extraneous-dependencies */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "registerServerReference", {
    enumerable: true,
    get: function() {
        return _server.registerServerReference;
    }
});
const _server = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)"); //# sourceMappingURL=server-reference.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/api-key.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiKey",
    ()=>ApiKey
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ApiKey {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This methods retrieves a paginated list of API keys. It sends a request to the
     * [List API Keys](https://docs.medusajs.com/api/admin#api-keys_getapikeys) API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of API keys.
     *
     * @example
     * To retrieve the list of API keys:
     *
     * ```ts
     * sdk.admin.apiKey.list()
     * .then(({ api_keys, count, limit, offset }) => {
     *   console.log(api_keys)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.apiKey.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ api_keys, count, limit, offset }) => {
     *   console.log(api_keys)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each API key:
     *
     * ```ts
     * sdk.admin.apiKey.list({
     *   fields: "id,*sales_channels"
     * })
     * .then(({ api_keys, count, limit, offset }) => {
     *   console.log(api_keys)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method creates an API key. It sends a request to the [Create API Key](https://docs.medusajs.com/api/admin#api-keys_postapikeys)
     * API route.
     *
     * @param body - The API key's details.
     * @param query - Configure the fields to retrieve in the created API key.
     * @param headers - Headers to pass in the request
     * @returns The created API key
     *
     * @example
     * sdk.admin.apiKey.create({
     *   title: "Development",
     *   type: "publishable"
     * })
     * .then(({ api_key }) => {
     *   console.log(api_key)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method revokes an API key. It sends a request to the
     * [Revoke API Key](https://docs.medusajs.com/api/admin#api-keys_postapikeysidrevoke) API route.
     *
     * @param id - The API key's ID.
     * @param headers - Headers to pass in the request.
     * @returns The API key's details.
     *
     * @example
     * sdk.admin.apiKey.revoke("apk_123")
     * .then(({ api_key }) => {
     *   console.log(api_key)
     * })
     */ revoke(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys/${id}/revoke`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method retrieves an API key's details. It sends a request to the
     * [Get API key](https://docs.medusajs.com/api/admin#api-keys_getapikeysid) API route.
     *
     * @param id - The API key's ID.
     * @param headers - Headers to pass in the request.
     * @returns The API key's details.
     *
     * @example
     * sdk.admin.apiKey.retrieve("apk_123")
     * .then(({ api_key }) => {
     *   console.log(api_key)
     * })
     */ retrieve(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys/${id}`, {
                headers
            });
        });
    }
    /**
     * This method updates an API key's details. It sends a request to the
     * [Update API Key](https://docs.medusajs.com/api/admin#api-keys_postapikeysid) API route.
     *
     * @param id - The API key's ID.
     * @param body - The data to update in the API key.
     * @param query - Configure the fields to retrieve in the API key.
     * @param headers - Headers to pass in the request.
     * @returns The API key's details.
     *
     * @example
     * sdk.admin.apiKey.update("apk_123", {
     *   title: "Development"
     * })
     * .then(({ api_key }) => {
     *   console.log(api_key)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes an API key by its ID. It sends a request to the
     * [Delete API Key](https://docs.medusajs.com/api/admin#api-keys_deleteapikeysid) API route.
     *
     * @param id - The API key's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.apiKey.delete("apk_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the sales channels associated with a publishable API key to either add
     * or remove associations. It sends a request to the [Manage Sales Channels](https://docs.medusajs.com/api/admin#api-keys_postapikeysidsaleschannels)
     * API route.
     *
     * @param id - The API key's ID.
     * @param body - The sales channels to add or remove from the API key.
     * @param headers - Headers to pass in the request.
     * @returns The API key's details.
     *
     * @example
     * sdk.admin.apiKey.batchSalesChannels("apk_123", {
     *   add: ["sc_123"],
     *   remove: ["sc_321"]
     * })
     * .then(({ api_key }) => {
     *   console.log(api_key)
     * })
     */ batchSalesChannels(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/api-keys/${id}/sales-channels`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=api-key.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/campaign.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Campaign",
    ()=>Campaign
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Campaign {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a campaign by its ID. It sends a request to the
     * [Get Campaign](https://docs.medusajs.com/api/admin#campaigns_getcampaignsid) API route.
     *
     * @param id - The campaign's ID.
     * @param query - Configure the fields to retrieve in the campaign.
     * @param headers - Headers to pass in the request
     * @returns The campaign's details.
     *
     * @example
     * To retrieve a campaign by its ID:
     *
     * ```ts
     * sdk.admin.campaign.retrieve("procamp_123")
     * .then(({ campaign }) => {
     *   console.log(campaign)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.campaign.retrieve("procamp_123", {
     *   fields: "id,*budget"
     * })
     * .then(({ campaign }) => {
     *   console.log(campaign)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns/${id}`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of campaigns. It sends a request to the
     * [List Campaigns](https://docs.medusajs.com/api/admin#campaigns_getcampaigns) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of campaigns.
     *
     * @example
     * To retrieve the list of campaigns:
     *
     * ```ts
     * sdk.admin.campaign.list()
     * .then(({ campaigns, count, limit, offset }) => {
     *   console.log(campaigns)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.campaign.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ campaigns, count, limit, offset }) => {
     *   console.log(campaigns)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each campaign:
     *
     * ```ts
     * sdk.admin.campaign.list({
     *   fields: "id,*budget"
     * })
     * .then(({ campaigns, count, limit, offset }) => {
     *   console.log(campaigns)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns`, {
                headers,
                query
            });
        });
    }
    /**
     * This method creates a campaign. It sends a request to the
     * [Create Campaign](https://docs.medusajs.com/api/admin#campaigns_postcampaigns) API route.
     *
     * @param payload - The details of the campaign to create.
     * @param headers - Headers to pass in the request
     * @returns The campaign's details.
     *
     * @example
     * sdk.admin.campaign.create({
     *   name: "Summer Campaign"
     * })
     * .then(({ campaign }) => {
     *   console.log(campaign)
     * })
     */ create(payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns`, {
                method: "POST",
                headers,
                body: payload
            });
        });
    }
    /**
     * This method updates a campaign. It sends a request to the
     * [Update Campaign](https://docs.medusajs.com/api/admin#campaigns_postcampaignsid) API route.
     *
     * @param id - The campaign's ID.
     * @param payload - The data to update in the campaign.
     * @param headers - Headers to pass in the request
     * @returns The campaign's details.
     *
     * @example
     * sdk.admin.campaign.update("procamp_123", {
     *   name: "Summer Campaign"
     * })
     * .then(({ campaign }) => {
     *   console.log(campaign)
     * })
     */ update(id, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns/${id}`, {
                method: "POST",
                headers,
                body: payload
            });
        });
    }
    /**
     * This method deletes a campaign by its ID. It sends a request to the
     * [Delete Campaign](https://docs.medusajs.com/api/admin#campaigns_deletecampaignsid) API route.
     *
     * @param id - The campaign's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.campaign.delete("procamp_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the promotions of a campaign to either add or remove the association between them.
     * It sends a request to the [Manage Promotions](https://docs.medusajs.com/api/admin#campaigns_postcampaignsidpromotions)
     * API route.
     *
     * @param id - The campaign's ID.
     * @param payload - The promotions to add or remove associations to them.
     * @param headers - Headers to pass in the request
     * @returns The campaign's details.
     *
     * @example
     * sdk.admin.campaign.batchPromotions("procamp_123", {
     *   add: ["prom_123", "prom_456"],
     *   remove: ["prom_789"]
     * })
     * .then(({ campaign }) => {
     *   console.log(campaign)
     * })
     */ batchPromotions(id, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/campaigns/${id}/promotions`, {
                method: "POST",
                headers,
                body: payload
            });
        });
    }
} //# sourceMappingURL=campaign.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/claim.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Claim",
    ()=>Claim
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Claim {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of claims. It sends a request to the
     * [List Claims](https://docs.medusajs.com/api/admin#claims_getclaims) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of claims.
     *
     * @example
     * To retrieve the list of claims:
     *
     * ```ts
     * sdk.admin.claim.list()
     * .then(({ claims, count, limit, offset }) => {
     *   console.log(claims)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.claim.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ claims, count, limit, offset }) => {
     *   console.log(claims)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each claim:
     *
     * ```ts
     * sdk.admin.claim.list({
     *   fields: "id,*additional_items"
     * })
     * .then(({ claims, count, limit, offset }) => {
     *   console.log(claims)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a claim. It sends a request to the
     * [Get Claim](https://docs.medusajs.com/api/admin#claims_getclaimsid) API route.
     *
     * @param id - The claim's ID.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim's details.
     *
     * @example
     * To retrieve a claim by its ID:
     *
     * ```ts
     * sdk.admin.claim.retrieve("claim_123")
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.claim.retrieve("claim_123", {
     *   fields: "id,*additional_items"
     * })
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method creates a claim. It sends a request to the
     * [Create Claim](https://docs.medusajs.com/api/admin#claims_postclaims) API route.
     *
     * @param body - The claim's details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim and order's details.
     *
     * @example
     * sdk.admin.claim.create({
     *   type: "refund",
     *   order_id: "order_123",
     * })
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels a claim. It sends a request to the
     * [Cancel Claim](https://docs.medusajs.com/api/admin#claims_postclaimsidcancel) API route.
     *
     * @param id - The claim's ID.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim's details.
     *
     * @example
     * sdk.admin.claim.cancel("claim_123")
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ cancel(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/cancel`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method adds items to the claim. It sends a request to the
     * [Add Items](https://docs.medusajs.com/api/admin#claims_postclaimsidclaimitems) API route.
     *
     * @param id - The ID of the claim to add the items to.
     * @param body - The items' details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim's details with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.addItems("claim_123", {
     *   items: [
     *     {
     *       id: "orli_123",
     *       quantity: 1
     *     }
     *   ]
     * })
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ addItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/claim-items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a claim item by the ID of the item's `WRITE_OFF_ITEM` action. It
     * sends a request to the [Update Claim Item](https://docs.medusajs.com/api/admin#claims_postclaimsidclaimitemsaction_id) API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the order item's `WRITE_OFF_ITEM` action.
     * @param body - The details to update.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim's details with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.updateItem(
     *   "claim_123",
     *   "ordchact_123",
     *   {
     *     quantity: 1
     *   }
     *   )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ updateItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/claim-items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes a claim item from a claim by the ID of the item's `WRITE_OFF_ITEM` action.
     * It sends a request to the [Remove Claim Item](https://docs.medusajs.com/api/admin#claims_deleteclaimsidclaimitemsaction_id)
     * API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the order item's `WRITE_OFF_ITEM` action.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The claim's details with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.removeItem(
     *   "claim_123",
     *   "ordchact_123",
     *   )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ removeItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/claim-items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds inbound (or return) items to the claim. These inbound items will have a `RETURN_ITEM` action.
     *
     * This method sends a request to the [Add Inbound Items](https://docs.medusajs.com/api/admin#claims_postclaimsidinbounditems)
     * API route.
     *
     * @param id - The ID of the claim to add the inbound items to.
     * @param body - The inbound items' details.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request
     * @returns The details of the return associated with the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.addInboundItems(
     *   "claim_123",
     *   {
     *     items: [
     *       {
     *         id: "orli_123",
     *         quantity: 1
     *       }
     *     ]
     *   },
     *   )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ addInboundItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an inbound (or return) item of a claim using the ID of the item's `RETURN_ITEM` action.
     * It sends a request to the [Update Inbound Item](https://docs.medusajs.com/api/admin#claims_postclaimsidinbounditemsaction_id)
     * API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the return item's `RETURN_ITEM` action.
     * @param body - The details to update in the inbound item.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request
     * @returns The details of the return associated wth the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.updateInboundItem(
     *   "claim_123",
     *   "ordchact_123",
     *   {
     *     quantity: 1
     *   },
     *   )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ updateInboundItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an inbound (or return) item from a claim using the ID of the item's `RETURN_ITEM` action.
     * It sends a request to the [Remove Inbound Item](https://docs.medusajs.com/api/admin#claims_deleteclaimsidinbounditemsaction_id)
     * API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The ID of the return item's `RETURN_ITEM` action.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request
     * @returns The details of the return associated wth the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.removeInboundItem(
     *   "claim_123",
     *   "ordchact_123",
     *   )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ removeInboundItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds an inbound (or return) shipping method to a claim.
     * The inbound shipping method will have a `SHIPPING_ADD` action.
     *
     * This method sends a request to the [Add Inbound Shipping](https://docs.medusajs.com/api/admin#claims_postclaimsidinboundshippingmethod)
     * API route.
     *
     * @param id - The claim's ID.
     * @param body - The shipping method's details.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request
     * @returns The details of the return associated wth the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.addInboundShipping(
     *   "claim_123",
     *   {
     *     shipping_option_id: "so_123",
     *     custom_amount: 10
     *   },
     *   )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ addInboundShipping(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a shipping method for returning items in the claim using the ID of the method's `SHIPPING_ADD` action.
     * It sends a request to the [Update Inbound Shipping](https://docs.medusajs.com/api/admin#claims_postclaimsidinboundshippingmethodaction_id)
     * API route.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param body - The details to update in the shipping method
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.updateInboundShipping(
     *   "claim_123",
     *   "ordchact_123",
     *   {
     *     custom_amount: 10
     *   },
     *   )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ updateInboundShipping(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a shipping method for returning items in the claim using the ID of the method's `SHIPPING_ADD` action.
     * It sends a request to the [Remove Inbound Shipping](https://docs.medusajs.com/api/admin#claims_deleteclaimsidinboundshippingmethodaction_id)
     * API route.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request
     * @returns The details of the return associated wth the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.deleteInboundShipping(
     *   "claim_123",
     *   "ordchact_123",
     *   )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ deleteInboundShipping(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds outbound (or new) items to a claim. These outbound items will have an `ITEM_ADD` action.
     * It sends a request to the [Add Outbound Items](https://docs.medusajs.com/api/admin#claims_postclaimsidoutbounditems)
     * API route.
     *
     * @param id - The ID of the claim to add the outbound items to.
     * @param body - The items' details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.addOutboundItems(
     *   "claim_123",
     *   {
     *     items: [{
     *       id: "orli_123",
     *       quantity: 1
     *     }]
     *   },
     *   )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ addOutboundItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an outbound (or new) item of a claim using the ID of the item's `ITEM_ADD` action.
     * It sends a request to the [Update Outbound Item](https://docs.medusajs.com/api/admin#claims_postclaimsidoutbounditemsaction_id)
     * API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the new claim item's `ITEM_ADD` action.
     * @param body - The item's details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.updateOutboundItem(
     *   "claim_123",
     *   "ordchact_123",
     *   {
     *     quantity: 1
     *   },
     *   )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ updateOutboundItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an outbound (or new) item from a claim using the ID of the item's `ITEM_ADD` action.
     * It sends a request to the [Remove Outbound Item](https://docs.medusajs.com/api/admin#claims_deleteclaimsidoutbounditemsaction_id)
     * API route.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the new claim item's `ITEM_ADD` action.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.removeOutboundItem(
     *   "claim_123",
     *   "ordchact_123",
     * )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ removeOutboundItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds outbound an outbound shipping method to a claim.
     * The outbound shipping method will have a `SHIPPING_ADD` action.
     *
     * This method sends a request to the
     * [Add Outbound Shipping](https://docs.medusajs.com/api/admin#claims_postclaimsidoutboundshippingmethod)
     * API route.
     *
     * @param id - The claim's ID.
     * @param body - The shipping method's details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.addOutboundShipping(
     *   "claim_123",
     *   {
     *     shipping_option_id: "so_123",
     *     custom_amount: 10
     *   },
     * )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ addOutboundShipping(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates the shipping method for delivering outbound items in a claim using the ID of the method's `SHIPPING_ADD` action.
     * It sends a request to the [Update Outbound Shipping](https://docs.medusajs.com/api/admin#claims_postclaimsidoutboundshippingmethodaction_id)
     * API route.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param body - The shipping method's details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.updateOutboundShipping(
     *   "claim_123",
     *   "ordchact_123",
     *   {
     *     custom_amount: 10
     *   },
     * )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ updateOutboundShipping(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes the shipping method for delivering outbound items in the claim using the ID of the method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The claim's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.deleteOutboundShipping(
     *   "claim_123",
     *   "ordchact_123",
     * )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ deleteOutboundShipping(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method confirms a claim request, applying its changes on the associated order.
     * It sends a request to the [Confirm Claim Request](https://docs.medusajs.com/api/admin#claims_postclaimsidrequest)
     * API route.
     *
     * @param id - The claim's ID.
     * @param body - The confirmation details.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The details of the claim and its associated return, with a preview of the order when the claim is applied.
     *
     * @example
     * sdk.admin.claim.request(
     *   "claim_123",
     *   {},
     * )
     * .then(({ claim }) => {
     *   console.log(claim)
     * })
     */ request(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/request`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels a requested claim. It sends a request to the
     * [Cancel Claim Request](https://docs.medusajs.com/api/admin#claims_deleteclaimsidrequest)
     * API route.
     *
     * @param id - The claim's ID.
     * @param query - Configure the fields to retrieve in the claim.
     * @param headers - Headers to pass in the request
     * @returns The cancelation's details.
     *
     * @example
     * sdk.admin.claim.cancelRequest(
     *   "claim_123",
     * )
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ cancelRequest(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/claims/${id}/request`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=claim.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/currency.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Currency",
    ()=>Currency
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Currency {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of currencies. It sends a request to the
     * [List Currencies](https://docs.medusajs.com/api/admin#currencies_getcurrencies)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of currencies.
     *
     * @example
     * To retrieve the list of currencies:
     *
     * ```ts
     * sdk.admin.currency.list()
     * .then(({ currencies, count, limit, offset }) => {
     *   console.log(currencies)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.currency.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ currencies, count, limit, offset }) => {
     *   console.log(currencies)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each currency:
     *
     * ```ts
     * sdk.admin.currency.list({
     *   fields: "code,symbol"
     * })
     * .then(({ currencies, count, limit, offset }) => {
     *   console.log(currencies)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/currencies`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a currency by its code. It sends a request to the
     * [Get Currency](https://docs.medusajs.com/api/admin#currencies_getcurrenciescode) API route.
     *
     * @param code - The currency's code.
     * @param query - Configure the fields to retrieve in the currency.
     * @param headers - Headers to pass in the request
     * @returns The currency's details.
     *
     * @example
     * To retrieve a currency by its code:
     *
     * ```ts
     * sdk.admin.currency.retrieve("usd")
     * .then(({ currency }) => {
     *   console.log(currency)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.currency.retrieve("usd", {
     *   fields: "code,symbol"
     * })
     * .then(({ currency }) => {
     *   console.log(currency)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(code, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/currencies/${code}`, {
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=currency.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/customer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Customer",
    ()=>Customer
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Customer {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a customer. It sends a request to the
     * [Create Customer](https://docs.medusajs.com/api/admin#customers_postcustomers) API route.
     *
     * @param body - The customer's details.
     * @param query - Configure the fields to retrieve in the customer.
     * @param headers - Headers to pass in the request.
     * @returns The customer's details.
     *
     * @example
     * sdk.admin.customer.create({
     *   email: "customer@gmail.com"
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/customers`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a customer's details. It sends a request to the
     * [Update Customer](https://docs.medusajs.com/api/admin#customers_postcustomersid) API route.
     *
     * @param id - The customer's ID.
     * @param body - The details to update of the customer.
     * @param query - Configure the fields to retrieve in the customer.
     * @param headers - Headers to pass in the request.
     * @returns The customer's details.
     *
     * @example
     * sdk.admin.customer.update("cus_123", {
     *   first_name: "John"
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/customers/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of customers. It sends a request to the
     * [List Customers](https://docs.medusajs.com/api/admin#customers_getcustomers)
     * API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of customers.
     *
     * @example
     * To retrieve the list of customers:
     *
     * ```ts
     * sdk.admin.customer.list()
     * .then(({ customers, count, limit, offset }) => {
     *   console.log(customers)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.customer.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ customers, count, limit, offset }) => {
     *   console.log(customers)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each customer:
     *
     * ```ts
     * sdk.admin.customer.list({
     *   fields: "id,*groups"
     * })
     * .then(({ customers, count, limit, offset }) => {
     *   console.log(customers)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/customers`, {
                headers,
                query: queryParams
            });
        });
    }
    /**
     * This method retrieves a customer by its ID. It sends a request to the
     * [Get Customer](https://docs.medusajs.com/api/admin#customers_getcustomersid)
     * API route.
     *
     * @param id - The customer's ID.
     * @param query - Configure the fields to retrieve in the customer.
     * @param headers - Headers to pass in the request.
     * @returns The customer's details.
     *
     * @example
     * To retrieve a customer by its ID:
     *
     * ```ts
     * sdk.admin.customer.retrieve("cus_123")
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.customer.retrieve("cus_123", {
     *   fields: "id,*groups"
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/customers/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a customer by its ID. It sends a request to the
     * [Delete Customer](https://docs.medusajs.com/api/admin#customers_deletecustomersid)
     * API route.
     *
     * @param id - The customer's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.customer.delete("cus_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/customers/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages customer groups for a customer.
     * It sends a request to the [Manage Customers](https://docs.medusajs.com/api/admin#customers_postcustomersidcustomergroups)
     * API route.
     *
     * @param id - The customer's ID.
     * @param body - The groups to add customer to or remove customer from.
     * @param headers - Headers to pass in the request
     * @returns The customers details.
     *
     * @example
     * sdk.admin.customer.batchCustomerGroups("cus_123", {
     *   add: ["cusgroup_123"],
     *   remove: ["cusgroup_321"]
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ batchCustomerGroups(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/customer-groups`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method creates a customer address. It sends a request to the
     * [Create Customer Address](https://docs.medusajs.com/api/admin#customers_postcustomersidaddresses)
     * API route.
     *
     * @param id - The customer's ID.
     * @param body - The customer address's details.
     * @param headers - Headers to pass in the request.
     * @returns The customer address's details.
     *
     * @example
     * sdk.admin.customer.createAddress("cus_123", {
     *   address_1: "123 Main St",
     *   city: "Anytown",
     *   country_code: "US",
     *   postal_code: "12345"
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ createAddress(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/addresses`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method updates a customer address. It sends a request to the
     * [Update Customer Address](https://docs.medusajs.com/api/admin#customers_postcustomersidaddressesaddressid)
     * API route.
     *
     * @param id - The customer's ID.
     * @param addressId - The customer address's ID.
     * @param body - The customer address's details.
     * @param headers - Headers to pass in the request.
     * @returns The customer address's details.
     *
     * @example
     * sdk.admin.customer.updateAddress("cus_123", "cus_addr_123", {
     *   address_1: "123 Main St",
     *   city: "Anytown",
     *   country_code: "US",
     *   postal_code: "12345"
     * })
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ updateAddress(id, addressId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/addresses/${addressId}`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method deletes a customer address. It sends a request to the
     * [Delete Customer Address](https://docs.medusajs.com/api/admin#customers_deletecustomersidaddressesaddressid)
     * API route.
     *
     * @param id - The customer's ID.
     * @param addressId - The customer address's ID.
     * @param headers - Headers to pass in the request.
     * @returns The customer address's details.
     *
     * @example
     * sdk.admin.customer.deleteAddress("cus_123", "cus_addr_123")
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ deleteAddress(id, addressId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/addresses/${addressId}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a customer address by its ID. It sends a request to the
     * [Get Customer Address](https://docs.medusajs.com/api/admin#customers_getcustomersidaddressesaddressid)
     * API route.
     *
     * @param id - The customer's ID.
     * @param addressId - The customer address's ID.
     * @param headers - Headers to pass in the request.
     * @returns The customer address's details.
     *
     * @example
     * sdk.admin.customer.retrieveAddress("cus_123", "cus_addr_123")
     * .then(({ customer }) => {
     *   console.log(customer)
     * })
     */ retrieveAddress(id, addressId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/addresses/${addressId}`, {
                headers
            });
        });
    }
    /**
     * This method retrieves a list of customer addresses. It sends a request to the
     * [List Customer Addresses](https://docs.medusajs.com/api/admin#customers_getcustomersidaddresses)
     * API route.
     *
     * @param id - The customer's ID.
     * @param headers - Headers to pass in the request.
     * @returns The list of customer addresses.
     *
     * @example
     * sdk.admin.customer.listAddresses("cus_123")
     * .then(({ addresses }) => {
     *   console.log(addresses)
     * })
     */ listAddresses(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customers/${id}/addresses`, {
                headers
            });
        });
    }
} //# sourceMappingURL=customer.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/customer-group.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CustomerGroup",
    ()=>CustomerGroup
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class CustomerGroup {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a customer group by its ID. It sends a request to the
     * [Get Customer Group](https://docs.medusajs.com/api/admin#customer-groups_getcustomergroupsid) API route.
     *
     * @param id - The customer group's ID.
     * @param query - Configure the fields to retrieve in the customer group.
     * @param headers - Headers to pass in the request
     * @returns The group's details.
     *
     * @example
     * To retrieve a customer group by its ID:
     *
     * ```ts
     * sdk.admin.customerGroup.retrieve("cusgroup_123")
     * .then(({ customer_group }) => {
     *   console.log(customer_group)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.customerGroup.retrieve("cusgroup_123", {
     *   fields: "id,*customer"
     * })
     * .then(({ customer_group }) => {
     *   console.log(customer_group)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups/${id}`, {
                method: "GET",
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a paginated list of customer groups. It sends a request to the
     * [List Customer Groups](https://docs.medusajs.com/api/admin#customer-groups_getcustomergroups)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of customer groups.
     *
     * @example
     * To retrieve the list of customer groups:
     *
     * ```ts
     * sdk.admin.customerGroup.list()
     * .then(({ customer_groups, count, limit, offset }) => {
     *   console.log(customer_groups)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.customerGroup.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ customer_groups, count, limit, offset }) => {
     *   console.log(customer_groups)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each customer group:
     *
     * ```ts
     * sdk.admin.customerGroup.list({
     *   fields: "id,*customer"
     * })
     * .then(({ customer_groups, count, limit, offset }) => {
     *   console.log(customer_groups)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method creates a customer group. It sends a request to the
     * [Create Customer Group](https://docs.medusajs.com/api/admin#customer-groups_postcustomergroups)
     * API route.
     *
     * @param body - The customer group's details.
     * @param query - Configure the fields to retrieve in the customer group.
     * @param headers - Headers to pass in the request.
     * @returns The customer group's details.
     *
     * @example
     * sdk.admin.customerGroup.create({
     *   name: "VIP"
     * })
     * .then(({ customer_group }) => {
     *   console.log(customer_group)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a customer group's details. It sends a request to the
     * [Update Customer](https://docs.medusajs.com/api/admin#customer-groups_postcustomergroupsid)
     * API route.
     *
     * @param id - The customer group's ID.
     * @param body - The details to update in the group.
     * @param query - Configure the fields to retrieve in the customer group.
     * @param headers - Headers to pass in the request.
     * @returns The customer group's details.
     *
     * @example
     * sdk.admin.customerGroup.update("cusgroup_123", {
     *   name: "VIP"
     * })
     * .then(({ customer_group }) => {
     *   console.log(customer_group)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a customer group. This method sends a request to the
     * [Delete Customer Group](https://docs.medusajs.com/api/admin#customer-groups_deletecustomergroupsid)
     * API route.
     *
     * @param id - The customer group's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.customerGroup.delete("cusgroup_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages customers of a group to add or remove them from the group.
     * It sends a request to the [Manage Customers](https://docs.medusajs.com/api/admin#customer-groups_postcustomergroupsidcustomers)
     * API route.
     *
     * @param id - The group's ID.
     * @param body - The customers to add or remove from the group.
     * @param headers - Headers to pass in the request
     * @returns The customer group's details.
     *
     * @example
     * sdk.admin.customerGroup.batchCustomers("cusgroup_123", {
     *   add: ["cus_123"],
     *   remove: ["cus_321"]
     * })
     * .then(({ customer_group }) => {
     *   console.log(customer_group)
     * })
     */ batchCustomers(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/customer-groups/${id}/customers`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=customer-group.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/draft-order.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DraftOrder",
    ()=>DraftOrder
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class DraftOrder {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a draft order by its ID. It sends a request to the
     * [Get Draft Order](https://docs.medusajs.com/api/admin#draft-orders_getdraftordersid)
     * API route.
     *
     * @param id - The draft order's ID.
     * @param query - Configure the fields to retrieve in the draft order.
     * @param headers - Headers to pass in the request
     * @returns The draft order's details.
     *
     * @example
     * To retrieve a draft order by its ID:
     *
     * ```ts
     * sdk.admin.draftOrder.retrieve("order_123")
     * .then(({ draft_order }) => {
     *   console.log(draft_order)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.draftOrder.retrieve("order_123", {
     *   fields: "id,*items"
     * })
     * .then(({ draft_order }) => {
     *   console.log(draft_order)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a paginated list of draft orders. It sends a request to the
     * [List Draft Orders](https://docs.medusajs.com/api/admin#draft-orders_getdraftorders) API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of draft orders.
     *
     * @example
     * To retrieve the list of draft orders:
     *
     * ```ts
     * sdk.admin.draftOrder.list()
     * .then(({ draft_orders, count, limit, offset }) => {
     *   console.log(draft_orders)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.draftOrder.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ draft_orders, count, limit, offset }) => {
     *   console.log(draft_orders)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each draft order:
     *
     * ```ts
     * sdk.admin.draftOrder.list({
     *   fields: "id,*items"
     * })
     * .then(({ draft_orders, count, limit, offset }) => {
     *   console.log(draft_orders)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method creates a draft order. It sends a request to the
     * [Create Draft Order](https://docs.medusajs.com/api/admin#draft-orders_postdraftorders) API route.
     *
     * @param body - The data to create the draft order.
     * @param query - Configure the fields to retrieve in the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order's details.
     *
     * @example
     * sdk.admin.draftOrder.create({
     *   email: "test@test.com",
     *   items: [
     *     {
     *       variant_id: "variant_123",
     *       quantity: 1,
     *     },
     *   ],
     *   region_id: "region_123",
     *   sales_channel_id: "sc_123",
     * })
     * .then(({ draft_order }) => {
     *   console.log(draft_order)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders`, {
                method: "POST",
                body,
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a draft order. It sends a request to the
     * [Delete Draft Order](https://docs.medusajs.com/api/admin#draft-orders_deleteordereditsid) API route.
     *
     * @param id - The draft order's ID.
     * @param headers - Headers to pass in the request.
     *
     * @example
     * sdk.admin.draftOrder.delete("order_123")
     * .then(({ id, object, deleted }) => {
     *   console.log(id, object, deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method updates a draft order. It sends a request to the
     * [Update Draft Order](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersid) API route.
     *
     * @param id - The draft order's ID.
     * @param body - The data to update the draft order.
     * @param query - Configure the fields to retrieve in the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order's details.
     *
     * @example
     * sdk.admin.draftOrder.update("order_123", {
     *   email: "test@test.com",
     * })
     * .then(({ draft_order }) => {
     *   console.log(draft_order)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}`, {
                method: "POST",
                body,
                query,
                headers
            });
        });
    }
    /**
     * This method converts a draft order to an order. It sends a request to the
     * [Convert Draft Order to Order](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersidconverttoorder) API route.
     *
     * @param id - The draft order's ID.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request.
     * @returns The order's details.
     *
     * @example
     * sdk.admin.draftOrder.convertToOrder("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ convertToOrder(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/convert-to-order`, {
                method: "POST",
                query,
                headers
            });
        });
    }
    /**
     * This method adds items to a draft order. It sends a request to the
     * [Add Draft Order Items](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersidedititems) API route.
     *
     * @param id - The draft order's ID.
     * @param body - The data to add the items to the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.addItems("order_123", {
     *   items: [
     *     {
     *       variant_id: "variant_123",
     *       quantity: 1,
     *     },
     *   ],
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ addItems(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/items`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method updates an item that is part of an action in a draft order. It sends a request to the
     * [Update Draft Order Item](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersidedititemsaction_id) API route.
     *
     * @param id - The draft order's ID.
     * @param actionId - The action ID.
     * @param body - The data to update the item.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.updateActionItem("order_123", "action_123", {
     *   quantity: 2,
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ updateActionItem(id, actionId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/items/${actionId}`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method removes an item that is part of an action in a draft order. It sends a request to the
     * [Remove Draft Order Item](https://docs.medusajs.com/api/admin#draft-orders_deletedraftordersidedititemsaction_id) API route.
     *
     * @param id - The draft order's ID.
     * @param actionId - The action ID.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.removeActionItem("order_123", "action_123")
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ removeActionItem(id, actionId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/items/${actionId}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method updates an item in a draft order. It sends a request to the
     * [Update Draft Order Item](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersidedititemsitemitem_id) API route.
     *
     * @param id - The draft order's ID.
     * @param itemId - The item ID.
     * @param body - The data to update the item.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.updateItem("order_123", "item_123", {
     *   quantity: 2,
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ updateItem(id, itemId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/items/item/${itemId}`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method adds promotions to a draft order. It sends a request to the
     * [Add Draft Order Promotions](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditpromotions) API route.
     *
     * @param id - The draft order's ID.
     * @param body - The data to add the promotions to the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.addPromotions("order_123", {
     *   promo_codes: ["PROMO_CODE_1", "PROMO_CODE_2"],
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ addPromotions(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/promotions`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method removes promotions from a draft order. It sends a request to the
     * [Remove Draft Order Promotions](https://docs.medusajs.com/api/admin#draft-orders_deletedraftordersideditpromotions) API route.
     *
     * @param id - The draft order's ID.
     * @param body - The data to remove the promotions from the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.removePromotions("order_123", {
     *   promo_codes: ["PROMO_CODE_1", "PROMO_CODE_2"],
     * })
     */ removePromotions(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/promotions`, {
                method: "DELETE",
                body,
                headers
            });
        });
    }
    /**
     * This method adds a shipping method to a draft order. It sends a request to the
     * [Add Draft Order Shipping Method](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditshippingmethods) API route.
     *
     * @param id - The draft order's ID.
     * @param body - The data to add the shipping method to the draft order.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.addShippingMethod("order_123", {
     *   shipping_option_id: "shipping_option_123",
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ addShippingMethod(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/shipping-methods`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method updates a shipping method in a draft order. It sends a request to the
     * [Update Draft Order Shipping Method](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditshippingmethodsaction_id) API route.
     *
     * @param id - The draft order's ID.
     * @param actionId - The action ID.
     * @param body - The data to update the shipping method.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.updateShippingMethod("order_123", "action_123", {
     *   shipping_option_id: "shipping_option_123",
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ updateActionShippingMethod(id, actionId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/shipping-methods/${actionId}`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method removes a shipping method from a draft order. It sends a request to the
     * [Remove Draft Order Shipping Method](https://docs.medusajs.com/api/admin#draft-orders_deletedraftordersideditshippingmethodsaction_id) API route.
     *
     * @param id - The draft order's ID.
     * @param actionId - The action ID.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.removeShippingMethod("order_123", "action_123")
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ removeActionShippingMethod(id, actionId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/shipping-methods/${actionId}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method removes a shipping method from an edited draft order. It sends a request to the
     * [Remove Draft Order Shipping Method](https://docs.medusajs.com/api/admin#draft-orders_deletedraftordersideditshippingmethodsmethodmethod_id) API route.
     *
     * @param id - The draft order's ID.
     * @param shippingMethodId - The shipping method's ID.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.removeShippingMethod(
     *   "order_123",
     *   "shipping_method_123"
     * )
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ removeShippingMethod(id, shippingMethodId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/shipping-methods/method/${shippingMethodId}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method updates a shipping method in a draft order. It sends a request to the
     * [Update Draft Order Shipping Method](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditshippingmethodsmethodmethod_id) API route.
     *
     * @param id - The draft order's ID.
     * @param methodId - The shipping method's ID.
     * @param body - The data to update the shipping method.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.updateShippingMethod("order_123", "sm_123", {
     *  shipping_option_id: "so_123",
     * })
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ updateShippingMethod(id, methodId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/shipping-methods/method/${methodId}`, {
                method: "POST",
                body,
                headers
            });
        });
    }
    /**
     * This method begins an edit to a draft order. It sends a request to the
     * [Begin Draft Order Edit](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersidedit) API route.
     *
     * @param id - The draft order's ID.
     * @param headers - Headers to pass in the request.
     *
     * @example
     * sdk.admin.draftOrder.beginEdit("order_123")
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ beginEdit(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method cancels an edit to a draft order. It sends a request to the
     * [Cancel Draft Order Edit](https://docs.medusajs.com/api/admin#draft-orders_deletedraftordersidedit) API route.
     *
     * @param id - The draft order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The cancelation's details.
     *
     * @example
     * sdk.admin.draftOrder.cancelEdit("order_123")
     * .then(({ id, object, deleted }) => {
     *   console.log(id, object, deleted)
     * })
     */ cancelEdit(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method requests an edit to a draft order. It sends a request to the
     * [Request Draft Order Edit](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditrequest) API route.
     *
     * @param id - The draft order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.requestEdit("order_123")
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ requestEdit(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/request`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method confirms an edit to a draft order. It sends a request to the
     * [Confirm Draft Order Edit](https://docs.medusajs.com/api/admin#draft-orders_postdraftordersideditconfirm) API route.
     *
     * @param id - The draft order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The draft order preview's details.
     *
     * @example
     * sdk.admin.draftOrder.confirmEdit("order_123")
     * .then(({ draft_order_preview }) => {
     *   console.log(draft_order_preview)
     * })
     */ confirmEdit(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/draft-orders/${id}/edit/confirm`, {
                method: "POST",
                headers
            });
        });
    }
} //# sourceMappingURL=draft-order.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/exchange.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Exchange",
    ()=>Exchange
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Exchange {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of exchanges. It sends a request to the
     * [List Exchanges](https://docs.medusajs.com/api/admin#exchanges_getexchanges)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of exchanges.
     *
     * @example
     * To retrieve the list of exchanges:
     *
     * ```ts
     * sdk.admin.exchange.list()
     * .then(({ exchanges, count, limit, offset }) => {
     *   console.log(exchanges)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.exchange.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ exchanges, count, limit, offset }) => {
     *   console.log(exchanges)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each exchange:
     *
     * ```ts
     * sdk.admin.exchange.list({
     *   fields: "id,*order"
     * })
     * .then(({ exchanges, count, limit, offset }) => {
     *   console.log(exchanges)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves an exchange by its ID. It sends a request to the
     * [Get Exchange](https://docs.medusajs.com/api/admin#exchanges_getexchangesid)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request.
     * @returns The exchange's details.
     *
     * @example
     * To retrieve an exchange by its ID:
     *
     * ```ts
     * sdk.admin.exchange.retrieve("exchange_123")
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.exchange.retrieve("exchange_123", {
     *   fields: "id,*order"
     * })
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method creates an admin exchange. It sends a request to the
     * [Create Exchange](https://docs.medusajs.com/api/admin#exchanges_postexchanges) API route.
     *
     * @param body - The exchange's details.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request.
     * @returns The exchange's details.
     *
     * @example
     * sdk.admin.exchange.create({
     *   order_id: "order_123"
     * })
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels an exchange. It sends a request to the
     * [Cancel Exchange](https://docs.medusajs.com/api/admin#exchanges_postexchangesidcancel) API route.
     *
     * @param id - The exchange's ID.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request.
     * @returns The exchange's details.
     *
     * @example
     * sdk.admin.exchange.cancel("exchange_123")
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ cancel(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/cancel`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method adds inbound (or return) items to an exchange. These inbound items will
     * have the action `RETURN_ITEM`.
     *
     * This method sends a request to the [Add Inbound Items](https://docs.medusajs.com/api/admin#exchanges_postexchangesidinbounditems)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param body - The items to add.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.addInboundItems("exchange_123", {
     *   items: [{
     *     id: "orli_123",
     *     quantity: 1
     *   }]
     * })
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ addInboundItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an inbound (or return) item from an exchange using the ID of
     * the item's `RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can
     * check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Update Inbound Item](https://docs.medusajs.com/api/admin#exchanges_postexchangesidinbounditemsaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the return item's `RETURN_ITEM` action.
     * @param body - The details to update.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.updateInboundItem(
     *   "exchange_123",
     *   "ordchact_123",
     *   {
     *     quantity: 1
     *   }
     * )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ updateInboundItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an inbound (or return) item from an exchange using the ID of the
     * item's `RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Remove Inbound Item](https://docs.medusajs.com/api/admin#exchanges_deleteexchangesidinbounditemsaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the return item's `RETURN_ITEM` action.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.removeInboundItem(
     *   "exchange_123",
     *   "ordchact_123",
     * )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ removeInboundItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds an inbound (or return) shipping method to an exchange.
     * The inbound shipping method will have a `SHIPPING_ADD` action.
     *
     * This method sends a request to the [Add Inbound Shipping](https://docs.medusajs.com/api/admin#exchanges_postexchangesidinboundshippingmethod)
     * API route.
     *
     * This method sends a request to the [Add Inbound Shipping](https://docs.medusajs.com/api/admin#exchanges_postexchangesidinboundshippingmethod)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param body - The shipping method's details.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.addInboundShipping("exchange_123", {
     *   shipping_option_id: "so_123"
     * })
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ addInboundShipping(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates the shipping method for returning items in the exchange using the ID
     * of the method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Update Inbound Shipping](https://docs.medusajs.com/api/admin#exchanges_postexchangesidinboundshippingmethodaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param body - The details to update.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.updateInboundShipping(
     *   "exchange_123",
     *   "ordchact_123",
     *    {
     *     custom_amount: 10
     *   }
     * )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ updateInboundShipping(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes the shipping method for returning items in the exchange using the ID
     * of the method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Remove Inbound Shipping](https://docs.medusajs.com/api/admin#exchanges_deleteexchangesidinboundshippingmethodaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param query - Configure the fields to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The details of the return associated with the exchange, with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.deleteInboundShipping(
     *   "exchange_123",
     *   "ordchact_123",
     * )
     * .then(({ return: returnData }) => {
     *   console.log(returnData)
     * })
     */ deleteInboundShipping(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds outbound (or new) items to an exchange.
     * These outbound items will have the action `ITEM_ADD`.
     *
     * This method sends a request to the [Add Outbound Items](https://docs.medusajs.com/api/admin#exchanges_postexchangesidoutbounditems)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param body - The items to add.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.addOutboundItems("exchange_123", {
     *   items: [{
     *     id: "variant_123",
     *     quantity: 1
     *   }]
     * })
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ addOutboundItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an outbound (or new) item from an exchange using the ID
     * of the item's `ITEM_ADD` action.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Update Inbound Item](https://docs.medusajs.com/api/admin#exchanges_postexchangesidoutbounditemsaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the new exchange item's `ITEM_ADD` action.
     * @param body - The item's details to update.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.updateOutboundItem(
     *   "exchange_123",
     *   "ordchact_123",
     *   {
     *     quantity: 1
     *   }
     * )
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ updateOutboundItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an outbound (or new) item from an exchange using the ID
     * of the item's `ITEM_ADD` action.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Update Outbound Item](https://docs.medusajs.com/api/admin#exchanges_deleteexchangesidoutbounditemsaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the new exchange item's `ITEM_ADD` action.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.removeOutboundItem(
     *   "exchange_123",
     *   "ordchact_123",
     * )
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ removeOutboundItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds an outbound shipping method to an exchange. The outbound shipping method
     * will have a `SHIPPING_ADD` action.
     *
     * This method sends a request to the [Add Outbound Shipping](https://docs.medusajs.com/api/admin#exchanges_postexchangesidoutboundshippingmethod)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param body - The shipping method's details.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.addOutboundShipping("exchange_123", {
     *   shipping_option_id: "so_123"
     * })
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ addOutboundShipping(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates the shipping method for delivering outbound items in the exchange using
     * the ID of the method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Update Outbound Shipping](https://docs.medusajs.com/api/admin#exchanges_postexchangesidoutboundshippingmethodaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param body - The details to update.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.updateOutboundShipping(
     *   "exchange_123",
     *   "ordchact_123",
     *   {
     *     custom_amount: 10
     *   }
     * )
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ updateOutboundShipping(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes the shipping method for delivering outbound items in the exchange using
     * the ID of the method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * This method sends a request to the [Remove Outbound Shipping](https://docs.medusajs.com/api/admin#exchanges_deleteexchangesidoutboundshippingmethodaction_id)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param actionId - The id of the shipping method's `SHIPPING_ADD` action.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.deleteOutboundShipping(
     *   "exchange_123",
     *   "ordchact_123",
     * )
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ deleteOutboundShipping(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method confirms an exchange request, applying its changes on the associated order.
     *
     * This method sends a request to the [Confirm Exchange](https://docs.medusajs.com/api/admin#exchanges_postexchangesidrequest)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param body - The confirmation's details.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The exchange and associated return's details with a preview of the order when the exchange is applied.
     *
     * @example
     * sdk.admin.exchange.request("exchange_123", {})
     * .then(({ exchange }) => {
     *   console.log(exchange)
     * })
     */ request(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/request`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels an exchange request. It sends a request to the
     * [Cancel Exchange Request](https://docs.medusajs.com/api/admin#exchanges_deleteexchangesidrequest)
     * API route.
     *
     * @param id - The exchange's ID.
     * @param query - Configure the fields to retrieve in the exchange.
     * @param headers - Headers to pass in the request
     * @returns The cancelation's details.
     *
     * @example
     * sdk.admin.exchange.cancel("exchange_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ cancelRequest(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/exchanges/${id}/request`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=exchange.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Fulfillment",
    ()=>Fulfillment
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Fulfillment {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a fulfillment. It sends a request to the
     * [Create Fulfillment](https://docs.medusajs.com/api/admin#fulfillments_postfulfillments)
     * API route.
     *
     * @param body - The fulfillment's details.
     * @param query - Configure the fields to retrieve in the fulfillment.
     * @param headers - Headers to pass in the request.
     * @returns The fulfillment's details.
     *
     * @example
     * sdk.admin.fulfillment.create({
     *   location_id: "sloc_123",
     *   provider_id: "my_fulfillment",
     *   delivery_address: {
     *     country_code: "us"
     *   },
     *   items: [
     *     {
     *       title: "Shirt",
     *       sku: "SHIRT",
     *       quantity: 1,
     *       barcode: "123"
     *     }
     *   ],
     *   labels: [],
     *   order: {},
     *   order_id: "order_123"
     * })
     * .then(({ fulfillment }) => {
     *   console.log(fulfillment)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillments`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels a fulfillment. It sends a request to the
     * [Cancel Fulfillment](https://docs.medusajs.com/api/admin#fulfillments_postfulfillmentsidcancel)
     * API route.
     *
     * @param id - The fulfillment's ID.
     * @param query - Configure the fields to retrieve in the fulfillment.
     * @param headers - Headers to pass in the request.
     * @returns The fulfillment's details.
     *
     * @example
     * sdk.admin.fulfillment.cancel("ful_123")
     * .then(({ fulfillment }) => {
     *   console.log(fulfillment)
     * })
     */ cancel(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillments/${id}/cancel`, {
                method: "POST",
                body: {},
                headers,
                query
            });
        });
    }
    /**
     * This method creates a shipment for a fulfillment. It sends a request to the
     * [Create Shipment](https://docs.medusajs.com/api/admin#fulfillments_postfulfillmentsidshipment)
     * API route.
     *
     * @param id - The fulfillment's ID.
     * @param body - The shipment's details.
     * @param query - Configure the fields to retrieve in the fulfillment.
     * @param headers - Headers to pass in the request.
     * @returns The fulfillment's details.
     *
     * @example
     * sdk.admin.fulfillment.createShipment("ful_123", {
     *   labels: [
     *     {
     *       tracking_number: "123",
     *       tracking_url: "example.com",
     *       label_url: "example.com"
     *     }
     *   ]
     * })
     * .then(({ fulfillment }) => {
     *   console.log(fulfillment)
     * })
     */ createShipment(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillments/${id}/shipment`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=fulfillment.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-provider.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FulfillmentProvider",
    ()=>FulfillmentProvider
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class FulfillmentProvider {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of fulfillment providers. It sends a request to the
     * [List Fulfillment Providers](https://docs.medusajs.com/api/admin#fulfillment-providers_getfulfillmentproviders)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of providers.
     *
     * @example
     * To retrieve the list of fulfillment providers:
     *
     * ```ts
     * sdk.admin.fulfillmentProvider.list()
     * .then(({ fulfillment_providers, count, limit, offset }) => {
     *   console.log(fulfillment_providers)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.fulfillmentProvider.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ fulfillment_providers, count, limit, offset }) => {
     *   console.log(fulfillment_providers)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each fulfillment provider:
     *
     * ```ts
     * sdk.admin.fulfillmentProvider.list({
     *   fields: "id"
     * })
     * .then(({ fulfillment_providers, count, limit, offset }) => {
     *   console.log(fulfillment_providers)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-providers`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of fulfillment options for a given fulfillment provider. It sends a request to the
     * [List Fulfillment Options](https://docs.medusajs.com/api/admin#fulfillment-providers_getfulfillmentprovidersidoptions)
     * API route.
     *
     * @param id - The ID of the fulfillment provider.
     * @param headers - Headers to pass in the request.
     * @returns The list of fulfillment options.
     *
     * @example
     * sdk.admin.fulfillmentProvider.listFulfillmentOptions("fp_123")
     * .then(({ fulfillment_options }) => {
     *   console.log(fulfillment_options)
     * })
     */ listFulfillmentOptions(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-providers/${id}/options`, {
                method: "GET",
                headers
            });
        });
    }
} //# sourceMappingURL=fulfillment-provider.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-set.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FulfillmentSet",
    ()=>FulfillmentSet
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class FulfillmentSet {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method deletes a fulfillment set. It sends a request to the
     * [Delete Fulfillment Set](https://docs.medusajs.com/api/admin#fulfillment-sets_deletefulfillmentsetsid)
     * API route.
     *
     * @param id - The fulfillment set's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.fulfillmentSet.delete("fset_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-sets/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method adds a service zone to a fulfillment set. It uses the
     * [Add Service Zone](https://docs.medusajs.com/api/admin#fulfillment-sets_postfulfillmentsetsidservicezones)
     * API route.
     *
     * @param id - The fulfillment set's ID.
     * @param body - The service zone's details.
     * @param query - Configure the fields to retrieve in the fulfillment set.
     * @param headers - Headers to pass in the request.
     * @returns The fulfillment set's details.
     *
     * @example
     * sdk.admin.fulfillmentSet.createServiceZone("fset_123", {
     *   name: "Europe Service Zone",
     *   geo_zones: [{
     *     type: "country",
     *     country_code: "us"
     *   }]
     * })
     * .then(({ fulfillment_set }) => {
     *   console.log(fulfillment_set)
     * })
     */ createServiceZone(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-sets/${id}/service-zones`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a fulfillment set's service zone's details. It sends a request to the
     * [Get Service Zone](https://docs.medusajs.com/api/admin#fulfillment-sets_getfulfillmentsetsidservicezoneszone_id)
     * API route.
     *
     * @param fulfillmentSetId - The fulfillment set's ID.
     * @param serviceZoneId - The service zone's ID.
     * @param query - Configure the fields to retrieve in the service zone.
     * @param headers - Headers to pass in the request.
     * @returns The service zone's details.
     *
     * @example
     * To retrieve a fulfillment set's service zone by its ID:
     *
     * ```ts
     * sdk.admin.fulfillmentSet.retrieveServiceZone(
     *   "fset_123",
     *   "serzo_123"
     * )
     * .then(({ service_zone }) => {
     *   console.log(service_zone)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.fulfillmentSet.retrieveServiceZone(
     *   "fset_123",
     *   "serzo_123",
     *   {
     *     fields: "id,*geo_zones"
     *   }
     * )
     * .then(({ service_zone }) => {
     *   console.log(service_zone)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieveServiceZone(fulfillmentSetId, serviceZoneId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method updates a service zone in a fulfillment set. It sends a request to the
     * [Update Service Zone](https://docs.medusajs.com/api/admin#fulfillment-sets_postfulfillmentsetsidservicezoneszone_id)
     * API route.
     *
     * @param fulfillmentSetId - The fulfillment set's ID.
     * @param serviceZoneId - The service zone's ID.
     * @param body - The data to update in the service zone.
     * @param query - Configure the fields to retrieve in the fulfillment set.
     * @param headers - Headers to pass in the request.
     * @returns The fulfillment set's details.
     *
     * @example
     * sdk.admin.fulfillmentSet.updateServiceZone(
     *   "fset_123",
     *   "serzo_123",
     *   {
     *     name: "Europe Service Zone",
     *   }
     * )
     * .then(({ fulfillment_set }) => {
     *   console.log(fulfillment_set)
     * })
     */ updateServiceZone(fulfillmentSetId, serviceZoneId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a service zone in a fulfillment set. It sends a request to the
     * [Remove Service Zone](https://docs.medusajs.com/api/admin#fulfillment-sets_deletefulfillmentsetsidservicezoneszone_id)
     * API route.
     *
     * @param fulfillmentSetId - The fulfullment set's ID.
     * @param serviceZoneId - The service zone's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.fulfillmentSet.deleteServiceZone(
     *   "fset_123",
     *   "serzo_123",
     * )
     * .then(({ deleted, parent: fulfillmentSet }) => {
     *   console.log(deleted, fulfillmentSet)
     * })
     */ deleteServiceZone(fulfillmentSetId, serviceZoneId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=fulfillment-set.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/inventory-item.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InventoryItem",
    ()=>InventoryItem
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class InventoryItem {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates an inventory item. It sends a request to the
     * [Create Inventory Item](https://docs.medusajs.com/api/admin#inventory-items_postinventoryitems)
     * API route.
     *
     * @param body - The inventory item's details.
     * @param query - Configure the fields to retrieve in the inventory item.
     * @param headers - Headers to pass in the request.
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.create({
     *   sku: "SHIRT"
     * })
     * .then(({ inventory_item }) => {
     *   console.log(inventory_item)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an inventory level. It sends a request to the
     * [Update Inventory Item](https://docs.medusajs.com/api/admin#inventory-items_postinventoryitemsid)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param body - The data to update.
     * @param query - Configure the fields to retrieve in the inventory item.
     * @param headers - Headers to pass in the request.
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.update("iitem_123", {
     *   sku: "SHIRT"
     * })
     * .then(({ inventory_item }) => {
     *   console.log(inventory_item)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of inventory items. It sends a request to the
     * [List Inventory Items](https://docs.medusajs.com/api/admin#inventory-items_getinventoryitems)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of inventory items.
     *
     * @example
     * To retrieve the list of inventory items:
     *
     * ```ts
     * sdk.admin.inventoryItem.list()
     * .then(({ inventory_items, count, limit, offset }) => {
     *   console.log(inventory_items)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.inventoryItem.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ inventory_items, count, limit, offset }) => {
     *   console.log(inventory_items)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each inventory item:
     *
     * ```ts
     * sdk.admin.inventoryItem.list({
     *   fields: "id,*location_levels"
     * })
     * .then(({ inventory_items, count, limit, offset }) => {
     *   console.log(inventory_items)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves an inventory item by its ID. It sends a request to the
     * [Get Inventory Item](https://docs.medusajs.com/api/admin#inventory-items_getinventoryitemsid) API route.
     *
     * @param id - The inventory item's ID.
     * @param query - Configure the fields to retrieve in the inventory item.
     * @param headers - Headers to pass in the request
     * @returns The inventory item's details.
     *
     * @example
     * To retrieve an inventory item by its ID:
     *
     * ```ts
     * sdk.admin.inventoryItem.retrieve("iitem_123")
     * .then(({ inventory_item }) => {
     *   console.log(inventory_item)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.inventoryItem.retrieve("iitem_123", {
     *   fields: "id,*location_levels"
     * })
     * .then(({ inventory_item }) => {
     *   console.log(inventory_item)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes an inventory item. This sends a request to the
     * [Delete Inventory Item](https://docs.medusajs.com/api/admin#inventory-items_deleteinventoryitemsid)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.inventoryItem.delete("iitem_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a paginated list of inventory levels that belong to an inventory item.
     * It sends a request to the [List Inventory Items](https://docs.medusajs.com/api/admin#inventory-items_getinventoryitems)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of inventory levels.
     *
     * @example
     * To retrieve the list of inventory levels:
     *
     * ```ts
     * sdk.admin.inventoryItem.listLevels("iitem_123")
     * .then(({ inventory_levels, count, limit, offset }) => {
     *   console.log(inventory_levels)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.inventoryItem.listLevels("iitem_123", {
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ inventory_levels, count, limit, offset }) => {
     *   console.log(inventory_levels)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each inventory level:
     *
     * ```ts
     * sdk.admin.inventoryItem.listLevels("iitem_123", {
     *   fields: "id,*inventory_item"
     * })
     * .then(({ inventory_levels, count, limit, offset }) => {
     *   console.log(inventory_levels)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ listLevels(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels`, {
                query,
                headers
            });
        });
    }
    /**
     * This method updates the inventory level of the specified inventory item and
     * stock location.
     *
     * This method sends a request to the
     * [Update Inventory Level](https://docs.medusajs.com/api/admin#inventory-items_postinventoryitemsidlocationlevelslocation_id)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param locationId - The stock location's ID.
     * @param body - The details to update.
     * @param query - Configure the fields to retrieve in the inventory item.
     * @param headers - Headers to pass in the request
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.updateLevel(
     *   "iitem_123",
     *   "sloc_123",
     *   {
     *     stocked_quantity: 10
     *   }
     * )
     * .then(({ inventory_item }) => {
     *   console.log(inventory_item)
     * })
     */ updateLevel(id, locationId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/${locationId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes an inventory level associated with an inventory item
     * and a stock location.
     *
     * This method sends a request to the
     * [Remove Inventory Level](https://docs.medusajs.com/api/admin#inventory-items_deleteinventoryitemsidlocationlevelslocation_id)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param locationId - The stock location's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.inventoryItem.deleteLevel(
     *   "iitem_123",
     *   "sloc_123",
     * )
     * .then(({ deleted, parent: inventoryItem }) => {
     *   console.log(deleted, inventoryItem)
     * })
     */ deleteLevel(id, locationId, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/${locationId}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the inventory levels of an inventory item. It sends a request to the
     * [Manage Inventory Levels](https://docs.medusajs.com/api/admin#inventory-items_postinventoryitemsidlocationlevelsbatch)
     * API route.
     *
     * @deprecated Use `batchInventoryItemLocationLevels` instead.
     *
     * @param id - The inventory item's ID.
     * @param body - The inventory levels to create or delete.
     * @param query - Configure the fields to retrieve in the inventory item.
     * @param headers - Headers to pass in the request
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.batchUpdateLevels("iitem_123", {
     *   create: [{
     *     location_id: "sloc_123",
     *     stocked_quantity: 10
     *   }],
     *   delete: ["ilvl_123"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchUpdateLevels(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/batch`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method manages the inventory levels of an inventory item. It sends a request to the
     * [Manage Inventory Levels](https://docs.medusajs.com/api/admin#inventory-items_postinventoryitemsidlocationlevelsbatch)
     * API route.
     *
     * @param id - The inventory item's ID.
     * @param body - The inventory levels to create, update or delete, and an optional `force` flag.
     * @param headers - Headers to pass in the request
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.batchInventoryItemLocationLevels("iitem_123", {
     *   create: [{
     *     location_id: "sloc_123",
     *     stocked_quantity: 10
     *   }],
     *   delete: ["ilvl_123"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchInventoryItemLocationLevels(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/batch`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method manages the inventory levels of multiple inventory items.
     *
     * @param body - The inventory levels to create, update or delete, and an optional `force` flag.
     * @param headers - Headers to pass in the request
     * @returns The inventory item's details.
     *
     * @example
     * sdk.admin.inventoryItem.batchInventoryItemsLocationLevels({
     *   create: [{
     *     inventory_item_id: "iitem_123",
     *     location_id: "sloc_123",
     *     stocked_quantity: 10
     *   }],
     *   delete: ["ilvl_123"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchInventoryItemsLocationLevels(body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/inventory-items/location-levels/batch`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=inventory-item.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/invite.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Invite",
    ()=>Invite
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
class Invite {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method accepts an invite. It requires sending a previous request to
     * the {@link Auth.register}.
     *
     * This method sends a request to the [Accept Invite]
     * (https://docs.medusajs.com/api/admin#invites_postinvitesaccept)
     * API route.
     *
     * @param input - The details of the user to create.
     * @param query - Configure the fields to retrieve in the user.
     * @param headers - Headers to pass in the request
     * @returns The user's details.
     *
     * @example
     * await sdk.auth.register("user", "emailpass", {
     *   email: "user@gmail.com",
     *   password: "supersecret"
     * })
     *
     * // all subsequent requests will use the token in the header
     * const { user } = await sdk.admin.invite.accept(
     *   {
     *     email: "user@gmail.com",
     *     first_name: "John",
     *     last_name: "Smith",
     *     invite_token: "12345..."
     *   },
     * )
     */ accept(input, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            const { invite_token } = input, rest = __rest(input, [
                "invite_token"
            ]);
            return yield this.client.fetch(`/admin/invites/accept?token=${input.invite_token}`, {
                method: "POST",
                headers,
                body: rest,
                query
            });
        });
    }
    /**
     * This method creates an invite. It sends a request to the
     * [Create Invite](https://docs.medusajs.com/api/admin#invites_postinvites)
     * API route.
     *
     * @param body - The invite's details.
     * @param query - Configure the fields to retrieve in the invite.
     * @param headers - Headers to pass in the request
     * @returns The invite's details.
     *
     * @example
     * sdk.admin.invite.create({
     *   email: "user@gmail.com",
     * })
     * .then(({ invite }) => {
     *   console.log(invite)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/invites`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves an invite by its ID. It sends a request to the
     * [Get Invite](https://docs.medusajs.com/api/admin#invites_getinvitesid)
     * API route.
     *
     * @param id - The invite's ID.
     * @param query - Configure the fields to retrieve in the invite.
     * @param headers - Headers to pass in the request
     * @returns The invite's details.
     *
     * @example
     * To retrieve an invite its ID:
     *
     * ```ts
     * sdk.admin.invite.retrieve("invite_123")
     * .then(({ invite }) => {
     *   console.log(invite)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.invite.retrieve("invite_123", {
     *   fields: "id,email"
     * })
     * .then(({ invite }) => {
     *   console.log(invite)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/invites/${id}`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of invites. It sends a request to the
     * [List Invites](https://docs.medusajs.com/api/admin#invites_getinvites)
     * API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of invites.
     *
     * @example
     * To retrieve the list of invites:
     *
     * ```ts
     * sdk.admin.invite.list()
     * .then(({ invites, count, limit, offset }) => {
     *   console.log(invites)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.invite.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ invites, count, limit, offset }) => {
     *   console.log(invites)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each invite:
     *
     * ```ts
     * sdk.admin.invite.list({
     *   fields: "id,email"
     * })
     * .then(({ invites, count, limit, offset }) => {
     *   console.log(invites)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/invites`, {
                headers,
                query: queryParams
            });
        });
    }
    /**
     * This method refreshes the token of an invite. It sends a request to the
     * [Refresh Invite Token](https://docs.medusajs.com/api/admin#invites_postinvitesidresend)
     * API route.
     *
     * @param id - The invite's ID.
     * @param headers - Headers to pass in the request.
     * @returns The invite's details.
     *
     * @example
     * sdk.admin.invite.resend("invite_123")
     * .then(({ invite }) => {
     *   console.log(invite)
     * })
     */ resend(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/invites/${id}/resend`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method deletes an invite. It sends a request to the
     * [Delete Invite](https://docs.medusajs.com/api/admin#invites_deleteinvitesid)
     * API route.
     *
     * @param id - The invite's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.invite.delete("invite_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/invites/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=invite.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/notification.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Notification",
    ()=>Notification
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Notification {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a notification's details. It sends a request to the
     * [Get Notification](https://docs.medusajs.com/api/admin#notifications_getnotificationsid)
     * API route.
     *
     * @param id - The notification's ID.
     * @param query - Configure the fields to retrieve in the notification.
     * @param headers - Headers to pass in the request
     * @returns The notification's details.
     *
     * @example
     * To retrieve a notification by its ID:
     *
     * ```ts
     * sdk.admin.notification.retrieve("notif_123")
     * .then(({ notification }) => {
     *   console.log(notification)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.notification.retrieve("notif_123", {
     *   fields: "id,to"
     * })
     * .then(({ notification }) => {
     *   console.log(notification)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/notifications/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of notifications. It sends a request to the
     * [List Notifications](https://docs.medusajs.com/api/admin#notifications_getnotifications)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of notifications.
     *
     * @example
     * To retrieve the list of notifications:
     *
     * ```ts
     * sdk.admin.notification.list()
     * .then(({ notifications, count, limit, offset }) => {
     *   console.log(notifications)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.notification.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ notifications, count, limit, offset }) => {
     *   console.log(notifications)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each notification:
     *
     * ```ts
     * sdk.admin.notification.list({
     *   fields: "id,to"
     * })
     * .then(({ notifications, count, limit, offset }) => {
     *   console.log(notifications)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/notifications`, {
                method: "GET",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=notification.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/order.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Order",
    ()=>Order
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Order {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves an order by its ID. It sends a request to the
     * [Get Order](https://docs.medusajs.com/api/admin#orders_getordersid)
     * API route.
     *
     * @param id - The order's ID.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * To retrieve an order by its ID:
     *
     * ```ts
     * sdk.admin.order.retrieve("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.order.retrieve("order_123", {
     *   fields: "id,*items"
     * })
     * .then(({ order }) => {
     *   console.log(order)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method updates an order. It sends a request to the
     * [Update Order Email](https://docs.medusajs.com/api/admin#orders_postordersid)
     * API route.
     *
     * @param id - The order's ID.
     * @param body - The update details.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.update(
     *   "order_123",
     *   {
     *     email: "new_email@example.com",
     *     shipping_address: {
     *       first_name: "John",
     *       last_name: "Doe",
     *       address_1: "123 Main St",
     *     }
     *   }
     * )
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ update(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method retrieves the preview of an order based on its last associated change. It sends a request to the
     * [Get Order Preview](https://docs.medusajs.com/api/admin#orders_getordersidpreview) API route.
     *
     * @param id - The order's ID.
     * @param query - Query parameters.
     * @param headers - Headers to pass in the request
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.order.retrievePreview("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ retrievePreview(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/preview`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a paginated list of orders. It sends a request to the
     * [List Orders](https://docs.medusajs.com/api/admin#orders_getorders) API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of orders.
     *
     * @example
     * To retrieve the list of orders:
     *
     * ```ts
     * sdk.admin.order.list()
     * .then(({ orders, count, limit, offset }) => {
     *   console.log(orders)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.order.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ orders, count, limit, offset }) => {
     *   console.log(orders)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each order:
     *
     * ```ts
     * sdk.admin.order.list({
     *   fields: "id,*items"
     * })
     * .then(({ orders, count, limit, offset }) => {
     *   console.log(orders)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method archives an order. It sends a request to the
     * [Archive Order](https://docs.medusajs.com/api/admin#orders_postordersidarchive)
     * API route.
     *
     * @param id - The order's ID.
     * @param queryParams - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.archive("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ archive(id, queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/archive`, {
                method: "POST",
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method cancels an order. It sends a request to the
     * [Cancel Order](https://docs.medusajs.com/api/admin#orders_postordersidcancel)
     * API route.
     *
     * @param id - The order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.cancel("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ cancel(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/cancel`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method completes an order. It sends a request to the
     * [Complete Order](https://docs.medusajs.com/api/admin#orders_postordersidcomplete)
     * API route.
     *
     * @param id - The order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.complete("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ complete(id, body, queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/complete`, {
                method: "POST",
                body,
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method requests an order transfer. It sends a request to the
     * [Request Order Transfer](https://docs.medusajs.com/api/admin#orders_postordersidrequesttransfer)
     * API route.
     *
     * @param id - The order's ID.
     * @param headers - Headers to pass in the request.
     * @param body - The transfer's details - the id of the next owner.
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.requestTransfer("order_123", {
     *   customer_id: "cus_123",
     *   internal_note: "Internal note",
     * })
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ requestTransfer(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/transfer`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method cancels an order transfer request. It sends a request to the
     * [Cancel Order Transfer Request](https://docs.medusajs.com/api/admin#orders_postordersidcanceltransferrequest)
     * API route.
     *
     * @param id - The order's ID.
     * @param headers - Headers to pass in the request.
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.cancelTransfer("order_123")
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ cancelTransfer(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/transfer/cancel`, {
                method: "POST",
                headers
            });
        });
    }
    /**
     * This method creates a fulfillment for an order. It sends a request to the
     * [Create Fulfillment](https://docs.medusajs.com/api/admin#orders_postordersidfulfillments)
     * API route.
     *
     * @param id - The order's ID.
     * @param body - The fulfillment's details.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.createFulfillment("order_123", {
     *   items: [
     *     {
     *       id: "orli_123",
     *       quantity: 1
     *     }
     *   ]
     * })
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ createFulfillment(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/fulfillments`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels an order's fulfillment. It sends a request to the
     * [Cancel Fulfillment](https://docs.medusajs.com/api/admin#orders_postordersidfulfillmentsfulfillment_idcancel)
     * API route.
     *
     * @param id - The order's ID.
     * @param fulfillmentId - The ID of the fulfillment to cancel.
     * @param body - The cancelation's details.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.cancelFulfillment(
     *   "order_123",
     *   "ful_123",
     *   {
     *     no_notification: false
     *   }
     * )
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ cancelFulfillment(id, fulfillmentId, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/cancel`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method creates a shipment for an order's fulfillment. It sends a request to the
     * [Create Shipment](https://docs.medusajs.com/api/admin#orders_postordersidfulfillmentsfulfillment_idshipments)
     * API route.
     *
     * @param id - The order's ID.
     * @param fulfillmentId - The ID of the fulfillment.
     * @param body - The shipment's details.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.createShipment(
     *   "order_123",
     *   "ful_123",
     *   {
     *     items: [
     *       {
     *         id: "fulit_123",
     *         quantity: 1
     *       }
     *     ]
     *   }
     * )
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ createShipment(id, fulfillmentId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/shipments`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method marks an order's fulfillment as delivered. It sends a request to the
     * [Mark Delivered ](https://docs.medusajs.com/api/admin#orders_postordersidfulfillmentsfulfillment_idmarkasdelivered)
     * API route.
     *
     * @param id - The order's ID.
     * @param fulfillmentId - The fulfillment's ID.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.markAsDelivered(
     *   "order_123",
     *   "ful_123",
     * )
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ markAsDelivered(id, fulfillmentId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/mark-as-delivered`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of shipping options for an order based on the order's shipping address.
     *
     * This method sends a request to the [List Shipping Options](https://docs.medusajs.com/api/admin#orders_getordersidshipping-options)
     * API route.
     *
     * @param id - The order's ID.
     * @param queryParams - Configure the fields to retrieve in each shipping option.
     * @param headers - Headers to pass in the request
     * @returns The list of shipping options.
     *
     * @example
     * sdk.admin.order.listShippingOptions("order_123")
     * .then(({ shipping_options }) => {
     *   console.log(shipping_options)
     * })
     */ listShippingOptions(id, queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/shipping-options`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method retrieves a list of changes made on an order, including returns, exchanges, etc...
     *
     * This method sends a request to the [List Changes](https://docs.medusajs.com/api/admin#orders_getordersidchanges)
     * API route.
     *
     * @param id - The order's ID.
     * @param queryParams - Configure the fields to retrieve in each order change.
     * @param headers - Headers to pass in the request
     * @returns The list of order changes.
     *
     * @example
     * sdk.admin.order.listChanges("order_123")
     * .then(({ order_changes }) => {
     *   console.log(order_changes)
     * })
     */ listChanges(id, queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/changes`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method retrieves the order's line items. It sends a request to the
     * [List Line Items](https://docs.medusajs.com/api/admin#orders_getordersidlineitems)
     * API routes.
     *
     * @param id - The order's ID.
     * @param queryParams - Configure the fields to retrieve in each line item.
     * @param headers - Headers to pass in the request
     * @returns The list of line items.
     *
     * @example
     * sdk.admin.order.listLineItems("order_123")
     * .then(({ order_items }) => {
     *   console.log(order_items)
     * })
     */ listLineItems(id, queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${id}/line-items`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method creates a credit line for an order. It sends a request to the
     * [Create Credit Line](https://docs.medusajs.com/api/admin#orders_postordersidcredit-lines) API route.
     *
     * @param orderId - The order's ID.
     * @param body - The credit line's details.
     * @param query - Configure the fields to retrieve in the order.
     * @param headers - Headers to pass in the request
     * @returns The order's details.
     *
     * @example
     * sdk.admin.order.createCreditLine(
     *   "order_123",
     *   {
     *     amount: 100,
     *     reference: "order",
     *     reference_id: "order_123",
     *   }
     * )
     * .then(({ order }) => {
     *   console.log(order)
     * })
     */ createCreditLine(orderId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/orders/${orderId}/credit-lines`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=order.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/order-edit.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OrderEdit",
    ()=>OrderEdit
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class OrderEdit {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates an order edit request. It sends a HTTP request to the
     * [Create Order Edit](https://docs.medusajs.com/api/admin#order-edits_postorderedits)
     * API route.
     *
     * @param body - The order edit's details.
     * @param query - Configure the fields to retrieve in the order edit.
     * @param headers - Headers to pass in the request.
     * @returns The order edit's details.
     *
     * @example
     * sdk.admin.orderEdit.initiateRequest({
     *   order_id: "order_123"
     * })
     * .then(({ order_change }) => {
     *   console.log(order_change)
     * })
     */ initiateRequest(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method changes an order edit to requested. It sends a request to the
     * [Request Order Edit](https://docs.medusajs.com/api/admin#order-edits_postordereditsidrequest)
     * API route.
     *
     * @param id - The order edit's ID.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.request("ordch_123")
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ request(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/request`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method confirms an order edit and applies it on the order. It sends a request
     * to the [Confirm Order Edit](https://docs.medusajs.com/api/admin#order-edits_postordereditsidconfirm)
     * API route.
     *
     * @param id - The order edit's ID.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.confirm("ordch_123")
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ confirm(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/confirm`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method cancels a requested order edit. It sends a request to the
     * [Cancel Order Edit](https://docs.medusajs.com/api/admin#order-edits_deleteordereditsid)
     * API route.
     *
     * @param id - The order edit's ID.
     * @param query - Query parameters
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.orderEdit.cancelRequest("ordch_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ cancelRequest(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds items to an order edit. These items will have the action `ITEM_ADD`.
     *
     * The method sends a request to the [Add Items](https://docs.medusajs.com/api/admin#order-edits_postordereditsiditems)
     * API route.
     *
     * @param id - The order edit's ID.
     * @param body - The items to add.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.addItems("ordch_123", {
     *   items: [
     *     {
     *       variant_id: "variant_123",
     *       quantity: 1
     *     }
     *   ]
     * })
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ addItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates the quantity and other details of an item in an order. It sends a request to the
     * [Update Item Quantity](https://docs.medusajs.com/api/admin#order-edits_postordereditsiditemsitemitem_id)
     * API route.
     *
     * You can also use this method to remove an item from an order by setting the `quantity` to `0`.
     *
     * @param id - The order edit's ID.
     * @param itemId - The item's ID in the order.
     * @param body - The data to edit in the item.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.updateOriginalItem(
     *   "ordch_123",
     *   "orli_123",
     *   {
     *     quantity: 1
     *   }
     * )
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ updateOriginalItem(id, itemId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/items/item/${itemId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an added item in the order edit by the ID of the item's `ITEM_ADD` action.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * It sends a request
     * to the [Update Item](https://docs.medusajs.com/api/admin#order-edits_postordereditsiditemsaction_id)
     * API route.
     *
     * @param id - The order edit's ID.
     * @param actionId - The id of the new item's `ITEM_ADD` action.
     * @param body - The data to update.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.updateAddedItem(
     *   "ordch_123",
     *   "orli_123",
     *   {
     *     quantity: 1
     *   }
     * )
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ updateAddedItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an added item in the order edit by the ID of the item's `ITEM_ADD` action.
     *
     * Every item has an `actions` property, whose value is an array of actions.
     * You can check the action's name using its `action` property, and use the value of the `id` property.
     *
     * @param id - The order edit's ID.
     * @param actionId - The id of the new item's `ITEM_ADD` action.
     * @param query - Configure the fields to retrieve in the order preview.
     * @param headers - Headers to pass in the request.
     * @returns The order preview's details.
     *
     * @example
     * sdk.admin.orderEdit.removeAddedItem(
     *   "ordch_123",
     *   "orli_123",
     * )
     * .then(({ order_preview }) => {
     *   console.log(order_preview)
     * })
     */ removeAddedItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/order-edits/${id}/items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=order-edit.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/payment.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Payment",
    ()=>Payment
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Payment {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of payments. It sends a request to the
     * [List Payments](https://docs.medusajs.com/api/admin#payments_getpayments) API route.
     *
     * @param query  - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of payments.
     *
     * @example
     * To retrieve the list of payments:
     *
     * ```ts
     * sdk.admin.payment.list()
     * .then(({ payments, count, limit, offset }) => {
     *   console.log(payments)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.payment.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ payments, count, limit, offset }) => {
     *   console.log(payments)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each payment:
     *
     * ```ts
     * sdk.admin.payment.list({
     *   fields: "id,*payment_collection"
     * })
     * .then(({ payments, count, limit, offset }) => {
     *   console.log(payments)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payments`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a paginated list of payment providers. It sends a request to the
     * [List Payment Providers](https://docs.medusajs.com/api/admin#payments_getpaymentspaymentproviders) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of payment providers.
     *
     * @example
     * To retrieve the list of payment providers:
     *
     * ```ts
     * sdk.admin.payment.listPaymentProviders()
     * .then(({ payment_providers, count, limit, offset }) => {
     *   console.log(payment_providers)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.payment.listPaymentProviders({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ payment_providers, count, limit, offset }) => {
     *   console.log(payment_providers)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each payment provider:
     *
     * ```ts
     * sdk.admin.payment.listPaymentProviders({
     *   fields: "id,is_enabled"
     * })
     * .then(({ payment_providers, count, limit, offset }) => {
     *   console.log(payment_providers)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ listPaymentProviders(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payments/payment-providers`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a payment's details. It sends a request to the
     * [Get Payment](https://docs.medusajs.com/api/admin#payments_getpaymentsid)
     * API route.
     *
     * @param id - The payment's ID.
     * @param query - Configure the fields to retrieve in the payment.
     * @param headers - Headers to pass in the request
     * @returns The payment's details.
     *
     * @example
     * To retrieve a payment by its ID:
     *
     * ```ts
     * sdk.admin.payment.retrieve("pay_123")
     * .then(({ payment }) => {
     *   console.log(payment)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.payment.retrieve("pay_123", {
     *   fields: "id,*payment_collection"
     * })
     * .then(({ payment }) => {
     *   console.log(payment)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payments/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method captures a payment. It sends a request to the
     * [Capture Payment](https://docs.medusajs.com/api/admin#payments_postpaymentsidcapture) API route.
     *
     * The API route uses the `capturePayment` method of the payment provider associated with the payment's collection.
     *
     * @param id - The payment's ID.
     * @param body - The capture's details.
     * @param query - Configure the fields to retrieve in the payment.
     * @param headers - Headers to pass in the request
     * @returns The payment's details.
     *
     * @example
     * sdk.admin.payment.capture("paycol_123", {})
     * .then(({ payment }) => {
     *   console.log(payment)
     * })
     */ capture(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payments/${id}/capture`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method refunds a payment. It sends a request to the
     * [Refund Payment](https://docs.medusajs.com/api/admin#payments_postpaymentsidrefund) API route.
     *
     * The API route uses the `refundPayment` method of the payment provider associated with the payment's collection.
     *
     * @param id - The payment's ID.
     * @param body - The refund's details.
     * @param query - Configure the fields to retrieve in the payment.
     * @param headers - Headers to pass in the request
     * @returns The payment's details.
     *
     * @example
     * sdk.admin.payment.refund("paycol_123", {})
     * .then(({ payment }) => {
     *   console.log(payment)
     * })
     */ refund(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payments/${id}/refund`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=payment.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/payment-collection.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PaymentCollection",
    ()=>PaymentCollection
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PaymentCollection {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a payment collection. It sends a request to the
     * [Create Payment Collection](https://docs.medusajs.com/api/admin#payment-collections_postpaymentcollections)
     * API route.
     *
     * @param body - The details of the payment collection to create.
     * @param query - Configure the fields to retrieve in the payment collection.
     * @param headers - Headers to pass in the request
     * @returns The payment collection's details.
     *
     * @example
     * sdk.admin.paymentCollection.create({
     *   order_id: "order_123"
     * })
     * .then(({ payment_collection }) => {
     *   console.log(payment_collection)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payment-collections`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a payment collection. It sends a request to the
     * [Delete Payment Collection](https://docs.medusajs.com/api/admin#payment-collections_deletepaymentcollectionsid)
     * API route.
     *
     * @param id - The payment collection's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.paymentCollection.delete("paycol_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payment-collections/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method marks a payment collection as paid. It sends a request to the
     * [Mark as Paid](https://docs.medusajs.com/api/admin#payment-collections_postpaymentcollectionsidmarkaspaid)
     * API route.
     *
     * The API route creates and authorizes a payment session, then capture its payment,
     * using the manual payment provider.
     *
     * @param id - The payment collection to mark as paid.
     * @param body - The details to mark the payment collection as paid.
     * @param query - Configure the fields to retrieve in the payment collection.
     * @param headers - Headers to pass in the request.
     * @returns The payment collection's details.
     *
     * @example
     * sdk.admin.paymentCollection.markAsPaid("paycol_123", {
     *   order_id: "order_123"
     * })
     * .then(({ payment_collection }) => {
     *   console.log(payment_collection)
     * })
     */ markAsPaid(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/payment-collections/${id}/mark-as-paid`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=payment-collection.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/plugin.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Plugin",
    ()=>Plugin
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Plugin {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves the list of plugins installed in a Medusa application.
     *
     * @param headers - Headers to pass in the request.
     * @returns The list of plugins.
     *
     * @example
     * sdk.admin.plugin.list()
     * .then(({ plugins }) => {
     *   console.log(plugins)
     * })
     */ list(headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/plugins`, {
                headers,
                query: {}
            });
        });
    }
} //# sourceMappingURL=plugin.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/price-list.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PriceList",
    ()=>PriceList
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PriceList {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a price list. It sends a request to the
     * [Get Price List](https://docs.medusajs.com/v2/api/admin#price-lists_getpricelistsid)
     * API route.
     *
     * @param id - The price list's ID.
     * @param query - Configure the fields to retrieve in the price list.
     * @param headers - Headers to pass in the request
     * @returns The price list's details.
     *
     * @example
     * To retrieve a price list by its ID:
     *
     * ```ts
     * sdk.admin.priceList.retrieve("plist_123")
     * .then(({ price_list }) => {
     *   console.log(price_list)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.priceList.retrieve("plist_123", {
     *   fields: "id,*prices"
     * })
     * .then(({ price_list }) => {
     *   console.log(price_list)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/v2/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of price lists. It sends a request to the
     * [List Price Lists](https://docs.medusajs.com/v2/api/admin#price-lists_getpricelists) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of price lists.
     *
     * @example
     * To retrieve the list of price lists:
     *
     * ```ts
     * sdk.admin.priceList.list()
     * .then(({ price_lists, count, limit, offset }) => {
     *   console.log(price_lists)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.priceList.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ price_lists, count, limit, offset }) => {
     *   console.log(price_lists)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each price list:
     *
     * ```ts
     * sdk.admin.priceList.list({
     *   fields: "id,*prices"
     * })
     * .then(({ price_lists, count, limit, offset }) => {
     *   console.log(price_lists)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/v2/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method creates a price list. It sends a request to the
     * [Create Price List](https://docs.medusajs.com/v2/api/admin#price-lists_postpricelists)
     * API route.
     *
     * @param body - The details of the price list to create.
     * @param query - Configure the fields to retrieve in the price list.
     * @param headers - Headers to pass in the request
     * @returns The price list's details.
     *
     * @example
     * sdk.admin.priceList.create({
     *   title: "My Price List",
     *   status: "active",
     *   type: "sale",
     *   prices: [
     *     {
     *       variant_id: "variant_123",
     *       amount: 10,
     *       currency_code: "usd",
     *       rules: {
     *         region_id: "reg_123"
     *       }
     *     }
     *   ]
     * })
     * .then(({ price_list }) => {
     *   console.log(price_list)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a price list. It sends a request to the
     * [Update Price List](https://docs.medusajs.com/v2/api/admin#price-lists_postpricelistsid)
     * API route.
     *
     * @param id - The price list's ID.
     * @param body - The data to update in the price list.
     * @param query - Configure the fields to retrieve in the price list.
     * @param headers - Headers to pass in the request
     * @returns The price list's details.
     *
     * @example
     * sdk.admin.priceList.update("plist_123", {
     *   title: "My Price List",
     * })
     * .then(({ price_list }) => {
     *   console.log(price_list)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a price list. It sends a request to the
     * [Delete Price List](https://docs.medusajs.com/v2/api/admin#price-lists_deletepricelistsid)
     * API route.
     *
     * @param id - The price list's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.priceList.delete("plist_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the prices of a price list to create, update, or delete them.
     * It sends a request to the [Manage Prices](https://docs.medusajs.com/v2/api/admin#price-lists_postpricelistsidpricesbatch)
     * API route.
     *
     * @param id - The price list's ID.
     * @param body - The prices to create, update, or delete.
     * @param query - Configure the fields to retrieve in the price list.
     * @param headers - Headers to pass in the request
     * @returns The price list's details.
     *
     * @example
     * sdk.admin.priceList.batchPrices("plist_123", {
     *   create: [{
     *     variant_id: "variant_123",
     *     currency_code: "usd",
     *     amount: 10,
     *     rules: {
     *       region_id: "reg_123"
     *     }
     *   }],
     *   update: [{
     *     id: "price_123",
     *     variant_id: "variant_123",
     *     amount: 20,
     *   }],
     *   delete: ["price_123"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchPrices(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists/${id}/prices/batch`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes products from a price list. It sends a request to the
     * [Remove Product](https://docs.medusajs.com/v2/api/admin#price-lists_postpricelistsidproducts)
     * API route.
     *
     * @param id - The price list's ID.
     * @param body - The details of the products to remove.
     * @param query - Configure the fields to retrieve in the price list.
     * @param headers - Headers to pass in the request
     * @returns The price list's details.
     *
     * @example
     * sdk.admin.priceList.linkProducts("plist_123", {
     *   remove: ["prod_123"]
     * })
     * .then(({ price_list }) => {
     *   console.log(price_list)
     * })
     */ linkProducts(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-lists/${id}/products`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=price-list.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/price-preference.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PricePreference",
    ()=>PricePreference
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PricePreference {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a price preference. It sends a request to the
     * [Get Price Preference](https://docs.medusajs.com/api/admin#price-preferences_getpricepreferencesid)
     * API route.
     *
     * @param id - The price preference's ID.
     * @param query - Configure the fields to retrieve in the price preference.
     * @param headers - Headers to pass in the request
     * @returns The price preference's details.
     *
     * @example
     * To retrieve a price preference by its ID:
     *
     * ```ts
     * sdk.admin.pricePreference.retrieve("prpref_123")
     * .then(({ price_preference }) => {
     *   console.log(price_preference)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.pricePreference.retrieve("prpref_123", {
     *   fields: "id,is_tax_inclusive"
     * })
     * .then(({ price_preference }) => {
     *   console.log(price_preference)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-preferences/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of price preferences. It sends a request to the
     * [List Price Preferences](https://docs.medusajs.com/api/admin#price-preferences_getpricepreferences) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of price preferences.
     *
     * @example
     * To retrieve the list of price preferences:
     *
     * ```ts
     * sdk.admin.pricePreference.list()
     * .then(({ price_preferences, count, limit, offset }) => {
     *   console.log(price_preferences)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.pricePreference.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ price_preferences, count, limit, offset }) => {
     *   console.log(price_preferences)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each price preference:
     *
     * ```ts
     * sdk.admin.pricePreference.list({
     *   fields: "id,is_tax_inclusive"
     * })
     * .then(({ price_preferences, count, limit, offset }) => {
     *   console.log(price_preferences)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-preferences`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method creates a price preference. It sends a request to the
     * [Create Price Preference](https://docs.medusajs.com/api/admin#price-preferences_postpricepreferences)
     * API route.
     *
     * @param body - The details of the price preference to create.
     * @param query - Configure the fields to retrieve in the price preference.
     * @param headers - Headers to pass in the request
     * @returns The price preference's details.
     *
     * @example
     * sdk.admin.pricePreference.create({
     *   attribute: "region_id",
     *   value: "region_123",
     *   is_tax_inclusive: true
     * })
     * .then(({ price_preference }) => {
     *   console.log(price_preference)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-preferences`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a price preference. It sends a request to the
     * [Update Price Preference](https://docs.medusajs.com/api/admin#price-preferences_postpricepreferencesid)
     * API route.
     *
     * @param id - The price preference's ID.
     * @param body - The data to update in the price preference.
     * @param query - Configure the fields to retrieve in the price preference.
     * @param headers - Headers to pass in the request
     * @returns The price preference's details.
     *
     * @example
     * sdk.admin.pricePreference.update("prpref_123", {
     *   is_tax_inclusive: true
     * })
     * .then(({ price_preference }) => {
     *   console.log(price_preference)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-preferences/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a price preference. It sends a request to the
     * [Delete Price Preference](https://docs.medusajs.com/api/admin#price-preferences_deletepricepreferencesid)
     * API route.
     *
     * @param id - The price preference's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.pricePreference.delete("prpref_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/price-preferences/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=price-preference.js.map
}),
"[project]/node_modules/fetch-event-stream/esm/deps/jsr.io/@std/streams/0.221.0/text_line_stream.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Transform a stream into a stream where each chunk is divided by a newline,
 * be it `\n` or `\r\n`. `\r` can be enabled via the `allowCR` option.
 *
 * @example
 * ```ts
 * import { TextLineStream } from "@std/streams/text-line-stream";
 *
 * const res = await fetch("https://example.com");
 * const lines = res.body!
 *   .pipeThrough(new TextDecoderStream())
 *   .pipeThrough(new TextLineStream());
 * ```
 */ __turbopack_context__.s([
    "TextLineStream",
    ()=>TextLineStream
]);
class TextLineStream extends TransformStream {
    #currentLine = "";
    /** Constructs a new instance. */ constructor(options = {
        allowCR: false
    }){
        super({
            transform: (chars, controller)=>{
                chars = this.#currentLine + chars;
                while(true){
                    const lfIndex = chars.indexOf("\n");
                    const crIndex = options.allowCR ? chars.indexOf("\r") : -1;
                    if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
                        controller.enqueue(chars.slice(0, crIndex));
                        chars = chars.slice(crIndex + 1);
                        continue;
                    }
                    if (lfIndex === -1) break;
                    const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
                    controller.enqueue(chars.slice(0, endIndex));
                    chars = chars.slice(lfIndex + 1);
                }
                this.#currentLine = chars;
            },
            flush: (controller)=>{
                if (this.#currentLine === "") return;
                const currentLine = options.allowCR && this.#currentLine.endsWith("\r") ? this.#currentLine.slice(0, -1) : this.#currentLine;
                controller.enqueue(currentLine);
            }
        });
    }
}
}),
"[project]/node_modules/fetch-event-stream/esm/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fallback",
    ()=>fallback,
    "split",
    ()=>split,
    "stream",
    ()=>stream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$deps$2f$jsr$2e$io$2f40$std$2f$streams$2f$0$2e$221$2e$0$2f$text_line_stream$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-event-stream/esm/deps/jsr.io/@std/streams/0.221.0/text_line_stream.js [app-rsc] (ecmascript)");
;
function stream(input) {
    let decoder = new TextDecoderStream();
    let split = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$deps$2f$jsr$2e$io$2f40$std$2f$streams$2f$0$2e$221$2e$0$2f$text_line_stream$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TextLineStream"]({
        allowCR: true
    });
    return input.pipeThrough(decoder).pipeThrough(split);
}
function split(input) {
    let rgx = /[:]\s*/;
    let match = rgx.exec(input);
    // ": comment" -> index=0 -> ignore
    let idx = match && match.index;
    if (idx) {
        return [
            input.substring(0, idx),
            input.substring(idx + match[0].length)
        ];
    }
}
function fallback(headers, key, value) {
    let tmp = headers.get(key);
    if (!tmp) headers.set(key, value);
}
}),
"[project]/node_modules/fetch-event-stream/esm/mod.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "events",
    ()=>events,
    "stream",
    ()=>stream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-event-stream/esm/utils.js [app-rsc] (ecmascript)");
;
async function* events(res, signal) {
    // TODO: throw error?
    if (!res.body) return;
    let iter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stream"](res.body);
    let line, reader = iter.getReader();
    let event;
    for(;;){
        if (signal && signal.aborted) {
            return reader.cancel();
        }
        line = await reader.read();
        if (line.done) return;
        if (!line.value) {
            if (event) yield event;
            event = undefined;
            continue;
        }
        let [field, value] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["split"](line.value) || [];
        if (!field) continue; // comment or invalid
        if (field === 'data') {
            event ||= {};
            event[field] = event[field] ? event[field] + '\n' + value : value;
        } else if (field === 'event') {
            event ||= {};
            event[field] = value;
        } else if (field === 'id') {
            event ||= {};
            event[field] = +value || value;
        } else if (field === 'retry') {
            event ||= {};
            event[field] = +value || undefined;
        }
    }
}
async function stream(input, init) {
    let req = new Request(input, init);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fallback"](req.headers, 'Accept', 'text/event-stream');
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fallback"](req.headers, 'Content-Type', 'application/json');
    let r = await fetch(req);
    if (!r.ok) throw r;
    return events(r, req.signal);
}
}),
"[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/object-inspect/util.inspect.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").inspect;
}),
"[project]/node_modules/object-inspect/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
 ? function(O) {
    return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}
var utilInspect = __turbopack_context__.r("[project]/node_modules/object-inspect/util.inspect.js [app-rsc] (ecmascript)");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};
module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }
    if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }
    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') {
        depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === 'function' && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for(var i = 0; i < attrs.length; i++){
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) {
            s += '...';
        }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) {
            return '[]';
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) {
            return '[' + String(obj) + ']';
        }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, {
                depth: maxDepth - depth
            });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function(value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function(value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if (typeof globalThis !== 'undefined' && obj === globalThis || ("TURBOPACK compile-time value", "object") !== 'undefined' && obj === /*TURBOPACK member replacement*/ __turbopack_context__.g) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) {
            return tag + '{}';
        }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}
function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}
function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) {
    return toStr(obj) === '[object Array]' && canTrustToString(obj);
}
function isDate(obj) {
    return toStr(obj) === '[object Date]' && canTrustToString(obj);
}
function isRegExp(obj) {
    return toStr(obj) === '[object RegExp]' && canTrustToString(obj);
}
function isError(obj) {
    return toStr(obj) === '[object Error]' && canTrustToString(obj);
}
function isString(obj) {
    return toStr(obj) === '[object String]' && canTrustToString(obj);
}
function isNumber(obj) {
    return toStr(obj) === '[object Number]' && canTrustToString(obj);
}
function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]' && canTrustToString(obj);
}
// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}
function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
};
function has(obj, key) {
    return hasOwn.call(obj, key);
}
function toStr(obj) {
    return objectToString.call(obj);
}
function nameOf(f) {
    if (f.name) {
        return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
        return m[1];
    }
    return null;
}
function indexOf(xs, x) {
    if (xs.indexOf) {
        return xs.indexOf(x);
    }
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) {
            return i;
        }
    }
    return -1;
}
function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}
function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isElement(x) {
    if (!x || typeof x !== 'object') {
        return false;
    }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}
function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}
function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) {
        return '\\' + x;
    }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
    return 'Object(' + str + ')';
}
function weakCollectionOf(type) {
    return type + ' { ? }';
}
function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}
function singleLineValues(xs) {
    for(var i = 0; i < xs.length; i++){
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}
function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}
function indentedJoin(xs, indent) {
    if (xs.length === 0) {
        return '';
    }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}
function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for(var i = 0; i < obj.length; i++){
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for(var k = 0; k < syms.length; k++){
            symMap['$' + syms[k]] = syms[k];
        }
    }
    for(var key in obj){
        if (!has(obj, key)) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for(var j = 0; j < syms.length; j++){
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}
}),
"[project]/node_modules/side-channel-list/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-rsc] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/ /** @type {import('./list.d.ts').listGetNode} */ // eslint-disable-next-line consistent-return
var listGetNode = function(list, key, isDelete) {
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */ var prev = list;
    /** @type {(typeof list)['next']} */ var curr;
    // eslint-disable-next-line eqeqeq
    for(; (curr = prev.next) != null; prev = curr){
        if (curr.key === key) {
            prev.next = curr.next;
            if (!isDelete) {
                // eslint-disable-next-line no-extra-parens
                curr.next = list.next;
                list.next = curr; // eslint-disable-line no-param-reassign
            }
            return curr;
        }
    }
};
/** @type {import('./list.d.ts').listGet} */ var listGet = function(objects, key) {
    if (!objects) {
        return void undefined;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */ var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
        node.value = value;
    } else {
        // Prepend the new node to the beginning of the list
        objects.next = {
            key: key,
            next: objects.next,
            value: value
        };
    }
};
/** @type {import('./list.d.ts').listHas} */ var listHas = function(objects, key) {
    if (!objects) {
        return false;
    }
    return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */ // eslint-disable-next-line consistent-return
var listDelete = function(objects, key) {
    if (objects) {
        return listGetNode(objects, key, true);
    }
};
/** @type {import('.')} */ module.exports = function getSideChannelList() {
    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            var root = $o && $o.next;
            var deletedNode = listDelete($o, key);
            if (deletedNode && root && root === deletedNode) {
                $o = void undefined;
            }
            return !!deletedNode;
        },
        get: function(key) {
            return listGet($o, key);
        },
        has: function(key) {
            return listHas($o, key);
        },
        set: function(key, value) {
            if (!$o) {
                // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                $o = {
                    next: void undefined
                };
            }
            // eslint-disable-next-line no-extra-parens
            listSet($o, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}),
"[project]/node_modules/es-object-atoms/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/es-errors/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/uri.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-rsc] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-rsc] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/has-symbols/shams.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-rsc] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-rsc] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/function-bind/implementation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-rsc] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-rsc] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-rsc] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-rsc] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-rsc] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-rsc] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-rsc] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-rsc] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-rsc] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-rsc] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/get-proto/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-rsc] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-rsc] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-rsc] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/hasown/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-rsc] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-rsc] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-rsc] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-rsc] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-rsc] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-rsc] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-rsc] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-rsc] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-rsc] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-rsc] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-rsc] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-rsc] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-rsc] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-rsc] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-rsc] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-rsc] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-rsc] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-rsc] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-rsc] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-rsc] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-rsc] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-rsc] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-rsc] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-rsc] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-rsc] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/call-bound/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-rsc] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-rsc] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}),
"[project]/node_modules/side-channel-map/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-rsc] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-rsc] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-rsc] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
var $Map = GetIntrinsic('%Map%', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */ var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */ var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */ var $mapSize = callBound('Map.prototype.size', true);
/** @type {import('.')} */ module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
    /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {Map<K, V> | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($m) {
                var result = $mapDelete($m, key);
                if ($mapSize($m) === 0) {
                    $m = void undefined;
                }
                return result;
            }
            return false;
        },
        get: function(key) {
            if ($m) {
                return $mapGet($m, key);
            }
        },
        has: function(key) {
            if ($m) {
                return $mapHas($m, key);
            }
            return false;
        },
        set: function(key, value) {
            if (!$m) {
                // @ts-expect-error TS can't handle narrowing a variable inside a closure
                $m = new $Map();
            }
            $mapSet($m, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why TS is erroring here
    return channel;
};
}),
"[project]/node_modules/side-channel-weakmap/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-rsc] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-rsc] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-rsc] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/side-channel-map/index.js [app-rsc] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */ var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */ var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
/** @type {import('.')} */ module.exports = $WeakMap ? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
    /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {WeakMap<K & object, V> | undefined} */ var $wm;
    /** @type {Channel | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapDelete($wm, key);
                }
            } else if (getSideChannelMap) {
                if ($m) {
                    return $m['delete'](key);
                }
            }
            return false;
        },
        get: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapGet($wm, key);
                }
            }
            return $m && $m.get(key);
        },
        has: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapHas($wm, key);
                }
            }
            return !!$m && $m.has(key);
        },
        set: function(key, value) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if (!$wm) {
                    $wm = new $WeakMap();
                }
                $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
                if (!$m) {
                    $m = getSideChannelMap();
                }
                // eslint-disable-next-line no-extra-parens
                /** @type {NonNullable<typeof $m>} */ $m.set(key, value);
            }
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
} : getSideChannelMap;
}),
"[project]/node_modules/side-channel/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-rsc] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-rsc] (ecmascript)");
var getSideChannelList = __turbopack_context__.r("[project]/node_modules/side-channel-list/index.js [app-rsc] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/side-channel-map/index.js [app-rsc] (ecmascript)");
var getSideChannelWeakMap = __turbopack_context__.r("[project]/node_modules/side-channel-weakmap/index.js [app-rsc] (ecmascript)");
var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
/** @type {import('.')} */ module.exports = function getSideChannel() {
    /** @typedef {ReturnType<typeof getSideChannel>} Channel */ /** @type {Channel | undefined} */ var $channelData;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            return !!$channelData && $channelData['delete'](key);
        },
        get: function(key) {
            return $channelData && $channelData.get(key);
        },
        has: function(key) {
            return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
            if (!$channelData) {
                $channelData = makeChannel();
            }
            $channelData.set(key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}),
"[project]/node_modules/qs/lib/formats.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};
module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function(value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function(value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};
}),
"[project]/node_modules/qs/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-rsc] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var hexTable = function() {
    var array = [];
    for(var i = 0; i < 256; ++i){
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
}();
var compactQueue = function compactQueue(queue) {
    while(queue.length > 1){
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
            var compacted = [];
            for(var j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }
            item.obj[item.prop] = compacted;
        }
    }
};
var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? {
        __proto__: null
    } : {};
    for(var i = 0; i < source.length; ++i){
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }
    return obj;
};
var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */ if (!source) {
        return target;
    }
    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== 'object') {
        return [
            target
        ].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
var decode = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
var limit = 1024;
/* eslint operator-linebreak: [2, "before"] */ var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }
    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }
    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }
    var out = '';
    for(var j = 0; j < string.length; j += limit){
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for(var i = 0; i < segment.length; ++i){
            var c = segment.charCodeAt(i);
            if (c === 0x2D // -
             || c === 0x2E // .
             || c === 0x5F // _
             || c === 0x7E // ~
             || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }
            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }
            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
            arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        }
        out += arr.join('');
    }
    return out;
};
var compact = function compact(value) {
    var queue = [
        {
            obj: {
                o: value
            },
            prop: 'o'
        }
    ];
    var refs = [];
    for(var i = 0; i < queue.length; ++i){
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; ++j){
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value;
};
var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};
var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine(a, b) {
    return [].concat(a, b);
};
var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for(var i = 0; i < val.length; i += 1){
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};
module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};
}),
"[project]/node_modules/qs/lib/stringify.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getSideChannel = __turbopack_context__.r("[project]/node_modules/side-channel/index.js [app-rsc] (ecmascript)");
var utils = __turbopack_context__.r("[project]/node_modules/qs/lib/utils.js [app-rsc] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-rsc] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
        valueOrArray
    ]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
};
var sentinel = {};
var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag){
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }
    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }
        obj = '';
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [
                formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
            ];
        }
        return [
            formatter(prefix) + '=' + formatter(String(obj))
        ];
    }
    var values = [];
    if (typeof obj === 'undefined') {
        return values;
    }
    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [
            {
                value: obj.length > 0 ? obj.join(',') || null : void undefined
            }
        ];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }
    for(var j = 0; j < objKeys.length; ++j){
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined' ? key.value : obj[key];
        if (skipNulls && value === null) {
            continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!objKeys) {
        objKeys = Object.keys(obj);
    }
    if (options.sort) {
        objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for(var i = 0; i < objKeys.length; ++i){
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }
    return joined.length > 0 ? prefix + joined : '';
};
}),
"[project]/node_modules/qs/lib/parse.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/qs/lib/utils.js [app-rsc] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};
var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }
    return val;
};
// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')
var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
        __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
        for(i = 0; i < parts.length; ++i){
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }
    for(i = 0; i < parts.length; ++i){
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
            });
        }
        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }
        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [
                val
            ] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }
    return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for(var i = chain.length - 1; i >= 0; --i){
        var obj;
        var root = chain[i];
        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? {
                __proto__: null
            } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = {
                    0: leaf
                };
            } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }
        leaf = obj;
    }
    return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }
    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
    // The regex chunks
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    // Get the parent
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    // Stash the parent if it exists
    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(parent);
    }
    // Loop through children appending to the array until we hit depth
    var i = 0;
    while(options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth){
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }
    // If there's a remainder, check strictDepth option for throw, else just add whatever is left
    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};
module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? {
            __proto__: null
        } : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? {
        __proto__: null
    } : {};
    // Iterate over the keys and setup the new object
    var keys = Object.keys(tempObj);
    for(var i = 0; i < keys.length; ++i){
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
        return obj;
    }
    return utils.compact(obj);
};
}),
"[project]/node_modules/qs/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var stringify = __turbopack_context__.r("[project]/node_modules/qs/lib/stringify.js [app-rsc] (ecmascript)");
var parse = __turbopack_context__.r("[project]/node_modules/qs/lib/parse.js [app-rsc] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-rsc] (ecmascript)");
module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/client.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Client",
    ()=>Client,
    "FetchError",
    ()=>FetchError,
    "PUBLISHABLE_KEY_HEADER",
    ()=>PUBLISHABLE_KEY_HEADER
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$mod$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-event-stream/esm/mod.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$qs$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/qs/lib/index.js [app-rsc] (ecmascript)");
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
const PUBLISHABLE_KEY_HEADER = "x-publishable-api-key";
// We want to explicitly retrieve the base URL instead of relying on relative paths that differ in behavior between browsers.
const getBaseUrl = (passedBaseUrl)=>{
    if ("TURBOPACK compile-time truthy", 1) {
        return passedBaseUrl;
    }
    //TURBOPACK unreachable
    ;
};
const hasStorage = (storage)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return false;
};
const toBase64 = (str)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return Buffer.from(str).toString("base64");
};
const sanitizeHeaders = (headers)=>{
    return Object.assign(Object.assign({}, Object.fromEntries(headers.entries())), {
        authorization: "<REDACTED>"
    });
};
const normalizeRequest = (init, headers, config)=>{
    var _a, _b, _c;
    let body = init === null || init === void 0 ? void 0 : init.body;
    if (body && ((_a = headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json"))) {
        body = JSON.stringify(body);
    }
    // "credentials" is not supported in some environments (eg. on the backend), and it might throw an exception if the field is set.
    const isFetchCredentialsSupported = "credentials" in Request.prototype;
    // Oftentimes the server will be on a different origin, so we want to default to include
    // Note that the cookie's SameSite attribute takes precedence over this setting.
    const credentials = ((_b = config.auth) === null || _b === void 0 ? void 0 : _b.type) === "session" ? ((_c = config.auth) === null || _c === void 0 ? void 0 : _c.fetchCredentials) || "include" : "omit";
    return Object.assign(Object.assign(Object.assign({}, init), {
        headers,
        credentials: isFetchCredentialsSupported ? credentials : undefined
    }), body ? {
        body: body
    } : {});
};
const normalizeResponse = (resp, reqHeaders)=>__awaiter(void 0, void 0, void 0, function*() {
        var _a, _b;
        if (resp.status >= 300) {
            const jsonError = yield resp.json().catch(()=>({}));
            throw new FetchError((_a = jsonError.message) !== null && _a !== void 0 ? _a : resp.statusText, resp.statusText, resp.status);
        }
        // If we requested JSON, we try to parse the response. Otherwise, we return the raw response.
        const isJsonRequest = (_b = reqHeaders.get("accept")) === null || _b === void 0 ? void 0 : _b.includes("application/json");
        return isJsonRequest ? yield resp.json() : resp;
    });
class FetchError extends Error {
    constructor(message, statusText, status){
        super(message);
        this.statusText = statusText;
        this.status = status;
    }
}
class Client {
    constructor(config){
        this.DEFAULT_JWT_STORAGE_KEY = "medusa_auth_token";
        this.token = "";
        this.getApiKeyHeader_ = ()=>{
            return this.config.apiKey ? {
                Authorization: "Basic " + toBase64(this.config.apiKey + ":")
            } : {};
        };
        this.getPublishableKeyHeader_ = ()=>{
            return this.config.publishableKey ? {
                [PUBLISHABLE_KEY_HEADER]: this.config.publishableKey
            } : {};
        };
        this.getTokenStorageInfo_ = ()=>{
            var _a, _b, _c;
            const hasLocal = hasStorage("localStorage");
            const hasSession = hasStorage("sessionStorage");
            const hasCustom = Boolean((_a = this.config.auth) === null || _a === void 0 ? void 0 : _a.storage);
            const storageMethod = ((_b = this.config.auth) === null || _b === void 0 ? void 0 : _b.jwtTokenStorageMethod) || (hasLocal ? "local" : "nostore");
            const storageKey = ((_c = this.config.auth) === null || _c === void 0 ? void 0 : _c.jwtTokenStorageKey) || this.DEFAULT_JWT_STORAGE_KEY;
            if (!hasLocal && storageMethod === "local") {
                this.throwError_("Local JWT storage is only available in the browser");
            }
            if (!hasSession && storageMethod === "session") {
                this.throwError_("Session JWT storage is only available in the browser");
            }
            if (!hasCustom && storageMethod === "custom") {
                this.throwError_("Custom storage was not provided in the config");
            }
            return {
                storageMethod,
                storageKey
            };
        };
        this.config = Object.assign(Object.assign({}, config), {
            baseUrl: getBaseUrl(config.baseUrl)
        });
        const logger = config.logger || {
            error: console.error,
            warn: console.warn,
            info: console.info,
            debug: console.debug
        };
        this.logger = Object.assign(Object.assign({}, logger), {
            debug: config.debug ? logger.debug : ()=>{}
        });
        this.fetch_ = this.initClient();
    }
    /**
     * `fetch` closely follows (and uses under the hood) the native `fetch` API. There are, however, few key differences:
     * - Non 2xx statuses throw a `FetchError` with the status code as the `status` property, rather than resolving the promise
     * - You can pass `body` and `query` as objects, and they will be encoded and stringified.
     * - The response gets parsed as JSON if the `accept` header is set to `application/json`, otherwise the raw Response object is returned
     *
     * Since the response is dynamically determined, we cannot know if it is JSON or not. Therefore, it is important to pass `Response` as the return type
     *
     * @param input: FetchInput
     * @param init: FetchArgs
     * @returns Promise<T>
     */ fetch(input, init) {
        return this.fetch_(input, init);
    }
    /**
     * `fetchStream` is a helper method to deal with server-sent events. It returns an object with a stream and an abort function.
     * It follows a very similar interface to `fetch`, with the return value being an async generator.
     * The stream is an async generator that yields `ServerSentEventMessage` objects, which contains the event name, stringified data, and few other properties.
     * The caller is responsible for handling `disconnect` events and aborting the stream. The caller is also responsible for parsing the data field.
     *
     * @param input: FetchInput
     * @param init: FetchArgs
     * @returns FetchStreamResponse
     */ fetchStream(input, init) {
        return __awaiter(this, void 0, void 0, function*() {
            const abortController = new AbortController();
            const abortFunc = abortController.abort.bind(abortController);
            let res = yield this.fetch_(input, Object.assign(Object.assign({}, init), {
                signal: abortController.signal,
                headers: Object.assign(Object.assign({}, init === null || init === void 0 ? void 0 : init.headers), {
                    accept: "text/event-stream"
                })
            }));
            if (res.ok) {
                return {
                    stream: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$event$2d$stream$2f$esm$2f$mod$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["events"])(res, abortController.signal),
                    abort: abortFunc
                };
            }
            return {
                stream: null,
                abort: abortFunc
            };
        });
    }
    setToken(token) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.setToken_(token);
        });
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.getToken_();
        });
    }
    clearToken() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.clearToken_();
        });
    }
    clearToken_() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            const { storageMethod, storageKey } = this.getTokenStorageInfo_();
            switch(storageMethod){
                case "local":
                    {
                        window.localStorage.removeItem(storageKey);
                        break;
                    }
                case "session":
                    {
                        window.sessionStorage.removeItem(storageKey);
                        break;
                    }
                case "custom":
                    {
                        yield (_b = (_a = this.config.auth) === null || _a === void 0 ? void 0 : _a.storage) === null || _b === void 0 ? void 0 : _b.removeItem(storageKey);
                        break;
                    }
                case "memory":
                    {
                        this.token = "";
                        break;
                    }
            }
        });
    }
    initClient() {
        const defaultHeaders = new Headers(Object.assign(Object.assign({
            "content-type": "application/json",
            accept: "application/json"
        }, this.getApiKeyHeader_()), this.getPublishableKeyHeader_()));
        this.logger.debug("Initiating Medusa client with default headers:\n", `${JSON.stringify(sanitizeHeaders(defaultHeaders), null, 2)}\n`);
        return (input, init)=>__awaiter(this, void 0, void 0, function*() {
                // We always want to fetch the up-to-date JWT token before firing off a request.
                const headers = new Headers(defaultHeaders);
                const customHeaders = Object.assign(Object.assign(Object.assign({}, this.config.globalHeaders), (yield this.getJwtHeader_())), init === null || init === void 0 ? void 0 : init.headers);
                // We use `headers.set` in order to ensure headers are overwritten in a case-insensitive manner.
                Object.entries(customHeaders).forEach(([key, value])=>{
                    if (value === null) {
                        headers.delete(key);
                    } else {
                        headers.set(key, value);
                    }
                });
                let normalizedInput = input;
                if (input instanceof URL || typeof input === "string") {
                    const baseUrl = new URL(this.config.baseUrl);
                    const fullPath = `${baseUrl.pathname.replace(/\/$/, "")}/${input.toString().replace(/^\//, "")}`;
                    normalizedInput = new URL(fullPath, baseUrl.origin);
                    if (init === null || init === void 0 ? void 0 : init.query) {
                        const params = Object.fromEntries(normalizedInput.searchParams.entries());
                        const stringifiedQuery = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$qs$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stringify"])(Object.assign(Object.assign({}, params), init.query));
                        normalizedInput.search = stringifiedQuery;
                    }
                }
                this.logger.debug("Performing request to:\n", `URL: ${normalizedInput.toString()}\n`, `Headers: ${JSON.stringify(sanitizeHeaders(headers), null, 2)}\n`);
                // Any non-request errors (eg. invalid JSON in the response) will be thrown as-is.
                return yield fetch(normalizedInput, normalizeRequest(init, headers, this.config)).then((resp)=>{
                    this.logger.debug(`Received response with status ${resp.status}\n`);
                    return normalizeResponse(resp, headers);
                });
            });
    }
    getJwtHeader_() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            // If the user has requested for session storage, we don't want to send the JWT token in the header.
            if (((_a = this.config.auth) === null || _a === void 0 ? void 0 : _a.type) === "session") {
                return {};
            }
            const token = yield this.getToken_();
            return token ? {
                Authorization: `Bearer ${token}`
            } : {};
        });
    }
    setToken_(token) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            const { storageMethod, storageKey } = this.getTokenStorageInfo_();
            switch(storageMethod){
                case "local":
                    {
                        window.localStorage.setItem(storageKey, token);
                        break;
                    }
                case "session":
                    {
                        window.sessionStorage.setItem(storageKey, token);
                        break;
                    }
                case "custom":
                    {
                        yield (_b = (_a = this.config.auth) === null || _a === void 0 ? void 0 : _a.storage) === null || _b === void 0 ? void 0 : _b.setItem(storageKey, token);
                        break;
                    }
                case "memory":
                    {
                        this.token = token;
                        break;
                    }
            }
        });
    }
    getToken_() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            const { storageMethod, storageKey } = this.getTokenStorageInfo_();
            switch(storageMethod){
                case "local":
                    {
                        return window.localStorage.getItem(storageKey);
                    }
                case "session":
                    {
                        return window.sessionStorage.getItem(storageKey);
                    }
                case "custom":
                    {
                        return yield (_b = (_a = this.config.auth) === null || _a === void 0 ? void 0 : _a.storage) === null || _b === void 0 ? void 0 : _b.getItem(storageKey);
                    }
                case "memory":
                    {
                        return this.token;
                    }
            }
            return null;
        });
    }
    throwError_(message) {
        this.logger.error(message);
        throw new Error(message);
    }
} //# sourceMappingURL=client.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Product",
    ()=>Product
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/client.js [app-rsc] (ecmascript)");
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
class Product {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a product import. The products are only imported after
     * the import is confirmed using the {@link confirmImport} method.
     *
     * This method sends a request to the
     * [Create Product Import](https://docs.medusajs.com/api/admin#products_postproductsimport)
     * API route.
     *
     * @param body - The import's details.
     * @param query - Query parameters to pass to the request.
     * @param headers - Headers to pass in the request.
     * @returns The import's details.
     *
     * @example
     * sdk.admin.product.import({
     *   file // uploaded File instance
     * })
     * .then(({ transaction_id }) => {
     *   console.log(transaction_id)
     * })
     */ import(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            const form = new FormData();
            form.append("file", body.file);
            return yield this.client.fetch(`/admin/products/import`, {
                method: "POST",
                headers: Object.assign(Object.assign({}, headers), {
                    // Let the browser determine the content type.
                    "content-type": null
                }),
                body: form,
                query
            });
        });
    }
    /**
     * This method creates a product import. The products are only imported after
     * the import is confirmed using the {@link confirmImport} method.
     *
     * This method sends a request to the
     * [Create Product Import](https://docs.medusajs.com/api/admin#products_postproductsimports)
     * API route.
     *
     * @since 2.8.5
     *
     * @param body - The import's details.
     * @param query - Query parameters to pass to the request.
     * @param headers - Headers to pass in the request.
     * @returns The import's details.
     *
     * @example
     * sdk.admin.product.createImport({
     *   file // uploaded File instance
     * })
     * .then(({ transaction_id }) => {
     *   console.log(transaction_id)
     * })
     */ createImport(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            /**
             * Get signed URL for file uploads
             */ const response = yield this.client.fetch("admin/uploads/presigned-urls", {
                method: "POST",
                headers: headers,
                body: {
                    originalname: body.file.name,
                    mime_type: body.file.type,
                    size: body.file.size
                },
                query
            });
            /**
             * Upload file using the signed URL. We cannot send cookies or any other
             * special headers in this request, since external services like S3 will
             * give a CORS error.
             */ if (response.url.startsWith("http://") || response.url.startsWith("https://")) {
                const uploadResponse = yield fetch(response.url, {
                    method: "PUT",
                    body: body.file
                });
                if (uploadResponse.status >= 400) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FetchError"](uploadResponse.statusText, uploadResponse.statusText, uploadResponse.status);
                }
            } else {
                const form = new FormData();
                form.append("files", body.file);
                const localUploadResponse = yield this.client.fetch("admin/uploads", {
                    method: "POST",
                    headers: Object.assign(Object.assign({}, headers), {
                        // Let the browser determine the content type.
                        "content-type": null
                    }),
                    body: form,
                    query
                });
                response.filename = localUploadResponse.files[0].id;
            }
            /**
             * Perform products import using the uploaded file name
             */ return yield this.client.fetch("/admin/products/imports", {
                method: "POST",
                headers: Object.assign({}, headers),
                body: {
                    file_key: response.filename,
                    originalname: response.originalname,
                    extension: response.extension,
                    size: response.size,
                    mime_type: response.mime_type
                },
                query
            });
        });
    }
    /**
     * This method confirms a product import created using the method {@link import}.
     * It sends a request to the
     * [Confirm Product Import](https://docs.medusajs.com/api/admin#products_postproductsimporttransaction_idconfirm)
     * API route.
     *
     * @since 2.8.5
     *
     * @param transactionId - The ID of the transaction of the created product import. This is returned
     * by the API route used to create the product import.
     * @param query - Query parameters to pass in the request.
     * @param headers - Headers to pass in the request.
     *
     * @example
     * sdk.admin.product.confirmImport("transaction_123")
     * .then(() => {
     *   console.log("Import confirmed")
     * })
     */ confirmImport(transactionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/imports/${transactionId}/confirm`, {
                method: "POST",
                headers,
                body: {},
                query
            });
        });
    }
    /**
     * This method starts a product export process to retrieve a CSV of exported products.
     *
     * You'll receive in the response the transaction ID of the workflow generating the CSV file.
     * To check the status of the execution, send a `GET` request to
     * `/admin/workflows-executions/export-products/:transaction-id`.
     *
     * Once the execution finishes successfully, a notification is created for the export.
     * You can retrieve the notifications using the `/admin/notification` API route to
     * retrieve the file's download URL.
     *
     * This method sends a request to the [Export Product](https://docs.medusajs.com/api/admin#products_postproductsexport)
     * API route.
     *
     * @param body - The export's details.
     * @param query - Filters to specify which products to export.
     * @param headers - Headers to pass in the request.
     * @returns The export's details.
     *
     * @example
     * sdk.admin.product.export({})
     * .then(({ transaction_id }) => {
     *   console.log(transaction_id)
     * })
     */ export(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/export`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method manages products to create, update, or delete them. It sends a request to the
     * [Manage Products](https://docs.medusajs.com/api/admin#products_postproductsbatch)
     * API route.
     *
     * @param body - The products to create, update, or delete.
     * @param query - Configure the fields to retrieve in the products.
     * @param headers - Headers to pass in the request
     * @returns The batch operations details.
     *
     * @example
     * sdk.admin.product.batch({
     *   create: [
     *     {
     *       title: "Shirt",
     *       options: [{
     *         title: "Default",
     *         values: ["Default Option"]
     *       }],
     *       variants: [
     *         {
     *           title: "Default",
     *           options: {
     *             Default: "Default Option"
     *           },
     *           prices: []
     *         }
     *       ]
     *     }
     *   ],
     *   update: [{
     *     id: "prod_123",
     *     title: "Pants"
     *   }],
     *   delete: ["prod_321"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batch(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/batch`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method creates a product. It sends a request to the
     * [Create Product](https://docs.medusajs.com/api/admin#products_postproducts)
     * API route.
     *
     * @param body - The product's details.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.create({
     *   title: "Shirt",
     *   options: [{
     *     title: "Default",
     *     values: ["Default Option"]
     *   }],
     *   variants: [
     *     {
     *       title: "Default",
     *       options: {
     *         Default: "Default Option"
     *       },
     *       prices: []
     *     }
     *   ],
     *   shipping_profile_id: "sp_123"
     * })
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a product. It sends a request to the
     * [Update Product](https://docs.medusajs.com/api/admin#products_postproductsid)
     * API route.
     *
     * @param id - The product's ID.
     * @param body - The data to update in the product.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.update("prod_123", {
     *   title: "Shirt",
     * })
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of products. It sends a request to the
     * [List Products](https://docs.medusajs.com/api/admin#products_getproducts) API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of products.
     *
     * @example
     * To retrieve the list of products:
     *
     * ```ts
     * sdk.admin.product.list()
     * .then(({ products, count, limit, offset }) => {
     *   console.log(products)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.product.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ products, count, limit, offset }) => {
     *   console.log(products)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each products:
     *
     * ```ts
     * sdk.admin.product.list({
     *   fields: "id,*variants"
     * })
     * .then(({ products, count, limit, offset }) => {
     *   console.log(products)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products`, {
                headers,
                query: queryParams
            });
        });
    }
    /**
     * This method retrieves a product by its ID. It sends a request to the
     * [Get Product](https://docs.medusajs.com/api/admin#products_getproductsid)
     * API route.
     *
     * @param id - The product's ID.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * To retrieve a product by its ID:
     *
     * ```ts
     * sdk.admin.product.retrieve("prod_123")
     * .then(({ product }) => {
     *   console.log(product)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.product.retrieve("prod_123", {
     *   fields: "id,*variants"
     * })
     * .then(({ product }) => {
     *   console.log(product)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product. It sends a request to the
     * [Delete Product](https://docs.medusajs.com/api/admin#products_deleteproductsid)
     * API route.
     *
     * @param id - The product's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.product.delete("prod_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the variants of a product. It sends a request to the
     * [Manage Variants](https://docs.medusajs.com/api/admin#products_postproductsidvariantsbatch)
     * API route.
     *
     * @param productId - The product's ID.
     * @param body - The variants to create, update, or delete.
     * @param query - Configure the fields to retrieve in the product variants.
     * @param headers - Headers to pass in the request
     * @returns The product variants' details.
     *
     * @example
     * sdk.admin.product.batchVariants("prod_123", {
     *   create: [
     *     {
     *       title: "Blue Shirt",
     *       options: {
     *         Color: "Blue"
     *       },
     *       prices: []
     *     }
     *   ],
     *   update: [
     *     {
     *       id: "variant_123",
     *       title: "Pants"
     *     }
     *   ],
     *   delete: ["variant_123"]
     * })
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchVariants(productId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants/batch`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method creates a variant for a product. It sends a request to the
     * [Create Variant](https://docs.medusajs.com/api/admin#products_postproductsidvariants)
     * API route.
     *
     * @param productId - The product's ID.
     * @param body - The variant's details.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.createVariant("prod_123", {
     *   title: "Blue Shirt",
     *   options: {
     *     Color: "Blue"
     *   },
     *   prices: [
     *     {
     *       amount: 10,
     *       currency_code: "usd"
     *     }
     *   ]
     * })
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ createVariant(productId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a variant of a product. It sends a request to the
     * [Update Variant](https://docs.medusajs.com/api/admin#products_postproductsidvariantsvariant_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The variant's ID.
     * @param body - The data to update in the variant.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.updateVariant(
     *   "prod_123",
     *   "variant_123",
     *     {
     *     title: "Blue Shirt",
     *   }
     * )
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ updateVariant(productId, id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of products. It sends a request to the
     * [List Products](https://docs.medusajs.com/api/admin#products_getproductsidvariants) API route.
     *
     * @param productId - The ID of the product to retrieve its variants.
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product variants.
     *
     * @example
     * To retrieve the list of product variants:
     *
     * ```ts
     * sdk.admin.product.listVariants("prod_123")
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.product.listVariants("prod_123", {
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each product variant:
     *
     * ```ts
     * sdk.admin.product.listVariants("prod_123", {
     *   fields: "id,*product"
     * })
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ listVariants(productId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a product's variant. It sends a request to the
     * [Retrieve Variant](https://docs.medusajs.com/api/admin#products_getproductsidvariantsvariant_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The variant's ID.
     * @param query - Configure the fields to retrieve in the product variant.
     * @param headers - Headers to pass in the request
     * @returns The product variant's details.
     *
     * @example
     * To retrieve a product variant by its ID:
     *
     * ```ts
     * sdk.admin.product.retrieveVariant(
     *   "prod_123",
     *   "variant_123"
     * )
     * .then(({ variant }) => {
     *   console.log(variant)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.product.retrieveVariant(
     *   "prod_123",
     *   "variant_123",
     *   {
     *     fields: "id, *product"
     *   }
     * )
     * .then(({ variant }) => {
     *   console.log(variant)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieveVariant(productId, id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product's variant. It sends a request to the
     * [Delete Variant](https://docs.medusajs.com/api/admin#products_deleteproductsidvariantsvariant_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The ID of the variant.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.product.deleteVariant("prod_123", "variant_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ deleteVariant(productId, id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages a product's variant's inventories to associate them with inventory items,
     * update their inventory items, or delete their association with inventory items.
     *
     * It sends a request to the
     * [Manage Variant Inventory](https://docs.medusajs.com/api/admin#products_postproductsidvariantsinventoryitemsbatch)
     * API route.
     *
     * @param productId - The ID of the product that the variant belongs to.
     * @param body - The inventory items to create, update, or delete.
     * @param query - Pass query parameters in the request.
     * @param headers - Headers to pass in the request
     * @returns The details of the created, updated, or deleted inventory items.
     *
     * @example
     * sdk.admin.product.batchVariantInventoryItems(
     *   "prod_123",
     *   {
     *     create: [
     *       {
     *         inventory_item_id: "iitem_123",
     *         variant_id: "variant_123",
     *         required_quantity: 10
     *       }
     *     ],
     *     update: [
     *       {
     *         inventory_item_id: "iitem_1234",
     *         variant_id: "variant_1234",
     *         required_quantity: 20
     *       }
     *     ],
     *     delete: [
     *       {
     *         inventory_item_id: "iitem_321",
     *         variant_id: "variant_321"
     *       }
     *     ]
     *   }
     * )
     * .then(({ created, updated, deleted }) => {
     *   console.log(created, updated, deleted)
     * })
     */ batchVariantInventoryItems(productId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/variants/inventory-items/batch`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method creates an option in a product. It sends a request to the
     * [Create Option](https://docs.medusajs.com/api/admin#products_postproductsidoptions)
     * API route.
     *
     * @param productId - The product's ID.
     * @param body - The option's details.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.createOption(
     *   "prod_123",
     *   {
     *     title: "Color",
     *     values: ["Green", "Blue"]
     *   }
     * )
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ createOption(productId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/options`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a product's option. It sends a request to the
     * [Update Option](https://docs.medusajs.com/api/admin#products_postproductsidoptionsoption_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The ID of the option to update.
     * @param body - The data to update in the option.
     * @param query - Configure the fields to retrieve in the product.
     * @param headers - Headers to pass in the request
     * @returns The product's details.
     *
     * @example
     * sdk.admin.product.updateOption(
     *   "prod_123",
     *   "prodopt_123",
     *   {
     *     title: "Color"
     *   }
     * )
     * .then(({ product }) => {
     *   console.log(product)
     * })
     */ updateOption(productId, id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of product options. It sends a request to the
     * [List Options](https://docs.medusajs.com/api/admin#products_getproductsidoptions) API route.
     *
     * @param productId - The ID of the product to retrieve its options
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product options.
     *
     * @example
     * To retrieve the list of product options:
     *
     * ```ts
     * sdk.admin.product.listOptions("prod_123")
     * .then(({ product_options, count, limit, offset }) => {
     *   console.log(product_options)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.product.listOptions("prod_123", {
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ product_options, count, limit, offset }) => {
     *   console.log(product_options)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each product options:
     *
     * ```ts
     * sdk.admin.product.listOptions("prod_123", {
     *   fields: "id,title"
     * })
     * .then(({ product_options, count, limit, offset }) => {
     *   console.log(product_options)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ listOptions(productId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/options`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a product's option. It sends a request to the
     * [Get Option](https://docs.medusajs.com/api/admin#products_getproductsidoptionsoption_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The product option's ID.
     * @param query - Configure the fields to retrieve in the product option.
     * @param headers - Headers to pass in the request
     * @returns The product option's details.
     *
     * @example
     * To retrieve a product option by its ID:
     *
     * ```ts
     * sdk.admin.product.retrieveOption(
     *   "prod_123",
     *   "prodopt_123"
     * )
     * .then(({ product_option }) => {
     *   console.log(product_option)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.product.retrieveOption(
     *   "prod_123",
     *   "prodopt_123",
     *   {
     *     fields: "id,title"
     *   }
     * )
     * .then(({ product_option }) => {
     *   console.log(product_option)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieveOption(productId, id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product's option. It sends a request to the
     * [Delete Option](https://docs.medusajs.com/api/admin#products_deleteproductsidoptionsoption_id)
     * API route.
     *
     * @param productId - The product's ID.
     * @param id - The option's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.product.deleteOption("prod_123", "prodopt_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ deleteOption(productId, id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=product.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-category.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ProductCategory",
    ()=>ProductCategory
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProductCategory {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a product category. It sends a request to the
     * [Create Category](https://docs.medusajs.com/api/admin#product-categories_postproductcategories)
     * API route.
     *
     * @param body - The details of the category to create.
     * @param query - Configure the fields to retrieve in the category.
     * @param headers - Headers to pass in the request
     * @returns The category's details.
     *
     * @example
     * sdk.admin.productCategory.create({
     *   name: "Shirts"
     * })
     * .then(({ product_category }) => {
     *   console.log(product_category)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a product category. It sends a request to the
     * [Update Category](https://docs.medusajs.com/api/admin#product-categories_postproductcategoriesid)
     * API route.
     *
     * @param id - The product category's ID.
     * @param body - The data to update in the category.
     * @param query - Configure the fields to retrieve in the category.
     * @param headers - Headers to pass in the request
     * @returns The category's details.
     *
     * @example
     * sdk.admin.productCategory.update("pcat_123", {
     *   name: "Shirts"
     * })
     * .then(({ product_category }) => {
     *   console.log(product_category)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of product categories. It sends a request to the
     * [List Product Categories](https://docs.medusajs.com/api/admin#product-categories_getproductcategories) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product categories.
     *
     * @example
     * To retrieve the list of product categories:
     *
     * ```ts
     * sdk.admin.productCategory.list()
     * .then(({ product_categories, count, limit, offset }) => {
     *   console.log(product_categories)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.productCategory.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ product_categories, count, limit, offset }) => {
     *   console.log(product_categories)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each product category:
     *
     * ```ts
     * sdk.admin.productCategory.list({
     *   fields: "id,*products"
     * })
     * .then(({ product_categories, count, limit, offset }) => {
     *   console.log(product_categories)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories`, {
                headers,
                query: query
            });
        });
    }
    /**
     * This method retrieves a product category by its ID. It sends a request to the
     * [Get Product Category](https://docs.medusajs.com/api/admin#product-categories_getproductcategoriesid) API route.
     *
     * @param id - The category's ID.
     * @param query - Configure the fields to retrieve in the product category.
     * @param headers - Headers to pass in the request
     * @returns The product category's details.
     *
     * @example
     * To retrieve a product category by its ID:
     *
     * ```ts
     * sdk.admin.productCategory.retrieve("pcat_123")
     * .then(({ product_category }) => {
     *   console.log(product_category)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.productCategory.retrieve("pcat_123", {
     *   fields: "id,*products"
     * })
     * .then(({ product_category }) => {
     *   console.log(product_category)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product category. It sends a request to the
     * [Delete Product Category](https://docs.medusajs.com/api/admin#product-categories_deleteproductcategoriesid)
     * API route.
     *
     * @param id - The category's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.productCategory.delete("pcat_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manaes the products of a category to add or remove them. It sends a request
     * to the [Manage Products](https://docs.medusajs.com/api/admin#product-categories_postproductcategoriesidproducts)
     * API route.
     *
     * @param id - The category's ID.
     * @param body - The products to create or update.
     * @param query - Configure the fields to retrieve in the product category.
     * @param headers - Headers to pass in the request
     * @returns The product category's details.
     *
     * @example
     * sdk.admin.productCategory.updateProducts("pcat_123", {
     *   add: ["prod_123"],
     *   remove: ["prod_321"]
     * })
     * .then(({ product_category }) => {
     *   console.log(product_category)
     * })
     */ updateProducts(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-categories/${id}/products`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=product-category.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-collection.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ProductCollection",
    ()=>ProductCollection
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProductCollection {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a product collection. It sends a request to the
     * [Create Collection](https://docs.medusajs.com/api/admin#collections_postcollections)
     * API route.
     *
     * @param body - The details of the product collection to create.
     * @param query - Configure the fields to retrieve in the product collection.
     * @param headers - Headers to pass in the request
     * @returns The product collection's details.
     *
     * @example
     * sdk.admin.productCollection.create({
     *   title: "Summer Collection"
     * })
     * .then(({ collection }) => {
     *   console.log(collection)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a collection. It sends a request to the
     * [Update Collection](https://docs.medusajs.com/api/admin#collections_postcollectionsid)
     * API route.
     *
     * @param id - The ID of the collection.
     * @param body - The data to update in the collection.
     * @param query - Configure the fields to retrieve in the product collection.
     * @param headers - Headers to pass in the request
     * @returns The product collection's details.
     *
     * @example
     * sdk.admin.productCollection.update("pcol_123", {
     *   title: "Summer Collection"
     * })
     * .then(({ collection }) => {
     *   console.log(collection)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of collections. It sends a request to the
     * [List Collections](https://docs.medusajs.com/api/admin#collections_getcollections) API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of collections.
     *
     * @example
     * To retrieve the list of collections:
     *
     * ```ts
     * sdk.admin.productCollection.list()
     * .then(({ collections, count, limit, offset }) => {
     *   console.log(collections)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.productCollection.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ collections, count, limit, offset }) => {
     *   console.log(collections)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each collection:
     *
     * ```ts
     * sdk.admin.productCollection.list({
     *   fields: "id,*products"
     * })
     * .then(({ collections, count, limit, offset }) => {
     *   console.log(collections)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections`, {
                headers,
                query: queryParams
            });
        });
    }
    /**
     * This method retrieves a collection by its ID. It sends a request to the
     * [Get Collection](https://docs.medusajs.com/api/admin#collections_getcollectionsid) API route.
     *
     * @param id - The collection's ID.
     * @param query - Configure the fields to retrieve in the collection.
     * @param headers - Headers to pass in the request
     * @returns The collection's details.
     *
     * @example
     * To retrieve a collection by its ID:
     *
     * ```ts
     * sdk.admin.productCollection.retrieve("pcol_123")
     * .then(({ collection }) => {
     *   console.log(collection)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.productCollection.retrieve("pcol_123", {
     *   fields: "id,*products"
     * })
     * .then(({ collection }) => {
     *   console.log(collection)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product collection. It sends a request to the
     * [Delete Collection](https://docs.medusajs.com/api/admin#collections_deletecollectionsid)
     * API route.
     *
     * @param id - The collection's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.productCollection.delete("pcol_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method manages the products of a collection to add or remove them. It sends a request
     * to the [Manage Products](https://docs.medusajs.com/api/admin#collections_postcollectionsidproducts)
     * API route.
     *
     * @param id - The collection's ID.
     * @param body - The products to add or remove.
     * @param headers - Headers to pass in the request
     * @returns The product category's details.
     *
     * @example
     * sdk.admin.productCollection.updateProducts("pcol_123", {
     *   add: ["prod_123"],
     *   remove: ["prod_321"]
     * })
     * .then(({ collection }) => {
     *   console.log(collection)
     * })
     */ updateProducts(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/collections/${id}/products`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=product-collection.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-tag.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ProductTag",
    ()=>ProductTag
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProductTag {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a product tag. It sends a request to the
     * [Create Product Tag](https://docs.medusajs.com/api/admin#product-tags_postproducttags)
     * API route.
     *
     * @param body - The details of the product tag.
     * @param query - Configure the fields to retrieve in the product tag.
     * @param headers - Headers to pass in the request
     * @returns The product tag's details.
     *
     * @example
     * sdk.admin.productTag.create({
     *   value: "shirt"
     * })
     * .then(({ product_tag }) => {
     *   console.log(product_tag)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-tags`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a tag's details. It sends a request to the
     * [Update Product Tag](https://docs.medusajs.com/api/admin#product-tags_postproducttagsid)
     * API route.
     *
     * @param id - The tag's ID.
     * @param body - The data to update in the tag.
     * @param query - Configure the fields to retrieve in the product tag.
     * @param headers - Headers to pass in the request
     * @returns The product tag's details.
     *
     * @example
     * sdk.admin.productTag.update("ptag_123", {
     *   value: "shirt"
     * })
     * .then(({ product_tag }) => {
     *   console.log(product_tag)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-tags/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of product tags. It sends a request to the
     * [List Product Tags](https://docs.medusajs.com/api/admin#product-tags_getproducttags) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product tags.
     *
     * @example
     * To retrieve the list of product tags:
     *
     * ```ts
     * sdk.admin.productTag.list()
     * .then(({ product_tags, count, limit, offset }) => {
     *   console.log(product_tags)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.productTag.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ product_tags, count, limit, offset }) => {
     *   console.log(product_tags)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each product tag:
     *
     * ```ts
     * sdk.admin.productTag.list({
     *   fields: "id,*products"
     * })
     * .then(({ product_tags, count, limit, offset }) => {
     *   console.log(product_tags)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-tags`, {
                headers,
                query: query
            });
        });
    }
    /**
     * This method retrieves a product tag by its ID. It sends a request to the
     * [Get Product Tag](https://docs.medusajs.com/api/admin#product-tags_getproducttagsid) API route.
     *
     * @param id - The product tag's ID.
     * @param query - Configure the fields to retrieve in the product tag.
     * @param headers - Headers to pass in the request
     * @returns The product tag's details.
     *
     * @example
     * To retrieve a product tag by its ID:
     *
     * ```ts
     * sdk.admin.productTag.retrieve("ptag_123")
     * .then(({ product_tag }) => {
     *   console.log(product_tag)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.productTag.retrieve("ptag_123", {
     *   fields: "id,*products"
     * })
     * .then(({ product_tag }) => {
     *   console.log(product_tag)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-tags/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product tag. It sends a request to the
     * [Delete Product Tag](https://docs.medusajs.com/api/admin#product-tags_deleteproducttagsid)
     * API route.
     *
     * @param id - The tag's ID.
     * @param headers - Headers to pass in the request
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.productTag.delete("ptag_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-tags/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=product-tag.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-type.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ProductType",
    ()=>ProductType
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProductType {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a product type. It sends a request to the
     * [Create Product Type](https://docs.medusajs.com/api/admin#product-types_postproducttypes)
     * API route.
     *
     * @param body - The product type's details.
     * @param query - Configure the fields to retrieve in the product type.
     * @param headers - Headers to pass in the request
     * @returns The product type's details.
     *
     * @example
     * sdk.admin.productType.create({
     *   value: "Clothes"
     * })
     * .then(({ product_type }) => {
     *   console.log(product_type)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-types`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a product type. It sends a request to the
     * [Update Product Type](https://docs.medusajs.com/api/admin#product-types_postproducttypesid)
     * API route.
     *
     * @param id - The product type's ID.
     * @param body - The data to update in the product type.
     * @param query - Configure the fields to retrieve in the product type.
     * @param headers - Headers to pass in the request
     * @returns The product type's details.
     *
     * @example
     * sdk.admin.productType.update("ptyp_123", {
     *   value: "Clothes"
     * })
     * .then(({ product_type }) => {
     *   console.log(product_type)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-types/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of product types. It sends a request to the
     * [List Product Types](https://docs.medusajs.com/api/admin#product-types_getproducttypes) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product types.
     *
     * @example
     * To retrieve the list of product types:
     *
     * ```ts
     * sdk.admin.productType.list()
     * .then(({ product_types, count, limit, offset }) => {
     *   console.log(product_types)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.productType.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ product_types, count, limit, offset }) => {
     *   console.log(product_types)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each product type:
     *
     * ```ts
     * sdk.admin.productType.list({
     *   fields: "id,*products"
     * })
     * .then(({ product_types, count, limit, offset }) => {
     *   console.log(product_types)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-types`, {
                headers,
                query: query
            });
        });
    }
    /**
     * This method retrieves a product type by its ID. It sends a request to the
     * [Get Product Type](https://docs.medusajs.com/api/admin#product-types_getproducttypesid)
     * API route.
     *
     * @param id - The product type's ID.
     * @param query - Configure the fields to retrieve in the product type.
     * @param headers - Headers to pass in the request
     * @returns The product type's details.
     *
     * @example
     * To retrieve a product type by its ID:
     *
     * ```ts
     * sdk.admin.productType.retrieve("ptyp_123")
     * .then(({ product_type }) => {
     *   console.log(product_type)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.productType.retrieve("ptyp_123", {
     *   fields: "id,*products"
     * })
     * .then(({ product_type }) => {
     *   console.log(product_type)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-types/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a product type. It sends a request to the
     * [Delete Product Type](https://docs.medusajs.com/api/admin#product-types_deleteproducttypesid)
     * API route.
     *
     * @param id - The product type's ID.
     * @param headers - Headers to pass in the request
     * @returns The product type's details.
     *
     * @example
     * sdk.admin.productType.delete("ptyp_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/product-types/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=product-type.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-variant.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ProductVariant",
    ()=>ProductVariant
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProductVariant {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a paginated list of product variants. It sends a request to the
     * [List Product Variants](https://docs.medusajs.com/api/admin#product-variants_getproductvariants)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of product variants.
     *
     * @example
     * To retrieve the list of product variants:
     *
     * ```ts
     * sdk.admin.productVariant.list()
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.productVariant.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each campaign:
     *
     * ```ts
     * sdk.admin.productVariant.list({
     *   fields: "id,products"
     * })
     * .then(({ variants, count, limit, offset }) => {
     *   console.log(variants)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/product-variants`, {
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=product-variant.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/promotion.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Promotion",
    ()=>Promotion
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Promotion {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a promotion by its ID. It sends a request to the
     * [Retrieve Promotion](https://docs.medusajs.com/api/admin#promotions_getpromotionsid)
     * API route.
     *
     * @param id - The promotion's ID.
     * @param query - Configure the fields to retrieve in the promotion.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * To retrieve a promotion by its ID:
     *
     * ```ts
     * sdk.admin.promotion.retrieve("promo_123")
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.promotion.retrieve("promo_123", {
     *   fields: "id,*application_method"
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}`, {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of promotions. It sends a request to the
     * [List Promotions](https://docs.medusajs.com/api/admin#promotions_getpromotions)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of promotions.
     *
     * @example
     * To retrieve the list of promotions:
     *
     * ```ts
     * sdk.admin.promotion.list()
     * .then(({ promotions, count, limit, offset }) => {
     *   console.log(promotions)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.promotion.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ promotions, count, limit, offset }) => {
     *   console.log(promotions)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each promotion:
     *
     * ```ts
     * sdk.admin.promotion.list({
     *   fields: "id,*application_method"
     * })
     * .then(({ promotions, count, limit, offset }) => {
     *   console.log(promotions)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions`, {
                headers,
                query
            });
        });
    }
    /**
     * This method creates a new promotion. It sends a request to the
     * [Create Promotion](https://docs.medusajs.com/api/admin#promotions_postpromotions)
     * API route.
     *
     * @param payload - The promotion to create.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * sdk.admin.promotion.create({
     *   name: "My Promotion",
     *   description: "This is a test promotion",
     *   code: "PROMO123",
     *   starts_at: "2021-01-01",
     *   ends_at: "2021-01-01",
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ create(payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions`, {
                method: "POST",
                headers,
                body: payload
            });
        });
    }
    /**
     * This method updates a promotion. It sends a request to the
     * [Update Promotion](https://docs.medusajs.com/api/admin#promotions_postpromotionsid)
     * API route.
     *
     * @param id - The promotion's ID.
     * @param payload - The details to update in the promotion.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * sdk.admin.promotion.update("promo_123", {
     *   code: "PROMO123",
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ update(id, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}`, {
                method: "POST",
                headers,
                body: payload
            });
        });
    }
    /**
     * This method deletes a promotion. It sends a request to the
     * [Delete Promotion](https://docs.medusajs.com/api/admin#promotions_deletepromotionsid)
     * API route.
     *
     * @param id - The promotion's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deleted promotion's details.
     *
     * @example
     * sdk.admin.promotion.delete("promo_123")
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method creates and adds rules to a promotion. It can be the promotion's rules,
     * or its application method's buy or target rules. That depends on the rule type
     * you specify as a parameter.
     *
     * - If you set the `ruleType` to `rules`, the method sends a request to the
     * [Manage Promotion's Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidrulesbatch).
     * - If you set the `ruleType` to `buy-rules`, the method sends a request to the
     * [Manage Promotion's Buy Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidbuyrulesbatch).
     * - If you set the `ruleType` to `target-rules`, the method sends a request to the
     * [Manage Promotion's Target Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidtargetrulesbatch).
     *
     * @param id - The promotion's ID.
     * @param ruleType - The type of rules to create.
     * @param payload - The rules to create.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * sdk.admin.promotion.addRules("promo_123", "rules", {
     *   rules: [
     *     {
     *       operator: "eq",
     *       attribute: "product_id",
     *       values: ["prod_123"]
     *     }
     *   ]
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ addRules(id, ruleType, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
                method: "POST",
                headers,
                body: {
                    create: payload.rules
                }
            });
        });
    }
    /**
     * This method updates the rules of a promotion. It can be the promotion's rules,
     * or its application method's buy or target rules. That depends on the rule type
     * you specify as a parameter.
     *
     * - If you set the `ruleType` to `rules`, the method sends a request to the
     * [Manage Promotion's Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidrulesbatch).
     * - If you set the `ruleType` to `buy-rules`, the method sends a request to the
     * [Manage Promotion's Buy Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidbuyrulesbatch).
     * - If you set the `ruleType` to `target-rules`, the method sends a request to the
     * [Manage Promotion's Target Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidtargetrulesbatch).
     *
     * @param id - The promotion's ID.
     * @param ruleType - The type of rules to update.
     * @param payload - The rules to update.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * sdk.admin.promotion.updateRules("promo_123", "rules", {
     *   rules: [
     *     {
     *       id: "rule_123",
     *       operator: "ne",
     *     }
     *   ]
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ updateRules(id, ruleType, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
                method: "POST",
                headers,
                body: {
                    update: payload.rules
                }
            });
        });
    }
    /**
     * This method removes rules from a promotion. It can be the promotion's rules,
     * or its application method's buy or target rules. That depends on the rule type
     * you specify as a parameter.
     *
     * - If you set the `ruleType` to `rules`, the method sends a request to the
     * [Manage Promotion's Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidrulesbatch).
     * - If you set the `ruleType` to `buy-rules`, the method sends a request to the
     * [Manage Promotion's Buy Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidbuyrulesbatch).
     * - If you set the `ruleType` to `target-rules`, the method sends a request to the
     * [Manage Promotion's Target Rules API Route](https://docs.medusajs.com/api/admin#promotions_postpromotionsidtargetrulesbatch).
     *
     * @param id - The promotion's ID.
     * @param ruleType - The type of rules to remove.
     * @param payload - The rules to remove.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's details.
     *
     * @example
     * sdk.admin.promotion.removeRules("promo_123", "rules", {
     *   rule_ids: ["rule_123"]
     * })
     * .then(({ promotion }) => {
     *   console.log(promotion)
     * })
     */ removeRules(id, ruleType, payload, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
                method: "POST",
                headers,
                body: {
                    delete: payload.rule_ids
                }
            });
        });
    }
    /**
     * This method retrieves the rules of a promotion. It can be the promotion's rules,
     * or its application method's buy or target rules. That depends on the rule type
     * you specify as a parameter.
     *
     * This method sends a request to the
     * [List Rules of a Promotion API Route](https://docs.medusajs.com/api/admin#promotions_getpromotionsidrule_type)
     *
     * @param id - The promotion's ID.
     * @param ruleType - The type of rules to retrieve. Can be `rules`, `buy-rules`, or `target-rules`.
     * @param query - Configure the fields to retrieve in the rules.
     * @param headers - Headers to pass in the request.
     * @returns The promotion's rules.
     *
     * @example
     * sdk.admin.promotion.listRules("promo_123", "rules")
     * .then(({ rules }) => {
     *   console.log(rules)
     * })
     */ listRules(id, ruleType, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            // eslint-disable-next-line max-len
            return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}`, {
                headers,
                query
            });
        });
    }
    /**
     * Retrieve a list of potential rule attributes for the promotion and application method types specified in the query parameters. Only the attributes of the rule type specified in the path parameter are retrieved:
     *
     * - If `rule_type` is `rules`, the attributes of the promotion's type are retrieved.
     * - If `rule_type` is `target-rules`, the target rules' attributes of the application method's type are retrieved.
     * - If `rule_type` is `buy-rules`, the buy rules' attributes of the application method's type are retrieved.
     *
     * This method sends a request to the
     * [List Rule Attribute Options API Route](https://docs.medusajs.com/api/admin#promotions_getpromotionsruleattributeoptionsrule_type)
     *
     * @param ruleType - The type of rules to retrieve the attributes for. Can be `rules`, `buy-rules`, or `target-rules`.
     * @param promotionType - The type of promotion to retrieve the attributes for. It can be `standard` or `buyget`.
     * @param applicationMethodTargetType - The type of application method to retrieve the attributes for. It can be `order`, `items` (default) or `shipping_methods`.
     * @param headers - Headers to pass in the request.
     * @returns The list of rule attributes.
     *
     * @example
     * sdk.admin.promotion.listRuleAttributes("rules", "standard")
     * .then(({ attributes }) => {
     *   console.log(attributes)
     * })
     */ listRuleAttributes(ruleType, promotionType, applicationMethodTargetType, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            // eslint-disable-next-line max-len
            return yield this.client.fetch(`/admin/promotions/rule-attribute-options/${ruleType}`, {
                headers,
                query: {
                    promotion_type: promotionType,
                    application_method_target_type: applicationMethodTargetType
                }
            });
        });
    }
    /**
     * Retrieve all potential values for promotion rules and target and buy rules based on the specified rule attribute and type.
     * For example, if you provide the ID of the `currency_code` rule attribute, and set `rule_type` to rules,
     * a list of currencies are retrieved in label-value pairs.
     *
     * This method sends a request to the
     * [List Rule Values API Route](https://docs.medusajs.com/api/admin#promotions_getpromotionsrulevalueoptionsrule_typerule_attribute_id)
     *
     * @param ruleType - The type of rules to retrieve the values for. Can be `rules`, `buy-rules`, or `target-rules`.
     * @param ruleValue - The ID of the rule attribute to retrieve the values for.
     * @param query - Configure the fields to retrieve in the rule values.
     * @param headers - Headers to pass in the request.
     * @returns The list of rule values.
     *
     * @example
     * sdk.admin.promotion.listRuleValues("rules", "attr_123")
     * .then(({ values }) => {
     *   console.log(values)
     * })
     */ listRuleValues(ruleType, ruleValue, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/promotions/rule-value-options/${ruleType}/${ruleValue}`, {
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=promotion.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/refund-reasons.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RefundReason",
    ()=>RefundReason
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class RefundReason {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a list of refund reasons. It sends a request to the
     * [List Refund Reasons](https://docs.medusajs.com/api/admin#refund-reasons_getrefundreasons)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of refund reasons.
     *
     * @example
     * To retrieve the list of refund reasons:
     *
     * ```ts
     * sdk.admin.refundReason.list()
     * .then(({ refund_reasons, count, limit, offset }) => {
     *   console.log(refund_reasons)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.refundReason.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ refund_reasons, count, limit, offset }) => {
     *   console.log(refund_reasons)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each refund reason:
     *
     * ```ts
     * sdk.admin.refundReason.list({
     *   fields: "id,name"
     * })
     * .then(({ refund_reasons, count, limit, offset }) => {
     *   console.log(refund_reasons)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     *
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/refund-reasons`, {
                query,
                headers
            });
        });
    }
} //# sourceMappingURL=refund-reasons.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/region.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Region",
    ()=>Region
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Region {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a new region. It sends a request to the
     * [Create Region](https://docs.medusajs.com/api/admin#regions_postregions)
     * API route.
     *
     * @param body - The details of the region to create.
     * @param query - Configure the fields and relations to retrieve in the region.
     * @param headers - Headers to pass in the request.
     * @returns The created region's details.
     *
     * @example
     * sdk.admin.region.create({
     *   name: "United States",
     *   currency_code: "usd",
     * })
     * .then(({ region }) => {
     *   console.log(region)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/regions`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a region. It sends a request to the
     * [Update Region](https://docs.medusajs.com/api/admin#regions_postregionsid)
     * API route.
     *
     * @param id - The ID of the region to update.
     * @param body - The details of the region to update.
     * @param query - Configure the fields and relations to retrieve in the region.
     * @param headers - Headers to pass in the request.
     * @returns The updated region's details.
     *
     * @example
     * sdk.admin.region.update("region_123", {
     *   name: "United States",
     * })
     * .then(({ region }) => {
     *   console.log(region)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/regions/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a list of regions. It sends a request to the
     * [List Regions](https://docs.medusajs.com/api/admin#regions_getregions)
     * API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of regions.
     *
     * @example
     * To retrieve the list of regions:
     *
     * ```ts
     * sdk.admin.region.list()
     * .then(({ regions, count, limit, offset }) => {
     *   console.log(regions)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.region.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ regions, count, limit, offset }) => {
     *   console.log(regions)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each region:
     *
     * ```ts
     * sdk.admin.region.list({
     *   fields: "id,*countries"
     * })
     * .then(({ regions, count, limit, offset }) => {
     *   console.log(regions)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/regions`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method retrieves a region by ID. It sends a request to the
     * [Get Region](https://docs.medusajs.com/api/admin#regions_getregionsid)
     * API route.
     *
     * @param id - The ID of the region to retrieve.
     * @param query - Configure the fields and relations to retrieve in the region.
     * @param headers - Headers to pass in the request.
     * @returns The region's details.
     *
     * @example
     * To retrieve a region by its ID:
     *
     * ```ts
     * sdk.admin.region.retrieve("region_123")
     * .then(({ region }) => {
     *   console.log(region)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.region.retrieve("region_123", {
     *   fields: "id,*countries"
     * })
     * .then(({ region }) => {
     *   console.log(region)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/regions/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a region by ID. It sends a request to the
     * [Delete Region](https://docs.medusajs.com/api/admin#regions_deleteregionsid)
     * API route.
     *
     * @param id - The ID of the region to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.region.delete("region_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/regions/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=region.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/reservation.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Reservation {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a reservation by ID. It sends a request to the
     * [Get Reservation](https://docs.medusajs.com/api/admin#reservations_getreservationsid)
     * API route.
     *
     * @param id - The reservation's ID.
     * @param query - Configure the fields and relations to retrieve in the reservation.
     * @param headers - Headers to pass in the request.
     * @returns The reservation's details.
     *
     * @example
     * To retrieve a reservation by its ID:
     *
     * ```ts
     * sdk.admin.reservation.retrieve("res_123")
     * .then(({ reservation }) => {
     *   console.log(reservation)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.reservation.retrieve("res_123", {
     *   fields: "id,name"
     * })
     * .then(({ reservation }) => {
     *   console.log(reservation)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/reservations/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of reservations. It sends a request to the
     * [List Reservations](https://docs.medusajs.com/api/admin#reservations_getreservations)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of reservations.
     *
     * @example
     * To retrieve the list of reservations:
     *
     * ```ts
     * sdk.admin.reservation.list()
     * .then(({ reservations, count, limit, offset }) => {
     *   console.log(reservations)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.reservation.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ reservations, count, limit, offset }) => {
     *   console.log(reservations)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each reservation:
     *
     * ```ts
     * sdk.admin.reservation.list({
     *   fields: "id,*inventory_item"
     * })
     * .then(({ reservations, count, limit, offset }) => {
     *   console.log(reservations)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch("/admin/reservations", {
                method: "GET",
                query,
                headers
            });
        });
    }
    /**
     * This method creates a reservation. It sends a request to the
     * [Create Reservation](https://docs.medusajs.com/api/admin#reservations_postreservations)
     * API route.
     *
     * @param body - The details of the reservation to create.
     * @param query - Configure the fields and relations to retrieve in the reservation.
     * @param headers - Headers to pass in the request.
     * @returns The reservation's details.
     *
     * @example
     * sdk.admin.reservation.create({
     *   inventory_item_id: "iitem_123",
     *   location_id: "sloc_123",
     *   quantity: 10,
     * })
     * .then(({ reservation }) => {
     *   console.log(reservation)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch("/admin/reservations", {
                method: "POST",
                body,
                query,
                headers
            });
        });
    }
    /**
     * This method updates a reservation. It sends a request to the
     * [Update Reservation](https://docs.medusajs.com/api/admin#reservations_postreservationsid)
     * API route.
     *
     * @param id - The reservation's ID.
     * @param body - The details of the reservation to update.
     * @param query - Configure the fields and relations to retrieve in the reservation.
     * @param headers - Headers to pass in the request.
     * @returns The reservation's details.
     *
     * @example
     * sdk.admin.reservation.update("res_123", {
     *   quantity: 20,
     * })
     * .then(({ reservation }) => {
     *   console.log(reservation)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/reservations/${id}`, {
                method: "POST",
                body,
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a reservation by ID. It sends a request to the
     * [Delete Reservation](https://docs.medusajs.com/api/admin#reservations_deletereservationsid)
     * API route.
     *
     * @param id - The reservation's ID.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.reservation.delete("res_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/reservations/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
}
const __TURBOPACK__default__export__ = Reservation;
 //# sourceMappingURL=reservation.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/return.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Return",
    ()=>Return
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Return {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a list of returns. It sends a request to the
     * [List Returns](https://docs.medusajs.com/api/admin#returns_getreturns)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of returns.
     *
     * @example
     * To retrieve the list of returns:
     *
     * ```ts
     * sdk.admin.return.list()
     * .then(({ returns, count, limit, offset }) => {
     *   console.log(returns)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.return.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ returns, count, limit, offset }) => {
     *   console.log(returns)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each return:
     *
     * ```ts
     * sdk.admin.return.list({
     *   fields: "id,*items"
     * })
     * .then(({ returns, count, limit, offset }) => {
     *   console.log(returns)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns`, {
                query,
                headers
            });
        });
    }
    /**
     * This method retrieves a return by ID. It sends a request to the
     * [Get Return](https://docs.medusajs.com/api/admin#returns_getreturnsid)
     * API route.
     *
     * @param id - The ID of the return to retrieve.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * To retrieve a return by its ID:
     *
     * ```ts
     * sdk.admin.return.retrieve("return_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.return.retrieve("return_123", {
     *   fields: "id,*items"
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method initiates a return request by creating a return. It sends a request to the
     * [Create Return](https://docs.medusajs.com/api/admin#returns_postreturns)
     * API route.
     *
     * @param body - The details of the return to create.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.initiateRequest({
     *   order_id: "order_123",
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ initiateRequest(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels a return. It sends a request to the
     * [Cancel Return](https://docs.medusajs.com/api/admin#returns_postreturnsidcancel)
     * API route.
     *
     * @param id - The ID of the return to cancel.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.cancel("return_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ cancel(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/cancel`, {
                method: "POST",
                headers,
                query
            });
        });
    }
    /**
     * This method cancels a return request. It sends a request to the
     * [Cancel Return Request](https://docs.medusajs.com/api/admin#returns_deletereturnsidrequest)
     * API route.
     *
     * @param id - The ID of the return to cancel.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.cancelRequest("return_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ cancelRequest(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/request`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds an item to a return request. It sends a request to the
     * [Add Return Item](https://docs.medusajs.com/api/admin#returns_postreturnsidrequestitems)
     * API route.
     *
     * @param id - The ID of the return to add the item to.
     * @param body - The details of the item to add to the return.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.addReturnItem("return_123", {
     *   id: "orlitem_123",
     *   quantity: 1,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ addReturnItem(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/request-items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates an item in a return request by the ID of the item's `RETURN_ITEM` action.
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property. For example,
     * `item.actions.find((action) => action.action === "RETURN_ITEM")?.id` is the ID of an item's `RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Update Requested Return Item](https://docs.medusajs.com/api/admin#returns_postreturnsidrequestitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to update the item in.
     * @param actionId - The ID of the item's `RETURN_ITEM` action.
     * @param body - The details of the item to update.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.updateReturnItem("return_123", "orchach_123", {
     *   quantity: 2,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ updateReturnItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/request-items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes an item from a return request by the ID of the item's `RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property. For example,
     * `item.actions.find((action) => action.action === "RETURN_ITEM")?.id` is the ID of an item's `RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Remove Item from Return](https://docs.medusajs.com/api/admin#returns_deletereturnsidrequestitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to remove the item from.
     * @param actionId - The ID of the item's `RETURN_ITEM` action.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.removeReturnItem("return_123", "orchach_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ removeReturnItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/request-items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds a shipping method to a return request. It sends a request to the
     * [Add Shipping Method to Return](https://docs.medusajs.com/api/admin#returns_postreturnsidshippingmethod)
     * API route.
     *
     * @param id - The ID of the return to add the shipping method to.
     * @param body - The details of the shipping method to add to the return.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.addReturnShipping("return_123", {
     *   shipping_option_id: "so_123",
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ addReturnShipping(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/shipping-method`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a shipping method in a return request by the ID of the shipping method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `shipping_method.actions.find((action) => action.action === "SHIPPING_ADD")?.id` is
     * the ID of a shipping method's `SHIPPING_ADD` action.
     *
     * This method sends a request to the
     * [Update Shipping Method in Return](https://docs.medusajs.com/api/admin#returns_postreturnsidshippingmethodaction_id)
     * API route.
     *
     * @param id - The ID of the return to update the shipping method in.
     * @param actionId - The ID of the shipping method's `SHIPPING_ADD` action.
     * @param body - The details of the shipping method to update.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.updateReturnShipping("return_123", "orchach_123", {
     *   custom_amount: 100,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ updateReturnShipping(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/shipping-method/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes a shipping method from a return request by the ID of the shipping method's `SHIPPING_ADD` action.
     *
     * Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `shipping_method.actions.find((action) => action.action === "SHIPPING_ADD")?.id` is
     * the ID of a shipping method's `SHIPPING_ADD` action.
     *
     * This method sends a request to the
     * [Remove Shipping Method from Return](https://docs.medusajs.com/api/admin#returns_deletereturnsidshippingmethodaction_id)
     * API route.
     *
     * @param id - The ID of the return to remove the shipping method from.
     * @param actionId - The ID of the shipping method's `SHIPPING_ADD` action.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.deleteReturnShipping("return_123", "orchach_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ deleteReturnShipping(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/shipping-method/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method updates a return request. It sends a request to the
     * [Update Return](https://docs.medusajs.com/api/admin#returns_postreturnsid)
     * API route.
     *
     * @param id - The ID of the return to update.
     * @param body - The details of the return to update.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.updateRequest("return_123", {
     *   location_id: "sloc_123",
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ updateRequest(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method confirms a return request. The return's changes are applied on the inventory quantity of the return
     * items and the order only after the return has been confirmed as received using the
     * [Confirm Return Receival](https://docs.medusajs.com/api/admin#returns_postreturnsidreceiveconfirm)
     * API route.
     *
     * This method sends a request to the
     * [Confirm Return Request](https://docs.medusajs.com/api/admin#returns_postreturnsidrequest)
     * API route.
     *
     * @param id - The ID of the return to confirm.
     * @param body - The details of the return to confirm.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.confirmRequest("return_123", {
     *   no_notification: true,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ confirmRequest(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/request`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method starts the return receival process. It sends a request to the
     * [Start Return Receival](https://docs.medusajs.com/api/admin#returns_postreturnsidreceive)
     * API route.
     *
     * @param id - The ID of the return to start the receival process.
     * @param body - The details of the return to start the receival process.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.initiateReceive("return_123", {
     *   internal_note: "Return received by the customer",
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ initiateReceive(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method adds received items to a return. These items will have the action `RECEIVE_RETURN_ITEM`.
     *
     * The method sends a request to the
     * [Add Received Items](https://docs.medusajs.com/api/admin#returns_postreturnsidreceiveitems)
     * API route.
     *
     * @param id - The ID of the return to add the received items to.
     * @param body - The details of the received items to add to the return.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.receiveItems("return_123", {
     *   items: [
     *     { id: "item_123", quantity: 1 },
     *   ],
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ receiveItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive-items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a received item in the return by the ID of the item's `RECEIVE_RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `received_item.actions.find((action) => action.action === "RECEIVE_RETURN_ITEM")?.id` is
     * the ID of a received item's `RECEIVE_RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Update Received Item](https://docs.medusajs.com/api/admin#returns_postreturnsidreceiveitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to update the received item in.
     * @param actionId - The ID of the received item's `RECEIVE_RETURN_ITEM` action.
     * @param body - The details of the received item to update.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.updateReceiveItem("return_123", "orchach_123", {
     *   quantity: 2,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ updateReceiveItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive-items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes a received item from the return by the ID of the item's `RECEIVE_RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `received_item.actions.find((action) => action.action === "RECEIVE_RETURN_ITEM")?.id` is
     * the ID of a received item's `RECEIVE_RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Remove Received Item](https://docs.medusajs.com/api/admin#returns_deletereturnsidreceiveitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to remove the received item from.
     * @param actionId - The ID of the received item's `RECEIVE_RETURN_ITEM` action.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.removeReceiveItem("return_123", "orchach_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ removeReceiveItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive-items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method adds damaged items to the return. These items will have the action `RECEIVE_DAMAGED_RETURN_ITEM`.
     *
     * A damaged item's quantity is not added back to the associated inventory item's quantity in the
     * stock location where the return is initiated from.
     *
     * The method sends a request to the
     * [Add Damaged Items](https://docs.medusajs.com/api/admin#returns_postreturnsiddismissitems)
     * API route.
     *
     * @param id - The ID of the return to add the damaged items to.
     * @param body - The details of the damaged items to add to the return.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.dismissItems("return_123", {
     *   items: [
     *     { id: "orli_123", quantity: 1 },
     *   ],
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ dismissItems(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/dismiss-items`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a damaged item in the return by the ID of the item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `item.actions.find((action) => action.action === "RECEIVE_DAMAGED_RETURN_ITEM")?.id` is
     * the ID of a damaged item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Update Damaged Item](https://docs.medusajs.com/api/admin#returns_postreturnsiddismissitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to update the damaged item in.
     * @param actionId - The ID of the damaged item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     * @param body - The details of the damaged item to update.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.updateDismissItem("return_123", "orchach_123", {
     *   quantity: 2,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ updateDismissItem(id, actionId, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/dismiss-items/${actionId}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method removes a damaged item from the return by the ID of the item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     *
     * Every item has an `actions` property, whose value is an array of actions. You can check the action's name
     * using its `action` property, and use the value of the `id` property.
     *
     * For example, `item.actions.find((action) => action.action === "RECEIVE_DAMAGED_RETURN_ITEM")?.id` is
     * the ID of a damaged item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     *
     * This method sends a request to the
     * [Remove Damaged Item](https://docs.medusajs.com/api/admin#returns_deletereturnsiddismissitemsaction_id)
     * API route.
     *
     * @param id - The ID of the return to remove the damaged item from.
     * @param actionId - The ID of the damaged item's `RECEIVE_DAMAGED_RETURN_ITEM` action.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.removeDismissItem("return_123", "orchach_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ removeDismissItem(id, actionId, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/dismiss-items/${actionId}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
    /**
     * This method confirms the return receival. It sends a request to the
     * [Confirm Return Receival](https://docs.medusajs.com/api/admin#returns_postreturnsidreceiveconfirm)
     * API route.
     *
     * @param id - The ID of the return to confirm the receival of.
     * @param body - The details of the receival confirmation.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.confirmReceive("return_123", {
     *   no_notification: true,
     * })
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ confirmReceive(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive/confirm`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method cancels a return receival. It sends a request to the
     * [Cancel Return Receival](https://docs.medusajs.com/api/admin#returns_deletereturnsidreceive)
     * API route.
     *
     * @param id - The ID of the return to cancel the receival of.
     * @param query - Configure the fields and relations to retrieve in the return.
     * @param headers - Headers to pass in the request.
     * @returns The return's details.
     *
     * @example
     * sdk.admin.return.cancelReceive("return_123")
     * .then(({ return }) => {
     *   console.log(return)
     * })
     */ cancelReceive(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/returns/${id}/receive`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=return.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/return-reason.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReturnReason",
    ()=>ReturnReason
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ReturnReason {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a list of return reasons. It sends a request to the
     * [List Return Reasons](https://docs.medusajs.com/api/admin#return-reasons_returnreason_schema)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of return reasons.
     *
     * @example
     * To retrieve the list of return reasons:
     *
     * ```ts
     * sdk.admin.returnReason.list()
     * .then(({ return_reasons, count, limit, offset }) => {
     *   console.log(return_reasons)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.returnReason.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ return_reasons, count, limit, offset }) => {
     *   console.log(return_reasons)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each return reason:
     *
     * ```ts
     * sdk.admin.returnReason.list({
     *   fields: "id,value"
     * })
     * .then(({ return_reasons, count, limit, offset }) => {
     *   console.log(return_reasons)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch("/admin/return-reasons", {
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a return reason by ID. It sends a request to the
     * [Get Return Reason](https://docs.medusajs.com/api/admin#return-reasons_getreturnreasonsid)
     * API route.
     *
     * @param id - The return reason's ID.
     * @param query - Configure the fields and relations to retrieve in the return reason.
     * @param headers - Headers to pass in the request.
     * @returns The return reason's details.
     *
     * @example
     * To retrieve a return reason by its ID:
     *
     * ```ts
     * sdk.admin.returnReason.retrieve("ret_123")
     * .then(({ return_reason }) => {
     *   console.log(return_reason)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.returnReason.retrieve("ret_123", {
     *   fields: "id,value"
     * })
     * .then(({ return_reason }) => {
     *   console.log(return_reason)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/return-reasons/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method creates a return reason. It sends a request to the
     * [Create Return Reason](https://docs.medusajs.com/api/admin#return-reasons_postreturnreasons)
     * API route.
     *
     * @param body - The details of the return reason to create.
     * @param query - Configure the fields and relations to retrieve in the return reason.
     * @param headers - Headers to pass in the request.
     * @returns The return reason's details.
     *
     * @example
     * sdk.admin.returnReason.create({
     *   value: "refund",
     *   label: "Refund",
     * })
     * .then(({ return_reason }) => {
     *   console.log(return_reason)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/return-reasons`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a return reason. It sends a request to the
     * [Update Return Reason](https://docs.medusajs.com/api/admin#return-reasons_postreturnreasonsid)
     * API route.
     *
     * @param id - The return reason's ID.
     * @param body - The details of the return reason to update.
     * @param query - Configure the fields and relations to retrieve in the return reason.
     * @param headers - Headers to pass in the request.
     * @returns The return reason's details.
     *
     * @example
     * sdk.admin.returnReason.update("ret_123", {
     *   value: "refund",
     *   label: "Refund",
     * })
     * .then(({ return_reason }) => {
     *   console.log(return_reason)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/return-reasons/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a return reason. It sends a request to the
     * [Delete Return Reason](https://docs.medusajs.com/api/admin#return-reasons_deletereturnreasonsid)
     * API route.
     *
     * @param id - The return reason's ID.
     * @param query - Query parameters to pass to the request.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.returnReason.delete("ret_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/return-reasons/${id}`, {
                method: "DELETE",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=return-reason.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/sales-channel.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SalesChannel",
    ()=>SalesChannel
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class SalesChannel {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a new sales channel. It sends a request to the
     * [Create Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_postsaleschannels)
     * API route.
     *
     * @param body - The details of the sales channel to create.
     * @param query - Configure the fields and relations to retrieve in the sales channel.
     * @param headers - Headers to pass in the request.
     * @returns The sales channel's details.
     *
     * @example
     * sdk.admin.salesChannel.create({
     *   name: "Storefront",
     * })
     * .then(({ salesChannel }) => {
     *   console.log(salesChannel)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a sales channel. It sends a request to the
     * [Update Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_postsaleschannelsid)
     * API route.
     *
     * @param id - The ID of the sales channel to update.
     * @param body - The details of the sales channel to update.
     * @param query - Configure the fields and relations to retrieve in the sales channel.
     * @param headers - Headers to pass in the request.
     * @returns The sales channel's details.
     *
     * @example
     * sdk.admin.salesChannel.update(
     *   "sc_123",
     *   {
     *     name: "Storefront",
     *   }
     * )
     * .then(({ salesChannel }) => {
     *   console.log(salesChannel)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a sales channel. It sends a request to the
     * [Delete Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_deletesaleschannelsid)
     * API route.
     *
     * @param id - The ID of the sales channel to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.salesChannel.delete("sc_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a sales channel. It sends a request to the
     * [Retrieve Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_getsaleschannelsid)
     * API route.
     *
     * @param id - The ID of the sales channel to retrieve.
     * @param query - Configure the fields and relations to retrieve in the sales channel.
     * @param headers - Headers to pass in the request.
     * @returns The sales channel's details.
     *
     * @example
     * To retrieve a sales channel by its ID:
     *
     * ```ts
     * sdk.admin.salesChannel.retrieve("sc_123")
     * .then(({ sales_channel }) => {
     *   console.log(sales_channel)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.salesChannel.retrieve("sc_123", {
     *   fields: "id,*products"
     * })
     * .then(({ sales_channel }) => {
     *   console.log(sales_channel)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of sales channels. It sends a request to the
     * [List Sales Channels](https://docs.medusajs.com/api/admin#sales-channels_getsaleschannels)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of sales channels.
     *
     * @example
     * To retrieve the list of sales channels:
     *
     * ```ts
     * sdk.admin.salesChannel.list()
     * .then(({ sales_channels, count, limit, offset }) => {
     *   console.log(sales_channels)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.salesChannel.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ sales_channels, count, limit, offset }) => {
     *   console.log(sales_channels)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each sales channel:
     *
     * ```ts
     * sdk.admin.salesChannel.list({
     *   fields: "id,*products"
     * })
     * .then(({ sales_channels, count, limit, offset }) => {
     *   console.log(sales_channels)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method manages the products in a sales channel to add or remove them. It sends a request to the
     * [Manage Products in Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_postsaleschannelsidproducts)
     * API route.
     *
     * @param id - The ID of the sales channel to manage the products for.
     * @param body - The details of the products to add or remove from the sales channel.
     * @param headers - Headers to pass in the request.
     * @returns The sales channel's details.
     *
     * @example
     * sdk.admin.salesChannel.updateProducts("sc_123", {
     *   add: ["prod_123", "prod_456"],
     *   remove: ["prod_789"]
     * })
     * .then(({ sales_channel }) => {
     *   console.log(sales_channel)
     * })
     *
     * @deprecated Use {@link batchProducts} instead
     */ updateProducts(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels/${id}/products`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method manages the products in a sales channel to add or remove them. It sends a request to the
     * [Manage Products in Sales Channel](https://docs.medusajs.com/api/admin#sales-channels_postsaleschannelsidproducts)
     * API route.
     *
     * @param id - The ID of the sales channel to manage the products for.
     * @param body - The details of the products to add or remove from the sales channel.
     * @param headers - Headers to pass in the request.
     * @returns The sales channel's details.
     *
     * @example
     * sdk.admin.salesChannel.batchProducts("sc_123", {
     *   add: ["prod_123", "prod_456"],
     *   remove: ["prod_789"]
     * })
     * .then(({ sales_channel }) => {
     *   console.log(sales_channel)
     * })
     */ batchProducts(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/sales-channels/${id}/products`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=sales-channel.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-option.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShippingOption",
    ()=>ShippingOption
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ShippingOption {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a shipping option. It sends a request to the
     * [Create Shipping Option](https://docs.medusajs.com/api/admin#shipping-options_postshippingoptions)
     * API route.
     *
     * @param body - The details of the shipping option to create.
     * @param query - Configure the fields and relations to retrieve in the shipping option.
     * @param headers - Headers to pass in the request.
     * @returns The shipping option's details.
     *
     * @example
     * sdk.admin.shippingOption.create({
     *   name: "Standard Shipping",
     *   profile_id: "shp_123",
     * })
     * .then(({ shipping_option }) => {
     *   console.log(shipping_option)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a shipping option. It sends a request to the
     * [Get Shipping Option](https://docs.medusajs.com/api/admin#shipping-options_getshippingoptionsid)
     * API route.
     *
     * @param id - The ID of the shipping option to retrieve.
     * @param query - Configure the fields and relations to retrieve in the shipping option.
     * @param headers - Headers to pass in the request.
     * @returns The shipping option's details.
     *
     * @example
     * To retrieve a shipping option by its ID:
     *
     * ```ts
     * sdk.admin.shippingOption.retrieve("so_123")
     * .then(({ shipping_option }) => {
     *   console.log(shipping_option)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.shippingOption.retrieve("so_123", {
     *   fields: "id,*service_zone"
     * })
     * .then(({ shipping_option }) => {
     *   console.log(shipping_option)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method updates a shipping option. It sends a request to the
     * [Update Shipping Option](https://docs.medusajs.com/api/admin#shipping-options_postshippingoptionsid)
     * API route.
     *
     * @param id - The ID of the shipping option to update.
     * @param body - The details of the shipping option to update.
     * @param query - Configure the fields and relations to retrieve in the shipping option.
     * @param headers - Headers to pass in the request.
     * @returns The shipping option's details.
     *
     * @example
     * sdk.admin.shippingOption.update("so_123", {
     *   name: "Standard Shipping",
     * })
     * .then(({ shipping_option }) => {
     *   console.log(shipping_option)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a shipping option. It sends a request to the
     * [Delete Shipping Option](https://docs.medusajs.com/api/admin#shipping-options_deleteshippingoptionsid)
     * API route.
     *
     * @param id - The ID of the shipping option to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.shippingOption.delete("so_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a list of shipping options. It sends a request to the
     * [List Shipping Options](https://docs.medusajs.com/api/admin#shipping-options_getshippingoptions)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of shipping options.
     *
     * @example
     * To retrieve the list of shipping options:
     *
     * ```ts
     * sdk.admin.shippingOption.list()
     * .then(({ shipping_options, count, limit, offset }) => {
     *   console.log(shipping_options)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.shippingOption.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ shipping_options, count, limit, offset }) => {
     *   console.log(shipping_options)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each shipping option:
     *
     * ```ts
     * sdk.admin.shippingOption.list({
     *   fields: "id,*service_zone"
     * })
     * .then(({ shipping_options, count, limit, offset }) => {
     *   console.log(shipping_options)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method manages the rules of a shipping option to create, update, or remove them. It sends a request to the
     * [Manage Rules of a Shipping Option](https://docs.medusajs.com/api/admin#shipping-options_postshippingoptionsidrulesbatch)
     * API route.
     *
     * @param id - The ID of the shipping option to manage the rules for.
     * @param body - The details of the shipping option rules to manage.
     * @param headers - Headers to pass in the request.
     * @returns The shipping option's details.
     *
     * @example
     * sdk.admin.shippingOption.updateRules("so_123", {
     *   create: [{ attribute: "enabled_in_store", operator: "eq", value: "true" }],
     * })
     * .then(({ shipping_option }) => {
     *   console.log(shipping_option)
     * })
     */ updateRules(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-options/${id}/rules/batch`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=shipping-option.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-profile.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShippingProfile",
    ()=>ShippingProfile
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ShippingProfile {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a new shipping profile. It sends a request to the
     * [Create Shipping Profile](https://docs.medusajs.com/api/admin#shipping-profiles_postshippingprofiles)
     * API route.
     *
     * @param body - The details of the shipping profile to create.
     * @param query - Configure the fields and relations to retrieve in the shipping profile.
     * @param headers - Headers to pass in the request.
     * @returns The shipping profile's details.
     *
     * @example
     * sdk.admin.shippingProfile.create({
     *   name: "Default Shipping Profile",
     * })
     * .then(({ shipping_profile }) => {
     *   console.log(shipping_profile)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-profiles`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a shipping profile. It sends a request to the
     * [Update Shipping Profile](https://docs.medusajs.com/api/admin#shipping-profiles_postshippingprofilesid)
     * API route.
     *
     * @param id - The ID of the shipping profile to update.
     * @param body - The details of the shipping profile to update.
     * @param query - Configure the fields and relations to retrieve in the shipping profile.
     * @param headers - Headers to pass in the request.
     * @returns The shipping profile's details.
     *
     * @example
     * sdk.admin.shippingProfile.update("sp_123", {
     *   name: "Updated Shipping Profile",
     * })
     * .then(({ shipping_profile }) => {
     *   console.log(shipping_profile)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a shipping profile. It sends a request to the
     * [Delete Shipping Profile](https://docs.medusajs.com/api/admin#shipping-profiles_deleteshippingprofilesid)
     * API route.
     *
     * @param id - The ID of the shipping profile to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.shippingProfile.delete("sp_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a list of shipping profiles. It sends a request to the
     * [List Shipping Profiles](https://docs.medusajs.com/api/admin#shipping-profiles_getshippingprofiles)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of shipping profiles.
     *
     * @example
     * To retrieve the list of shipping profiles:
     *
     * ```ts
     * sdk.admin.shippingProfile.list()
     * .then(({ shipping_profiles, count, limit, offset }) => {
     *   console.log(shipping_profiles)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.shippingProfile.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ shipping_profiles, count, limit, offset }) => {
     *   console.log(shipping_profiles)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each shipping profile:
     *
     * ```ts
     * sdk.admin.shippingProfile.list({
     *   fields: "id,name"
     * })
     * .then(({ shipping_profiles, count, limit, offset }) => {
     *   console.log(shipping_profiles)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-profiles`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a shipping profile. It sends a request to the
     * [Get Shipping Profile](https://docs.medusajs.com/api/admin#shipping-profiles_getshippingprofilesid)
     * API route.
     *
     * @param id - The ID of the shipping profile to retrieve.
     * @param query - Configure the fields and relations to retrieve in the shipping profile.
     * @param headers - Headers to pass in the request.
     * @returns The shipping profile's details.
     *
     * @example
     * To retrieve a shipping profile by its ID:
     *
     * ```ts
     * sdk.admin.shippingProfile.retrieve("sp_123")
     * .then(({ shipping_profile }) => {
     *   console.log(shipping_profile)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.shippingProfile.retrieve("sp_123", {
     *   fields: "id,name"
     * })
     * .then(({ shipping_profile }) => {
     *   console.log(shipping_profile)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=shipping-profile.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/stock-location.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StockLocation",
    ()=>StockLocation
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class StockLocation {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a new stock location. It sends a request to the
     * [Create Stock Location](https://docs.medusajs.com/api/admin#stock-locations_poststocklocations)
     * API route.
     *
     * @param body - The details of the stock location to create.
     * @param query - Configure the fields and relations to retrieve in the stock location.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * sdk.admin.stockLocation.create({
     *   name: "Main Warehouse",
     *   address_id: "addr_123",
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a stock location. It sends a request to the
     * [Update Stock Location](https://docs.medusajs.com/api/admin#stock-locations_poststocklocationsid)
     * API route.
     *
     * @param id - The ID of the stock location to update.
     * @param body - The details of the stock location to update.
     * @param query - Configure the fields and relations to retrieve in the stock location.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * sdk.admin.stockLocation.update("sloc_123", {
     *   name: "European Warehouse",
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a stock location. It sends a request to the
     * [Delete Stock Location](https://docs.medusajs.com/api/admin#stock-locations_deletestocklocationsid)
     * API route.
     *
     * @param id - The ID of the stock location to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.stockLocation.delete("sloc_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a stock location. It sends a request to the
     * [Get Stock Location](https://docs.medusajs.com/api/admin#stock-locations_getstocklocationsid)
     * API route.
     *
     * @param id - The ID of the stock location to retrieve.
     * @param query - Configure the fields and relations to retrieve in the stock location.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * To retrieve a stock location by its ID:
     *
     * ```ts
     * sdk.admin.stockLocation.retrieve("sloc_123")
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.stockLocation.retrieve("sloc_123", {
     *   fields: "id,*sales_channels"
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of stock locations. It sends a request to the
     * [List Stock Locations](https://docs.medusajs.com/api/admin#stock-locations_getstocklocations)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of stock locations.
     *
     * @example
     * To retrieve the list of stock locations:
     *
     * ```ts
     * sdk.admin.stockLocation.list()
     * .then(({ stock_locations, count, limit, offset }) => {
     *   console.log(stock_locations)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.stockLocation.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ stock_locations, count, limit, offset }) => {
     *   console.log(stock_locations)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each stock location:
     *
     * ```ts
     * sdk.admin.stockLocation.list({
     *   fields: "id,*sales_channels"
     * })
     * .then(({ stock_locations, count, limit, offset }) => {
     *   console.log(stock_locations)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method manages the sales channels of a stock location by adding or removing them. It sends a request to the
     * [Manage Stock Location Sales Channels](https://docs.medusajs.com/api/admin#stock-locations_poststocklocationsidsaleschannels)
     * API route.
     *
     * @param id - The ID of the stock location to update the sales channels for.
     * @param body - The details of the sales channels to update.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * sdk.admin.stockLocation.updateSalesChannels("sloc_123", {
     *   add: ["sc_123"],
     *   remove: ["sc_456"],
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     */ updateSalesChannels(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}/sales-channels`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method adds a new fulfillment set to a stock location. It sends a request to the
     * [Add Fulfillment Set to Stock Location](https://docs.medusajs.com/api/admin#stock-locations_poststocklocationsidfulfillmentsets)
     * API route.
     *
     * @param id - The ID of the stock location to add the fulfillment set to.
     * @param body - The details of the fulfillment set to add.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * sdk.admin.stockLocation.createFulfillmentSet("sloc_123", {
     *   name: "Shipping",
     *   type: "shipping",
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     */ createFulfillmentSet(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}/fulfillment-sets`, {
                method: "POST",
                headers,
                body
            });
        });
    }
    /**
     * This method manages the fulfillment providers of a stock location by adding or removing them. It sends a request to the
     * [Manage Fulfillment Providers of Stock Location](https://docs.medusajs.com/api/admin#stock-locations_poststocklocationsidfulfillmentproviders)
     * API route.
     *
     * @param id - The ID of the stock location to manage the fulfillment providers for.
     * @param body - The details of the fulfillment providers to manage.
     * @param headers - Headers to pass in the request.
     * @returns The stock location's details.
     *
     * @example
     * sdk.admin.stockLocation.updateFulfillmentProviders("sloc_123", {
     *   add: ["fp_manual_manual"],
     *   remove: ["fp_shipstation_shipstation"],
     * })
     * .then(({ stock_location }) => {
     *   console.log(stock_location)
     * })
     */ updateFulfillmentProviders(id, body, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stock-locations/${id}/fulfillment-providers`, {
                method: "POST",
                headers,
                body
            });
        });
    }
} //# sourceMappingURL=stock-location.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/store.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Store",
    ()=>Store
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Store {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a store by its ID. It sends a request to the
     * [Get Store](https://docs.medusajs.com/api/admin#stores_getstoresid)
     * API route.
     *
     * @param id - The ID of the store to retrieve.
     * @param query - Configure the fields and relations to retrieve in the store.
     * @param headers - Headers to pass in the request.
     * @returns The store's details.
     *
     * @example
     * To retrieve a store by its ID:
     *
     * ```ts
     * sdk.admin.store.retrieve("store_123")
     * .then(({ store }) => {
     *   console.log(store)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.store.retrieve("store_123", {
     *   fields: "id,*supported_currencies"
     * })
     * .then(({ store }) => {
     *   console.log(store)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stores/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of stores. It sends a request to the
     * [List Stores](https://docs.medusajs.com/api/admin#stores_getstores)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of stores.
     *
     * @example
     * To retrieve the list of stores:
     *
     * ```ts
     * sdk.admin.store.list()
     * .then(({ stores, count, limit, offset }) => {
     *   console.log(stores)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.store.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ stores, count, limit, offset }) => {
     *   console.log(stores)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each store:
     *
     * ```ts
     * sdk.admin.store.list({
     *   fields: "id,*supported_currencies"
     * })
     * .then(({ stores, count, limit, offset }) => {
     *   console.log(stores)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stores`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method updates a store. It sends a request to the
     * [Update Store](https://docs.medusajs.com/api/admin#stores_poststoresid)
     * API route.
     *
     * @param id - The ID of the store to update.
     * @param body - The details of the store to update.
     * @param query - Configure the fields and relations to retrieve in the store.
     * @param headers - Headers to pass in the request.
     * @returns The store's details.
     *
     * @example
     * sdk.admin.store.update("store_123", {
     *   name: "My Store",
     * })
     * .then(({ store }) => {
     *   console.log(store)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/stores/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=store.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-provider.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TaxProvider",
    ()=>TaxProvider
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const taxProviderUrl = "/admin/tax-providers";
class TaxProvider {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a list of tax providers. It sends a request to the
     * [List Tax Providers](https://docs.medusajs.com/api/admin#tax-providers_gettaxproviders)
     * API route.
     *
     * @since 2.8.0
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of tax providers.
     *
     * @example
     * To retrieve the list of tax providers:
     *
     * ```ts
     * sdk.admin.taxProvider.list()
     * .then(({ tax_providers, count, limit, offset }) => {
     *   console.log(tax_providers)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.taxProvider.list({
     *   limit: 10,
     *   offset: 10,
     * })
     * .then(({ tax_providers, count, limit, offset }) => {
     *   console.log(tax_providers)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each products:
     *
     * ```ts
     * sdk.admin.taxProvider.list({
     *   fields: "id,*regions"
     * })
     * .then(({ tax_providers, count, limit, offset }) => {
     *   console.log(tax_providers)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(taxProviderUrl, {
                method: "GET",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=tax-provider.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-rate.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TaxRate",
    ()=>TaxRate
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const taxRateUrl = "/admin/tax-rates";
class TaxRate {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a tax rate. It sends a request to the
     * [Create Tax Rate](https://docs.medusajs.com/api/admin#tax-rates_posttaxrates)
     * API route.
     *
     * @param body - The details of the tax rate to create.
     * @param query - Configure the fields and relations to retrieve in the tax rate.
     * @param headers - Headers to pass in the request.
     * @returns The tax rate's details.
     *
     * @example
     * sdk.admin.taxRate.create({
     *   name: "VAT",
     *   tax_region_id: "txreg_123",
     *   code: "VAT",
     *   rate: 2, // 2%
     * })
     * .then(({ tax_rate }) => {
     *   console.log(tax_rate)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(taxRateUrl, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a tax rate. It sends a request to the
     * [Update Tax Rate](https://docs.medusajs.com/api/admin#tax-rates_posttaxratesid)
     * API route.
     *
     * @param id - The ID of the tax rate to update.
     * @param body - The details of the tax rate to update.
     * @param query - Configure the fields and relations to retrieve in the tax rate.
     * @param headers - Headers to pass in the request.
     * @returns The tax rate's details.
     *
     * @example
     * sdk.admin.taxRate.update("txrat_123", {
     *   name: "VAT",
     *   code: "VAT",
     * })
     * .then(({ tax_rate }) => {
     *   console.log(tax_rate)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRateUrl}/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a tax rate. It sends a request to the
     * [Delete Tax Rate](https://docs.medusajs.com/api/admin#tax-rates_deletetaxratesid)
     * API route.
     *
     * @param id - The ID of the tax rate to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.taxRate.delete("txrat_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRateUrl}/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a tax rate. It sends a request to the
     * [Get Tax Rate](https://docs.medusajs.com/api/admin#tax-rates_gettaxratesid)
     * API route.
     *
     * @param id - The ID of the tax rate to retrieve.
     * @param query - Configure the fields and relations to retrieve in the tax rate.
     * @param headers - Headers to pass in the request.
     * @returns The tax rate's details.
     *
     * @example
     * To retrieve a tax rate by its ID:
     *
     * ```ts
     * sdk.admin.taxRate.retrieve("txrat_123")
     * .then(({ tax_rate }) => {
     *   console.log(tax_rate)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.taxRate.retrieve("txrat_123", {
     *   fields: "id,*tax_region"
     * })
     * .then(({ tax_rate }) => {
     *   console.log(tax_rate)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRateUrl}/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of tax rates. It sends a request to the
     * [List Tax Rates](https://docs.medusajs.com/api/admin#tax-rates_gettaxrates)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of tax rates.
     *
     * @example
     * To retrieve the list of tax rates:
     *
     * ```ts
     * sdk.admin.taxRate.list()
     * .then(({ tax_rates, count, limit, offset }) => {
     *   console.log(tax_rates)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.taxRate.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ tax_rates, count, limit, offset }) => {
     *   console.log(tax_rates)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each tax rate:
     *
     * ```ts
     * sdk.admin.taxRate.list({
     *   fields: "id,*tax_region"
     * })
     * .then(({ tax_rates, count, limit, offset }) => {
     *   console.log(tax_rates)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(taxRateUrl, {
                method: "GET",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=tax-rate.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-region.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TaxRegion",
    ()=>TaxRegion
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const taxRegionUrl = "/admin/tax-regions";
class TaxRegion {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a tax region. It sends a request to the
     * [Create Tax Region](https://docs.medusajs.com/api/admin#tax-regions_posttaxregions)
     * API route.
     *
     * @param body - The details of the tax region to create.
     * @param query - Configure the fields and relations to retrieve in the tax region.
     * @param headers - Headers to pass in the request.
     * @returns The tax region's details.
     *
     * @example
     * sdk.admin.taxRegion.create({
     *   country_code: "us",
     *   province_code: "ca",
     *   default_tax_rate: {
     *     code: "VAT",
     *     name: "VAT",
     *     rate: 20, // 20%
     *     is_combinable: true,
     *   },
     * })
     * .then(({ tax_region }) => {
     *   console.log(tax_region)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(taxRegionUrl, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a tax region. It sends a request to the
     * [Update Tax Region](https://docs.medusajs.com/api/admin#tax-regions_posttaxregionsid)
     * API route.
     *
     * @since 2.8.0
     *
     * @param id - The ID of the tax region to update.
     * @param body - The details of the tax region to update.
     * @param query - Configure the fields and relations to retrieve in the tax region.
     * @param headers - Headers to pass in the request.
     * @returns The tax region's details.
     *
     * @example
     * sdk.admin.taxRegion.update("txreg_123", {
     *   province_code: "ca",
     * })
     * .then(({ tax_region }) => {
     *   console.log(tax_region)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRegionUrl}/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method deletes a tax region. It sends a request to the
     * [Delete Tax Region](https://docs.medusajs.com/api/admin#tax-regions_deletetaxregionsid)
     * API route.
     *
     * @param id - The ID of the tax region to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.taxRegion.delete("txreg_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRegionUrl}/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves a tax region. It sends a request to the
     * [Get Tax Region](https://docs.medusajs.com/api/admin#tax-regions_gettaxregionsid)
     * API route.
     *
     * @param id - The ID of the tax region to retrieve.
     * @param query - Configure the fields and relations to retrieve in the tax region.
     * @param headers - Headers to pass in the request.
     * @returns The tax region's details.
     *
     * @example
     * To retrieve a tax region by its ID:
     *
     * ```ts
     * sdk.admin.taxRegion.retrieve("txreg_123")
     * .then(({ tax_region }) => {
     *   console.log(tax_region)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.taxRegion.retrieve("txreg_123", {
     *   fields: "id,*tax_rates"
     * })
     * .then(({ tax_region }) => {
     *   console.log(tax_region)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`${taxRegionUrl}/${id}`, {
                method: "GET",
                headers,
                query
            });
        });
    }
    /**
     * This method retrieves a list of tax regions. It sends a request to the
     * [List Tax Regions](https://docs.medusajs.com/api/admin#tax-regions_gettaxregions)
     * API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of tax regions.
     *
     * @example
     * To retrieve the list of tax regions:
     *
     * ```ts
     * sdk.admin.taxRegion.list()
     * .then(({ tax_regions, count, limit, offset }) => {
     *   console.log(tax_regions)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.taxRegion.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ tax_regions, count, limit, offset }) => {
     *   console.log(tax_regions)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each tax region:
     *
     * ```ts
     * sdk.admin.taxRegion.list({
     *   fields: "id,*tax_rates"
     * })
     * .then(({ tax_regions, count, limit, offset }) => {
     *   console.log(tax_regions)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(taxRegionUrl, {
                method: "GET",
                headers,
                query
            });
        });
    }
} //# sourceMappingURL=tax-region.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/upload.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Upload",
    ()=>Upload
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Upload {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a new upload. It sends a request to the
     * [Upload Files](https://docs.medusajs.com/api/admin#uploads_postuploads)
     * API route.
     *
     * @param body - The details of the files to upload.
     * @param query - Configure the fields and relations to retrieve in the uploaded files.
     * @param headers - Headers to pass in the request.
     * @returns The upload files' details.
     *
     * @privateRemarks
     *
     * Note: The creation/upload flow be made more advanced, with support for streaming and progress, but for now we keep it simple
     *
     * @example
     * sdk.admin.upload.create(
     *   {
     *     files: [
     *        // file uploaded as a binary string
     *       {
     *         name: "test.txt",
     *         content: "test", // Should be the binary string of the file
     *       },
     *       // file uploaded as a File object
     *       new File(["test"], "test.txt", { type: "text/plain" })
     *     ],
     *   }
     * )
     * .then(({ files }) => {
     *   console.log(files)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            const form = new FormData();
            if (body instanceof FileList) {
                Array.from(body).forEach((file)=>{
                    form.append("files", file);
                });
            } else {
                body.files.forEach((file)=>{
                    form.append("files", "content" in file ? new Blob([
                        file.content
                    ], {
                        type: "text/plain"
                    }) : file, file.name);
                });
            }
            return this.client.fetch(`/admin/uploads`, {
                method: "POST",
                headers: Object.assign(Object.assign({}, headers), {
                    // Let the browser determine the content type.
                    "content-type": null
                }),
                body: form,
                query
            });
        });
    }
    /**
     * This method retrieves a file's details by its ID. It sends a request to the
     * [Get File](https://docs.medusajs.com/api/admin#uploads_getuploadsid)
     * API route.
     *
     * @param id - The ID of the file to retrieve.
     * @param query - Query parameters to pass in the request.
     * @param headers - Headers to pass in the request.
     * @returns The file's details.
     *
     * @example
     * sdk.admin.upload.retrieve("test.txt")
     * .then(({ file }) => {
     *   console.log(file)
     * })
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/uploads/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a file by its ID from the configured File Module Provider. It sends a request to the
     * [Delete File](https://docs.medusajs.com/api/admin#uploads_deleteuploadsid)
     * API route.
     *
     * @param id - The ID of the file to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.upload.delete("test.txt")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/uploads/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method creates a presigned URL for a file upload. It sends a request to the
     * `/admin/uploads/presigned-urls` API route.
     *
     * @param body - The details of the file to upload.
     * @param query - Query parameters to pass in the request.
     * @param headers - Headers to pass in the request.
     * @returns The presigned URL for the file upload.
     *
     * @example
     * sdk.admin.upload.presignedUrl({
     *   name: "test.txt",
     *   size: 1000,
     *   type: "text/plain",
     * }))
     */ presignedUrl(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/uploads/presigned-urls`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
} //# sourceMappingURL=upload.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/user.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "User",
    ()=>User
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class User {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method updates a user. It sends a request to the
     * [Update User](https://docs.medusajs.com/api/admin#users_postusersid)
     * API route.
     *
     * @param id - The ID of the user to update.
     * @param body - The details of the user to update.
     * @param query - Configure the fields and relations to retrieve in the tax region.
     * @param headers - Headers to pass in the request.
     * @returns The user's details.
     *
     * @example
     * sdk.admin.user.update("user_123", {
     *   first_name: "John",
     *   last_name: "Doe",
     * })
     * .then(({ user }) => {
     *   console.log(user)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/users/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a list of users. It sends a request to the
     * [List Users](https://docs.medusajs.com/api/admin#users_getusers)
     * API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of users.
     *
     * @example
     * To retrieve the list of users:
     *
     * ```ts
     * sdk.admin.user.list()
     * .then(({ users, count, limit, offset }) => {
     *   console.log(users)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.user.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ users, count, limit, offset }) => {
     *   console.log(users)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each user:
     *
     * ```ts
     * sdk.admin.user.list({
     *   fields: "id,email"
     * })
     * .then(({ users, count, limit, offset }) => {
     *   console.log(users)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/users`, {
                headers,
                query: queryParams
            });
        });
    }
    /**
     * This method retrieves a user. It sends a request to the
     * [Get User](https://docs.medusajs.com/api/admin#users_getusersid)
     * API route.
     *
     * @param id - The ID of the user to retrieve.
     * @param query - Configure the fields and relations to retrieve in the user.
     * @param headers - Headers to pass in the request.
     * @returns The user's details.
     *
     * @example
     * To retrieve a user by its ID:
     *
     * ```ts
     * sdk.admin.user.retrieve("user_123")
     * .then(({ user }) => {
     *   console.log(user)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.user.retrieve("user_123", {
     *   fields: "id,email"
     * })
     * .then(({ user }) => {
     *   console.log(user)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/users/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a user. It sends a request to the
     * [Delete User](https://docs.medusajs.com/api/admin#users_deleteusersid)
     * API route.
     *
     * @param id - The ID of the user to delete.
     * @param headers - Headers to pass in the request.
     * @returns The deletion's details.
     *
     * @example
     * sdk.admin.user.delete("user_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/users/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
    /**
     * This method retrieves the currently authenticated user. It sends a request to the
     * [Get Logged-In User](https://docs.medusajs.com/api/admin#users_getusersme)
     * API route.
     *
     * @param query - Configure the fields and relations to retrieve in the user.
     * @param headers - Headers to pass in the request.
     * @returns The user's details.
     *
     * @example
     * To retrieve the currently authenticated user:
     *
     * ```ts
     * sdk.admin.user.me()
     * .then(({ user }) => {
     *   console.log(user)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.user.me({
     *   fields: "id,email"
     * })
     * .then(({ user }) => {
     *   console.log(user)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ me(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/users/me`, {
                query,
                headers
            });
        });
    }
} //# sourceMappingURL=user.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/workflow-execution.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WorkflowExecution",
    ()=>WorkflowExecution
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class WorkflowExecution {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method retrieves a list of workflow executions. It sends a request to the
     * [List Workflow Executions](https://docs.medusajs.com/api/admin#workflows-executions_getworkflowsexecutions)
     * API route.
     *
     * @param queryParams - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The list of workflow executions.
     *
     * @example
     * To retrieve the list of workflow executions:
     *
     * ```ts
     * sdk.admin.workflowExecution.list()
     * .then(({ workflow_executions, count, limit, offset }) => {
     *   console.log(workflow_executions)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.workflowExecution.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ workflow_executions, count, limit, offset }) => {
     *   console.log(workflow_executions)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each workflow execution:
     *
     * ```ts
     * sdk.admin.workflowExecution.list({
     *   fields: "id,name"
     * })
     * .then(({ workflow_executions, count, limit, offset }) => {
     *   console.log(workflow_executions)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/admin#select-fields-and-relations).
     */ list(queryParams, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/workflows-executions`, {
                query: queryParams,
                headers
            });
        });
    }
    /**
     * This method retrieves a workflow execution by its ID. It sends a request to the
     * [Get Workflow Execution](https://docs.medusajs.com/api/admin#workflows-executions_getworkflowsexecutionsworkflow_idtransaction_id)
     * API route.
     *
     * @param id - The ID of the workflow execution to retrieve.
     * @param headers - Headers to pass in the request.
     * @returns The workflow execution's details.
     *
     * @example
     * sdk.admin.workflowExecution.retrieve("wrk_123")
     * .then(({ workflow_execution }) => {
     *   console.log(workflow_execution)
     * })
     */ retrieve(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.client.fetch(`/admin/workflows-executions/${id}`, {
                headers
            });
        });
    }
} //# sourceMappingURL=workflow-execution.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-option-type.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShippingOptionType",
    ()=>ShippingOptionType
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ShippingOptionType {
    /**
     * @ignore
     */ constructor(client){
        this.client = client;
    }
    /**
     * This method creates a shipping option type. It sends a request to the
     * [Create Shipping Option Type](https://docs.medusajs.com/api/admin#shipping-option-types_postshippingoptiontypes)
     * API route.
     *
     * @param body - The shipping option type's details.
     * @param query - Configure the fields to retrieve in the shipping option type.
     * @param headers - Headers to pass in the request
     * @returns The shipping option type's details.
     *
     * @example
     * sdk.admin.shippingOptionType.create({
     *   label: "Standard",
     *   code: "standard",
     *   description: "Ship in 2-3 days."
     * })
     * .then(({ shipping_option_type }) => {
     *   console.log(shipping_option_type)
     * })
     */ create(body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/shipping-option-types`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method updates a shipping option type. It sends a request to the
     * [Update Shipping Option Type](https://docs.medusajs.com/api/admin#shipping-option-types_postshippingoptiontypesid)
     * API route.
     *
     * @param id - The shipping option type's ID.
     * @param body - The data to update in the shipping option type.
     * @param query - Configure the fields to retrieve in the shipping option type.
     * @param headers - Headers to pass in the request
     * @returns The shipping option type's details.
     *
     * @example
     * sdk.admin.shippingOptionType.update("sotype_123", {
     *   code: "express"
     * })
     * .then(({ shipping_option_type }) => {
     *   console.log(shipping_option_type)
     * })
     */ update(id, body, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/shipping-option-types/${id}`, {
                method: "POST",
                headers,
                body,
                query
            });
        });
    }
    /**
     * This method retrieves a paginated list of shipping option types. It sends a request to the
     * [List Shipping Option Types](https://docs.medusajs.com/api/admin#shipping-option-types_getshippingoptiontypes) API route.
     *
     * @param query - Filters and pagination configurations.
     * @param headers - Headers to pass in the request.
     * @returns The paginated list of shipping option types.
     *
     * @example
     * To retrieve the list of shipping option types:
     *
     * ```ts
     * sdk.admin.shippingOptionType.list()
     * .then(({ shipping_option_types, count, limit, offset }) => {
     *   console.log(shipping_option_types)
     * })
     * ```
     *
     * To configure the pagination, pass the `limit` and `offset` query parameters.
     *
     * For example, to retrieve only 10 items and skip 10 items:
     *
     * ```ts
     * sdk.admin.shippingOptionType.list({
     *   limit: 10,
     *   offset: 10
     * })
     * .then(({ shipping_option_types, count, limit, offset }) => {
     *   console.log(shipping_option_types)
     * })
     * ```
     *
     * Using the `fields` query parameter, you can specify the fields and relations to retrieve
     * in each shipping option type:
     *
     * ```ts
     * sdk.admin.shippingOptionType.list({
     *   fields: "id,*shippingOptions"
     * })
     * .then(({ shipping_option_types, count, limit, offset }) => {
     *   console.log(shipping_option_types)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ list(query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/shipping-option-types`, {
                headers,
                query: query
            });
        });
    }
    /**
     * This method retrieves a shipping option type by its ID. It sends a request to the
     * [Get Shipping Option Type](https://docs.medusajs.com/api/admin#shipping-option-types_getshippingoptiontypesid)
     * API route.
     *
     * @param id - The shipping option type's ID.
     * @param query - Configure the fields to retrieve in the shipping option type.
     * @param headers - Headers to pass in the request
     * @returns The shipping option type's details.
     *
     * @example
     * To retrieve a shipping option type by its ID:
     *
     * ```ts
     * sdk.admin.shippingOptionType.retrieve("sotype_123")
     * .then(({ shipping_option_type }) => {
     *   console.log(shipping_option_type)
     * })
     * ```
     *
     * To specify the fields and relations to retrieve:
     *
     * ```ts
     * sdk.admin.shippingOptionType.retrieve("sotype_123", {
     *   fields: "id,*shippingOptions"
     * })
     * .then(({ shipping_option_type }) => {
     *   console.log(shipping_option_type)
     * })
     * ```
     *
     * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
     */ retrieve(id, query, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/shipping-option-types/${id}`, {
                query,
                headers
            });
        });
    }
    /**
     * This method deletes a shipping option type. It sends a request to the
     * [Delete Shipping Option Type](https://docs.medusajs.com/api/admin#shipping-option-types_deleteshippingoptiontypesid)
     * API route.
     *
     * @param id - The shipping option type's ID.
     * @param headers - Headers to pass in the request
     * @returns The shipping option type's details.
     *
     * @example
     * sdk.admin.shippingOptionType.delete("sotype_123")
     * .then(({ deleted }) => {
     *   console.log(deleted)
     * })
     */ delete(id, headers) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.fetch(`/admin/shipping-option-types/${id}`, {
                method: "DELETE",
                headers
            });
        });
    }
} //# sourceMappingURL=shipping-option-type.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Admin",
    ()=>Admin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$api$2d$key$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/api-key.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$campaign$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/campaign.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$claim$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/claim.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$currency$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/currency.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$customer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/customer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$customer$2d$group$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/customer-group.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$draft$2d$order$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/draft-order.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$exchange$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/exchange.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2d$provider$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-provider.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2d$set$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-set.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$inventory$2d$item$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/inventory-item.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$invite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/invite.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$notification$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/notification.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$order$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/order.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$order$2d$edit$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/order-edit.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$payment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/payment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$payment$2d$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/payment-collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$plugin$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/plugin.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$price$2d$list$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/price-list.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$price$2d$preference$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/price-preference.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$category$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-category.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$tag$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-tag.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-type.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$variant$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/product-variant.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$promotion$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/promotion.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$refund$2d$reasons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/refund-reasons.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$region$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/region.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$reservation$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/reservation.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$return$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/return.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$return$2d$reason$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/return-reason.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$sales$2d$channel$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/sales-channel.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$option$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-option.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$profile$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-profile.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$stock$2d$location$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/stock-location.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$provider$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-provider.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$rate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-rate.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$region$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/tax-region.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$upload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/upload.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$user$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/user.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$workflow$2d$execution$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/workflow-execution.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$option$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-option-type.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class Admin {
    constructor(client){
        this.invite = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$invite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Invite"](client);
        this.customer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$customer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Customer"](client);
        this.productCollection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ProductCollection"](client);
        this.productCategory = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$category$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ProductCategory"](client);
        this.priceList = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$price$2d$list$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PriceList"](client);
        this.pricePreference = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$price$2d$preference$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PricePreference"](client);
        this.product = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Product"](client);
        this.productType = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ProductType"](client);
        this.upload = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$upload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Upload"](client);
        this.region = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$region$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Region"](client);
        this.returnReason = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$return$2d$reason$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReturnReason"](client);
        this.stockLocation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$stock$2d$location$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StockLocation"](client);
        this.salesChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$sales$2d$channel$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SalesChannel"](client);
        this.fulfillmentSet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2d$set$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FulfillmentSet"](client);
        this.fulfillment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Fulfillment"](client);
        this.fulfillmentProvider = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$fulfillment$2d$provider$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FulfillmentProvider"](client);
        this.shippingOption = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$option$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ShippingOption"](client);
        this.shippingOptionType = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$option$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ShippingOptionType"](client);
        this.shippingProfile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$shipping$2d$profile$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ShippingProfile"](client);
        this.inventoryItem = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$inventory$2d$item$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InventoryItem"](client);
        this.notification = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$notification$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Notification"](client);
        this.order = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$order$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Order"](client);
        this.draftOrder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$draft$2d$order$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DraftOrder"](client);
        this.orderEdit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$order$2d$edit$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OrderEdit"](client);
        this.return = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$return$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Return"](client);
        this.claim = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$claim$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Claim"](client);
        this.taxRate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$rate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TaxRate"](client);
        this.taxRegion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$region$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TaxRegion"](client);
        this.store = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Store"](client);
        this.productTag = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$tag$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ProductTag"](client);
        this.user = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$user$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["User"](client);
        this.currency = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$currency$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Currency"](client);
        this.payment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$payment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Payment"](client);
        this.productVariant = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$product$2d$variant$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ProductVariant"](client);
        this.refundReason = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$refund$2d$reasons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RefundReason"](client);
        this.exchange = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$exchange$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Exchange"](client);
        this.paymentCollection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$payment$2d$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PaymentCollection"](client);
        this.apiKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$api$2d$key$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ApiKey"](client);
        this.workflowExecution = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$workflow$2d$execution$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["WorkflowExecution"](client);
        this.reservation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$reservation$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"](client);
        this.customerGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$customer$2d$group$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CustomerGroup"](client);
        this.promotion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$promotion$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Promotion"](client);
        this.campaign = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$campaign$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Campaign"](client);
        this.plugin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$plugin$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Plugin"](client);
        this.taxProvider = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$tax$2d$provider$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TaxProvider"](client);
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/auth/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Auth",
    ()=>Auth
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Auth {
    constructor(client, config){
        /**
         * This method is used to retrieve a registration JWT token for a user, customer, or custom actor type. It sends a request to the
         * [Retrieve Registration Token API route](https://docs.medusajs.com/api/store#auth_postactor_typeauth_provider_register).
         *
         * Then, it stores the returned token and passes it in the header of subsequent requests. So, you can call the
         * [store.customer.create](https://docs.medusajs.com/resources/references/js-sdk/store/customer#create) method,
         * for example, after calling this method.
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * @param actor - The actor type. For example, `user` for admin user, or `customer` for customer.
         * @param method - The authentication provider to use. For example, `emailpass` or `google`.
         * @param payload - The data to pass in the request's body for authentication. When using the `emailpass` provider,
         * you pass the email and password.
         * @returns The JWT token used for registration later.
         *
         * @tags auth
         *
         * @example
         * await sdk.auth.register(
         *   "customer",
         *   "emailpass",
         *   {
         *     email: "customer@gmail.com",
         *     password: "supersecret"
         *   }
         * )
         *
         * // all subsequent requests will use the token in the header
         * const { customer } = await sdk.store.customer.create({
         *   email: "customer@gmail.com",
         *   password: "supersecret"
         * })
         */ this.register = (actor, method, payload)=>__awaiter(this, void 0, void 0, function*() {
                const { token } = yield this.client.fetch(`/auth/${actor}/${method}/register`, {
                    method: "POST",
                    body: payload
                });
                this.client.setToken(token);
                return token;
            });
        /**
         * This method retrieves the JWT authenticated token for an admin user, customer, or custom
         * actor type. It sends a request to the [Authenticate API Route](https://docs.medusajs.com/api/admin#auth_postactor_typeauth_provider).
         *
         * ### Third-Party Authentication
         *
         * If the API route returns a `location` property, it means that the authentication requires additional steps,
         * typically in a third-party service. The `location` property is returned so that you
         * can redirect the user to the appropriate page.
         *
         * :::note
         *
         * For an example of implementing third-party authentication, refer to the
         * [Third-Party Login in Storefront](https://docs.medusajs.com/resources/storefront-development/customers/third-party-login) guide.
         *
         * :::
         *
         * ### Session Authentication
         *
         * If the `auth.type` of the SDK is set to `session`, this method will also send a request to the
         * [Set Authentication Session API route](https://docs.medusajs.com/api/admin#auth_postsession).
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * ### Automatic Authentication
         *
         * If the authentication was successful, subsequent requests using the SDK will automatically have the necessary authentication headers / session
         * set, based on your JS SDK authentication configurations.
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * @param actor - The actor type. For example, `user` for admin user, or `customer` for customer.
         * @param method - The authentication provider to use. For example, `emailpass` or `google`.
         * @param payload - The data to pass in the request's body for authentication. When using the `emailpass` provider,
         * you pass the email and password.
         * @returns The authentication JWT token
         *
         * @tags auth
         *
         * @example
         * const result = await sdk.auth.login(
         *   "customer",
         *   "emailpass",
         *   {
         *     email: "customer@gmail.com",
         *     password: "supersecret"
         *   }
         * )
         *
         * if (typeof result !== "string") {
         *   alert("Authentication requires additional steps")
         *   // replace with the redirect logic of your application
         *   window.location.href = result.location
         *   return
         * }
         *
         * // customer is now authenticated
         * // all subsequent requests will use the token in the header
         * const { customer } = await sdk.store.customer.retrieve()
         */ this.login = (actor, method, payload)=>__awaiter(this, void 0, void 0, function*() {
                // There will either be token or location returned from the backend.
                const { token, location } = yield this.client.fetch(`/auth/${actor}/${method}`, {
                    method: "POST",
                    body: payload
                });
                // In the case of an oauth login, we return the redirect location to the caller.
                // They can decide if they do an immediate redirect or put it in an <a> tag.
                if (location) {
                    return {
                        location
                    };
                }
                yield this.setToken_(token);
                return token;
            });
        /**
         * This method is used to validate an Oauth callback from a third-party service, such as Google, for an admin user, customer, or custom actor types.
         * It sends a request to the [Validate Authentication Callback](https://docs.medusajs.com/api/admin#auth_postactor_typeauth_providercallback).
         *
         * The method stores the returned token and passes it in the header of subsequent requests. So, you can call the
         * [store.customer.create](https://docs.medusajs.com/resources/references/js-sdk/store/customer#create) or {@link refresh} methods,
         * for example, after calling this method.
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * @param actor - The actor type. For example, `user` for admin user, or `customer` for customer.
         * @param method - The authentication provider to use. For example, `google`.
         * @param query - The query parameters from the Oauth callback, which should be passed to the API route. This includes query parameters like
         * `code` and `state`.
         * @returns The authentication JWT token
         *
         * @tags auth
         *
         * @example
         * await sdk.auth.callback(
         *   "customer",
         *   "google",
         *   {
         *     code: "123",
         *     state: "456"
         *   }
         * )
         *
         * // all subsequent requests will use the token in the header
         * const { customer } = await sdk.store.customer.create({
         *   email: "customer@gmail.com",
         *   password: "supersecret"
         * })
         *
         * @privateRemarks
         * The callback expects all query parameters from the Oauth callback to be passed to
         * the backend, and the provider is in charge of parsing and validating them
         */ this.callback = (actor, method, query)=>__awaiter(this, void 0, void 0, function*() {
                const { token } = yield this.client.fetch(`/auth/${actor}/${method}/callback`, {
                    method: "GET",
                    query
                });
                yield this.setToken_(token);
                return token;
            });
        /**
         * This method refreshes a JWT authentication token, which is useful after validating the Oauth callback
         * with {@link callback}. It sends a request to the [Refresh Authentication Token API route](https://docs.medusajs.com/api/admin#auth_postadminauthtokenrefresh).
         *
         * The method stores the returned token and passes it in the header of subsequent requests. So, you can call other
         * methods that require authentication after calling this method.
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * For an example of implementing third-party authentication, refer to the
         * [Third-Party Login in Storefront](https://docs.medusajs.com/resources/storefront-development/customers/third-party-login) guide.
         *
         *
         * @returns The refreshed JWT authentication token.
         *
         * @tags auth
         *
         * @example
         * const token = await sdk.auth.refresh()
         *
         * // all subsequent requests will use the token in the header
         * const { customer } = await sdk.store.customer.retrieve()
         */ this.refresh = ()=>__awaiter(this, void 0, void 0, function*() {
                const { token } = yield this.client.fetch("/auth/token/refresh", {
                    method: "POST"
                });
                // Putting the token in session after refreshing is only useful when the new token has updated info (eg. actor_id).
                // Ideally we don't use the full JWT in session as key, but just store a pseudorandom key that keeps the rest of the auth context as value.
                yield this.setToken_(token);
                return token;
            });
        /**
         * This method logs out the currently authenticated user based on your JS SDK authentication configurations.
         *
         * If the `auth.type` of the SDK is set to `session`, this method will also send a request to the
         * [Delete Authentication Session API route](https://docs.medusajs.com/api/admin#auth_deletesession).
         *
         * The method also clears any stored tokens or sessions, based on your JS SDK authentication configurations.
         *
         * Learn more in the [JS SDK Authentication](https://docs.medusajs.com/resources/js-sdk/auth/overview) guide.
         *
         * @tags auth
         *
         * @example
         * await sdk.auth.logout()
         *
         * // user is now logged out
         * // you can't send any requests that require authentication
         */ this.logout = ()=>__awaiter(this, void 0, void 0, function*() {
                var _a, _b;
                if (((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.type) === "session") {
                    yield this.client.fetch("/auth/session", {
                        method: "DELETE"
                    });
                }
                this.client.clearToken();
            });
        /**
         * This method requests a reset password token for an admin user, customer, or custom actor type.
         * It sends a request to the [Generate Reset Password Token API route](https://docs.medusajs.com/api/admin#auth_postactor_typeauth_providerresetpassword).
         *
         * To reset the password later using the token delivered to the user, use the {@link updateProvider} method.
         *
         * Related guide: [How to allow customers to reset their passwords in a storefront](https://docs.medusajs.com/resources/storefront-development/customers/reset-password).
         *
         * @param actor - The actor type. For example, `user` for admin user, or `customer` for customer.
         * @param provider - The authentication provider to use. For example, `emailpass`.
         * @param body - The data required to identify the user.
         *
         * @tags auth
         *
         * @example
         * sdk.auth.resetPassword(
         *   "customer",
         *   "emailpass",
         *   {
         *     identifier: "customer@gmail.com"
         *   }
         * )
         * .then(() => {
         *   // user receives token
         * })
         */ this.resetPassword = (actor, provider, body)=>__awaiter(this, void 0, void 0, function*() {
                yield this.client.fetch(`/auth/${actor}/${provider}/reset-password`, {
                    method: "POST",
                    body,
                    headers: {
                        accept: "text/plain"
                    }
                });
            });
        /**
         * This method is used to update user-related data authentication data.
         *
         * More specifically, use this method when updating the password of an admin user, customer, or
         * custom actor type after requesting to reset their password with {@link resetPassword}.
         *
         * This method sends a request to [this API route](https://docs.medusajs.com/api/admin#auth_postactor_typeauth_providerupdate).
         *
         * Related guide: [How to allow customers to reset their passwords in a storefront](https://docs.medusajs.com/resources/storefront-development/customers/reset-password).
         *
         * @param actor - The actor type. For example, `user` for admin user, or `customer` for customer.
         * @param provider - The authentication provider to use. For example, `emailpass`.
         * @param body - The data necessary to update the user's authentication data. When resetting the user's password,
         * send the `password` property.
         *
         * @tags auth
         *
         * @example
         * sdk.auth.updateProvider(
         *   "customer",
         *   "emailpass",
         *   {
         *     password: "supersecret"
         *   },
         *   token
         * )
         * .then(() => {
         *   // password updated
         * })
         */ this.updateProvider = (actor, provider, body, token)=>__awaiter(this, void 0, void 0, function*() {
                yield this.client.fetch(`/auth/${actor}/${provider}/update`, {
                    method: "POST",
                    body,
                    headers: {
                        Authorization: `Bearer ${token}`
                    }
                });
            });
        /**
         * @ignore
         */ this.setToken_ = (token)=>__awaiter(this, void 0, void 0, function*() {
                var _a, _b;
                // By default we just set the token in the configured storage, if configured to use sessions we convert it into session storage instead.
                if (((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.type) === "session") {
                    yield this.client.fetch("/auth/session", {
                        method: "POST",
                        headers: {
                            Authorization: `Bearer ${token}`
                        }
                    });
                } else {
                    this.client.setToken(token);
                }
            });
        this.client = client;
        this.config = config;
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/store/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Store",
    ()=>Store
]);
var __awaiter = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Store {
    /**
     * @ignore
     */ constructor(client){
        /**
         * @tags region
         */ this.region = {
            /**
             * This method retrieves the paginated list of regions in the store. It sends a request to the
             * [List Regions API route](https://docs.medusajs.com/api/store#regions_getregions).
             *
             * Related guide: [How to list regions in a storefront](https://docs.medusajs.com/resources/storefront-development/regions/list).
             *
             * @param query - Filters and pagination configurations.
             * @param headers - Headers to pass in the request
             * @returns The paginated list of regions.
             *
             * @example
             * To retrieve the list of regions:
             *
             * ```ts
             * sdk.store.region.list()
             * .then(({ regions, count, limit, offset }) => {
             *   console.log(regions)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.region.list({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ regions, count, limit, offset }) => {
             *   console.log(regions)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each region:
             *
             * ```ts
             * sdk.store.region.list({
             *   fields: "id,*countries"
             * })
             * .then(({ regions, count, limit, offset }) => {
             *   console.log(regions)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ list: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/regions`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method retrieves a region by its ID. It sends a request to the [Get Region](https://docs.medusajs.com/api/store#regions_getregionsid)
             * API route.
             *
             * Related guide: [Store and retrieve regions in a storefront](https://docs.medusajs.com/resources/storefront-development/regions/store-retrieve-region).
             *
             * @param id - The region's ID.
             * @param query - Configure the fields to retrieve in the region.
             * @param headers - Headers to pass in the request
             * @returns The region.
             *
             * @example
             * To retrieve a region by its ID:
             *
             * ```ts
             * sdk.store.region.retrieve("reg_123")
             * .then(({ region }) => {
             *   console.log(region)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.region.retrieve(
             *   "reg_123",
             *   {
             *     fields: "id,*countries"
             *   }
             * )
             * .then(({ region }) => {
             *   console.log(region)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/regions/${id}`, {
                        query,
                        headers
                    });
                })
        };
        /**
         * @tags product
         */ this.collection = {
            /**
             * This method retrieves a paginated list of product collections. It sends a request to the
             * [List Collections](https://docs.medusajs.com/api/store#collections_getcollections) API route.
             *
             * Related guide: [How to retrieve collections in a storefront](https://docs.medusajs.com/resources/storefront-development/products/collections/list).
             *
             * @param query - Filters and pagination configurations.
             * @param headers - Headers to pass in the request
             * @returns The paginated list of collections.
             *
             * @example
             * To retrieve the list of collections:
             *
             * ```ts
             * sdk.store.collection.list()
             * .then(({ collections, count, limit, offset }) => {
             *   console.log(collections)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.collection.list({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ collections, count, limit, offset }) => {
             *   console.log(collections)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each collection:
             *
             * ```ts
             * sdk.store.collection.list({
             *   fields: "id,handle"
             * })
             * .then(({ collections, count, limit, offset }) => {
             *   console.log(collections)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ list: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/collections`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method retrieves a collection by its ID. It sends a request to the [Get Collection](https://docs.medusajs.com/api/store#collections_getcollectionsid)
             * API route.
             *
             * Related guide: [How to retrieve a collection in a storefront](https://docs.medusajs.com/resources/storefront-development/products/collections/retrieve).
             *
             * @param id - The ID of the collection to retrieve.
             * @param query - Configure the fields to retrieve in the collection.
             * @param headers - Headers to pass in the request
             * @returns The collection.
             *
             * @example
             * To retrieve a collection by its ID:
             *
             * ```ts
             * sdk.store.collection.retrieve("pcol_123")
             * .then(({ collection }) => {
             *   console.log(collection)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.collection.retrieve("pcol_123", {
             *   fields: "id,handle"
             * })
             * .then(({ collection }) => {
             *   console.log(collection)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/collections/${id}`, {
                        query,
                        headers
                    });
                })
        };
        /**
         * @tags product
         */ this.category = {
            /**
             * This method retrieves a paginated list of product categories. It sends a request to the
             * [List Categories](https://docs.medusajs.com/api/store#product-categories_getproductcategories) API route.
             *
             * Related guide: [How to retrieve list of categories in the storefront](https://docs.medusajs.com/resources/storefront-development/products/categories/list).
             *
             * @param query - Filters and pagination configurations.
             * @param headers - Headers to pass in the request.
             * @returns The paginated list of categories.
             *
             * @example
             * To retrieve the list of categories:
             *
             * ```ts
             * sdk.store.category.list()
             * .then(({ product_categories, count, offset, limit }) => {
             *   console.log(product_categories)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.category.list({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ product_categories, count, offset, limit }) => {
             *   console.log(product_categories)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each category:
             *
             * ```ts
             * sdk.store.category.list({
             *   fields: "id,*parent_category"
             * })
             * .then(({ product_categories, count, offset, limit }) => {
             *   console.log(product_categories)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ list: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/product-categories`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method retrieves a category by its ID. It sends a request to the
             * [Retrieve Product Category](https://docs.medusajs.com/api/store#product-categories_getproductcategoriesid).
             *
             * Related guide: [How to retrieve a category in the storefront](https://docs.medusajs.com/resources/storefront-development/products/categories/retrieve).
             *
             * @param id - The ID of the category to retrieve.
             * @param query - Configure the fields to retrieve in the category.
             * @param headers - Headers to pass in the request
             * @returns The category.
             *
             * @example
             * To retrieve a category by its ID:
             *
             * ```ts
             * sdk.store.category.retrieve("pcat_123")
             * .then(({ product_category }) => {
             *   console.log(product_category)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.category.retrieve("pcat_123", {
             *   fields: "id,*parent_category"
             * })
             * .then(({ product_category }) => {
             *   console.log(product_category)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/product-categories/${id}`, {
                        query,
                        headers
                    });
                })
        };
        /**
         * @tags product
         */ this.product = {
            /**
             * This method retrieves a list of products. It sends a request to the
             * [List Products API route](https://docs.medusajs.com/api/store#products_getproducts).
             *
             * Related guides:
             *
             * - [How to list products in a storefront](https://docs.medusajs.com/resources/storefront-development/products/list).
             * - [How to retrieve a product variant's prices in the storefront](https://docs.medusajs.com/resources/storefront-development/products/price)
             *
             * @param query - Filters and pagination configurations.
             * @param headers - Headers to pass in the request.
             * @returns The paginated list of products.
             *
             * @example
             * To retrieve the list of products:
             *
             * ```ts
             * sdk.store.product.list()
             * .then(({ products, count, offset, limit }) => {
             *   console.log(products)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.product.list({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ products, count, offset, limit }) => {
             *   console.log(products)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each product:
             *
             * ```ts
             * sdk.store.product.list({
             *   fields: "id,*collection"
             * })
             * .then(({ products, count, offset, limit }) => {
             *   console.log(products)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ list: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/products`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method is used to retrieve a product by its ID. It sends a request to the
             * [Get Product](https://docs.medusajs.com/api/store#products_getproductsid) API route.
             *
             * Related guides:
             *
             * - [How to retrieve a product in the storefront](https://docs.medusajs.com/resources/storefront-development/products/retrieve).
             * - [How to retrieve a product variant's prices in the storefront](https://docs.medusajs.com/resources/storefront-development/products/price)
             *
             * @param id - The product's ID.
             * @param query - Configure the fields to retrieve in the product.
             * @param headers - Headers to pass in the request
             * @returns The product.
             *
             * @example
             * To retrieve a product by its ID:
             *
             * ```ts
             * sdk.store.product.retrieve("prod_123")
             * .then(({ product }) => {
             *   console.log(product)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.product.retrieve("prod_123", {
             *   fields: "id,*collection"
             * })
             * .then(({ product }) => {
             *   console.log(product)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/products/${id}`, {
                        query,
                        headers
                    });
                })
        };
        /**
         * Related guides: [How to implement carts in the storefront](https://docs.medusajs.com/resources/storefront-development/cart).
         *
         * @tags cart
         */ this.cart = {
            /**
             * This method creates a cart. It sends a request to the [Create Cart](https://docs.medusajs.com/api/store#carts_postcarts)
             * API route.
             *
             * Related guide: [How to create a cart in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/create).
             *
             * @param body - The details of the cart to create.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The created cart.
             *
             * @example
             * sdk.store.cart.create({
             *   region_id: "reg_123"
             * })
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ create: (body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method updates a cart. It sends a request to the
             * [Update Cart](https://docs.medusajs.com/api/store#carts_postcartsid) API route.
             *
             * Related guide: [How to update a cart in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/update).
             *
             * @param id - The cart's ID.
             * @param body - The data to update in the cart.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The updated cart.
             *
             * @example
             * sdk.store.cart.update("cart_123", {
             *   region_id: "reg_123"
             * })
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ update: (id, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${id}`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method retrieves a cart by its ID. It sends a request to the
             * [Get Cart](https://docs.medusajs.com/api/store#carts_getcartsid) API route.
             *
             * Related guide: [How to retrieve a cart in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/retrieve).
             *
             * @param id - The cart's ID.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The cart's details.
             *
             * @example
             * To retrieve a cart by its ID:
             *
             * ```ts
             * sdk.store.cart.retrieve("cart_123")
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.cart.retrieve("cart_123", {
             *   fields: "id,*items"
             * })
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${id}`, {
                        headers,
                        query
                    });
                }),
            /**
             * This methods adds a product variant to the cart as a line item. It sends a request to the
             * [Add Line Item](https://docs.medusajs.com/api/store#carts_postcartsidlineitems) API route.
             *
             * Related guide: [How to manage a cart's line items in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/manage-items).
             *
             * @param cartId - The cart's ID.
             * @param body - The details of the item to add.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The cart's details.
             *
             * @example
             * sdk.store.cart.createLineItem("cart_123", {
             *   variant_id: "variant_123",
             *   quantity: 1
             * })
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ createLineItem: (cartId, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${cartId}/line-items`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method updates a line item in a cart. It sends a request to the
             * [Update Line Item](https://docs.medusajs.com/api/store#carts_postcartsidlineitemsline_id) API route.
             *
             * Related guide: [How to manage a cart's line items in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/manage-items).
             *
             * @param cartId - The cart's ID.
             * @param lineItemId - The line item's ID.
             * @param body - The data to update.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The cart's details.
             *
             * @example
             * sdk.store.cart.updateLineItem(
             *   "cart_123",
             *   "li_123",
             *   {
             *     quantity: 1
             *   }
             * )
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ updateLineItem: (cartId, lineItemId, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${cartId}/line-items/${lineItemId}`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method deletes a line item from a cart. It sends a request to the
             * [Remove Line Item](https://docs.medusajs.com/api/store#carts_deletecartsidlineitemsline_id) API route.
             *
             * Related guide: [How to manage a cart's line items in the storefront](https://docs.medusajs.com/resources/storefront-development/cart/manage-items).
             *
             * @param cartId - The cart's ID.
             * @param lineItemId - The item's ID.
             * @param headers - Headers to pass in the request.
             * @returns The deletion's details.
             *
             * @example
             * sdk.store.cart.deleteLineItem(
             *   "cart_123",
             *   "li_123"
             * )
             * .then(({ deleted, parent: cart }) => {
             *   console.log(deleted, cart)
             * })
             */ deleteLineItem: (cartId, lineItemId, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${cartId}/line-items/${lineItemId}`, {
                        method: "DELETE",
                        headers
                    });
                }),
            /**
             * This method adds a shipping method to a cart. It sends a request to
             * the [Add Shipping Method](https://docs.medusajs.com/api/store#carts_postcartsidshippingmethods) API routes.
             *
             * Related guide: [Implement shipping step during checkout](https://docs.medusajs.com/resources/storefront-development/checkout/shipping).
             *
             * @param cartId - The cart's ID.
             * @param body - The shipping method's details.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The cart's details.
             *
             * @example
             * sdk.store.cart.addShippingMethod("cart_123", {
             *   option_id: "so_123",
             *   data: {
             *     // custom data for fulfillment provider.
             *   }
             * })
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ addShippingMethod: (cartId, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${cartId}/shipping-methods`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method completes a cart and places the order. It's the last step of the checkout flow.
             * The method sends a request to the [Complete Cart](https://docs.medusajs.com/api/store#carts_postcartsidcomplete)
             * API route.
             *
             * Related guide: [Learn how to complete cart in checkout flow](https://docs.medusajs.com/resources/storefront-development/checkout/complete-cart).
             *
             * @param cartId - The cart's ID.
             * @param query - Configure the fields to retrieve in the created order.
             * @param headers - Headers to pass in the request.
             * @returns The order's details, if it was placed successfully. Otherwise, the cart is returned with an error.
             *
             * @example
             * sdk.store.cart.complete("cart_123")
             * .then((data) => {
             *   if(data.type === "cart") {
             *     // an error occurred
             *     console.log(data.error, data.cart)
             *   } else {
             *     // order placed successfully
             *     console.log(data.order)
             *   }
             * })
             */ complete: (cartId, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${cartId}/complete`, {
                        method: "POST",
                        headers,
                        query
                    });
                }),
            /**
             * This method updates the customer of a cart.
             *
             * @param id - The cart's ID.
             * @param query - Configure the fields to retrieve in the cart.
             * @param headers - Headers to pass in the request.
             * @returns The updated cart.
             *
             * @example
             * sdk.store.cart.transferCart("cart_123")
             * .then(({ cart }) => {
             *   console.log(cart)
             * })
             */ transferCart: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/carts/${id}/customer`, {
                        method: "POST",
                        headers,
                        query
                    });
                })
        };
        /**
         * @tags fulfillment
         */ this.fulfillment = {
            /**
             * This method retrieves the list of shipping options for a cart. It sends a request to
             * the [List Shipping Options](https://docs.medusajs.com/api/store#shipping-options_getshippingoptions)
             * API route.
             *
             * Related guide: [Implement shipping step during checkout](https://docs.medusajs.com/resources/storefront-development/checkout/shipping).
             *
             * @param query - The cart's details along with configurations of the fields to retrieve in the options.
             * @param headers - Headers to pass in the request.
             * @returns The shipping options that can be used for the cart.
             *
             * @example
             * sdk.store.fulfillment.listCartOptions({
             *   cart_id: "cart_123"
             * })
             * .then(({ shipping_options }) => {
             *   console.log(shipping_options)
             * })
             */ listCartOptions: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/shipping-options`, {
                        headers,
                        query
                    });
                }),
            /**
             * This method calculates the price of a shipping option in a cart, which is useful during checkout.
             * It sends a request to the [Calculate Shipping Option Price](https://docs.medusajs.com/api/store#shipping-options_postshippingoptionsidcalculate)
             * API route.
             *
             * @param id - The shipping option's ID.
             * @param body - The price calculation's details.
             * @param query - Configure the fields to retrieve in the shipping option.
             * @param headers - Headers to pass in the request.
             * @returns The shipping option's details.
             *
             * @example
             * sdk.store.fulfillment.calculate("so_123", {
             *   cart_id: "cart_123"
             * })
             * .then(({ shipping_option }) => {
             *   console.log(shipping_option)
             * })
             */ calculate: (id, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return yield this.client.fetch(`/store/shipping-options/${id}/calculate`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                })
        };
        /**
         * @tags payment
         */ this.payment = {
            /**
             * This method retrieves the payment providers available in a region, which is useful during checkout.
             * It sends a request to the [List Payment Providers](https://docs.medusajs.com/api/store#payment-providers_getpaymentproviders)
             * API route.
             *
             * Related guide: [Implement payment step during checkout](https://docs.medusajs.com/resources/storefront-development/checkout/payment).
             *
             * @param query - The filters to apply on the retrieved providers, along with configurations of the
             * fields to retrieve in the options.
             * @param headers - Headers to pass in the request.
             * @returns The list of payment providers.
             *
             * @example
             * To retrieve the list of payment providers for a region:
             *
             * ```ts
             * sdk.store.payment.listPaymentProviders({
             *   region_id: "reg_123"
             * })
             * .then(({ payment_providers, count, offset, limit }) => {
             *   console.log(payment_providers)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.payment.listPaymentProviders({
             *   region_id: "reg_123",
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ payment_providers, count, offset, limit }) => {
             *   console.log(payment_providers)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each provider:
             *
             * ```ts
             * sdk.store.payment.listPaymentProviders({
             *   region_id: "reg_123",
             *   limit: 10,
             *   offset: 10,
             *   fields: "id"
             * })
             * .then(({ payment_providers, count, offset, limit }) => {
             *   console.log(payment_providers)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ listPaymentProviders: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/payment-providers`, {
                        headers,
                        query
                    });
                }),
            /**
             * This method creates a payment session of a cart's payment collection, selecting a payment provider.
             * It sends a request to the [Initialize Payment Session](https://docs.medusajs.com/api/store#payment-collections_postpaymentcollectionsidpaymentsessions)
             * API route.
             *
             * If the cart doesn't have a payment collection, a payment collection is created for the cart by
             * sending a request to the [Create Payment Collection](https://docs.medusajs.com/api/store#payment-collections_postpaymentcollections)
             * API route.
             *
             * Related guide: [Implement payment step during checkout](https://docs.medusajs.com/resources/storefront-development/checkout/payment).
             *
             * @param cart - The cart's details.
             * @param body - The payment session's details.
             * @param query - Configure the fields to retrieve in the payment collection.
             * @param headers - Headers to pass in the request.
             * @returns The payment collection's details.
             *
             * @example
             * sdk.store.payment.initiatePaymentSession(
             *   cart, // assuming you already have the cart object.
             *   {
             *     provider_id: "pp_stripe_stripe",
             *     data: {
             *       // any data relevant for the provider.
             *     }
             *   }
             * )
             * .then(({ payment_collection }) => {
             *   console.log(payment_collection)
             * })
             */ initiatePaymentSession: (cart, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    var _a;
                    let paymentCollectionId = (_a = cart.payment_collection) === null || _a === void 0 ? void 0 : _a.id;
                    if (!paymentCollectionId) {
                        const collectionBody = {
                            cart_id: cart.id
                        };
                        paymentCollectionId = (yield this.client.fetch(`/store/payment-collections`, {
                            method: "POST",
                            headers,
                            body: collectionBody
                        })).payment_collection.id;
                    }
                    return this.client.fetch(`/store/payment-collections/${paymentCollectionId}/payment-sessions`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                })
        };
        /**
         * @tags order
         */ this.order = {
            /**
             * This method retrieves a paginated list of orders matching the specified filters. It
             * sends a request to the [List Orders](https://docs.medusajs.com/api/store#orders_getorders)
             * API route.
             *
             * @param query - Configure the fields to retrieve in the orders.
             * @param headers - Headers to pass in the request.
             * @returns The paginated list of orders.
             *
             * @example
             * To retrieve the list of orders:
             *
             * ```ts
             * sdk.store.order.list()
             * .then(({ orders, count, offset, limit }) => {
             *   console.log(orders)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.order.list({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ orders, count, offset, limit }) => {
             *   console.log(orders)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each order:
             *
             * ```ts
             * sdk.store.order.list({
             *   fields: "id,*items"
             * })
             * .then(({ orders, count, offset, limit }) => {
             *   console.log(orders)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ list: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method retrieves an order by its ID. It sends a request to the
             * [Get Order](https://docs.medusajs.com/api/store#orders_getordersid) API route.
             *
             * @param id - The order's ID.
             * @param query - Configure the fields to retrieve in the order.
             * @param headers - Headers to pass in the request.
             * @returns The order's details.
             *
             * @example
             * To retrieve an order by its ID:
             *
             * ```ts
             * sdk.store.order.retrieve("order_123")
             * .then(({ order }) => {
             *   console.log(order)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.order.retrieve("order_123", {
             *   fields: "id,*items"
             * })
             * .then(({ order }) => {
             *   console.log(order)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieve: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders/${id}`, {
                        headers,
                        query
                    });
                }),
            /**
             * This method requests a order transfer from a guest account to the current, logged in customer account.
             *
             * Customer requesting the transfer must be logged in.
             *
             * @param body - The transfer's details.
             * @param query - Configure the fields to retrieve in the order.
             * @param headers - Headers to pass in the request.
             * @returns The order details.
             *
             * @example
             * sdk.store.order.requestTransfer(
             *   "order_123",
             *   {
             *     description: "I want to transfer this order to my friend."
             *   },
             *   {},
             *   {
             *     Authorization: `Bearer ${token}`
             *   }
             * )
             * .then(({ order }) => {
             *   console.log(order)
             * })
             */ requestTransfer: (id, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders/${id}/transfer/request`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method cancels an order transfer request.
             *
             * Customer requesting the transfer must be logged in.
             *
             * @param id - The order's ID.
             * @param query - Configure the fields to retrieve in the order.
             * @param headers - Headers to pass in the request.
             * @returns The order details.
             *
             * @example
             * sdk.store.order.cancelTransfer(
             *   "order_123",
             *   {},
             *   {
             *     Authorization: `Bearer ${token}`
             *   }
             * )
             * .then(({ order }) => {
             *   console.log(order)
             * })
             */ cancelTransfer: (id, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders/${id}/transfer/cancel`, {
                        method: "POST",
                        headers,
                        query
                    });
                }),
            /**
             * The method called for the original owner to accept the order transfer to a new owner.
             *
             * @param id - The order's ID.
             * @param body - The payload containing the transfer token.
             * @param query - Configure the fields to retrieve in the order.
             * @param headers - Headers to pass in the request.
             * @returns The order details.
             *
             * @example
             * sdk.store.order.acceptTransfer(
             *   "order_123",
             *   {
             *     token: "transfer_token"
             *   },
             *   {
             *     Authorization: `Bearer ${token}`
             *   }
             * )
             * .then(({ order }) => {
             *   console.log(order)
             * })
             */ acceptTransfer: (id, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders/${id}/transfer/accept`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * The method called for the original owner to decline the order transfer to a new owner.
             *
             * @param id - The order's ID.
             * @param body - The payload containing the transfer token.
             * @param query - Configure the fields to retrieve in the order.
             * @param headers - Headers to pass in the request.
             * @returns The order details.
             *
             * @example
             * sdk.store.order.declineTransfer(
             *   "order_123",
             *   {
             *     token: "transfer_token"
             *   },
             *   {
             *     Authorization: `Bearer ${token}`
             *   }
             * )
             * .then(({ order }) => {
             *   console.log(order)
             * })
             */ declineTransfer: (id, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/orders/${id}/transfer/decline`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                })
        };
        /**
         * @tags customer
         */ this.customer = {
            /**
             * This method registers a customer. It sends a request to the [Register Customer](https://docs.medusajs.com/api/store#customers_postcustomers)
             * API route.
             *
             * You must use the {@link Auth.register} method first to retrieve a registration token. Then, pass that
             * registration token in the `headers` parameter of this method as an authorization bearer header.
             *
             * Related guide: [How to register customer in storefront](https://docs.medusajs.com/resources/storefront-development/customers/register)
             *
             * @param body - The customer's details.
             * @param query - Configure the fields to retrieve in the customer.
             * @param headers - Headers to pass in the request. This is where you include the authorization JWT registration token.
             * @returns The customer's details.
             *
             * @example
             * const token = await sdk.auth.register("customer", "emailpass", {
             *   "email": "customer@gmail.com",
             *   "password": "supersecret"
             * })
             *
             * sdk.store.customer.create(
             *   {
             *     "email": "customer@gmail.com"
             *   },
             *   {},
             *   {
             *     Authorization: `Bearer ${token}`
             *   }
             * )
             * .then(({ customer }) => {
             *   console.log(customer)
             * })
             */ create: (body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method updates the logged-in customer's details. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the
             * [Update Customer](https://docs.medusajs.com/api/store#customers_postcustomersme) API route.
             *
             * Related guide: [How to edit customer's profile in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/profile).
             *
             * @param body - The customer's details to update.
             * @param query - Configure the fields to retrieve in the customer.
             * @param headers - Headers to pass in the request.
             * @returns The customer's details.
             *
             * @example
             * sdk.store.customer.update({
             *   first_name: "John"
             * })
             * .then(({ customer }) => {
             *   console.log(customer)
             * })
             */ update: (body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method retrieves the logged-in customer's details. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [Get Logged-In Customer](https://docs.medusajs.com/api/store#customers_getcustomersme)
             * API route.
             *
             * @param query - Configure the fields to retrieve in the customer.
             * @param headers - Headers to pass in the request.
             * @returns The customer's details.
             *
             * @example
             * sdk.store.customer.retrieve()
             * .then(({ customer }) => {
             *   console.log(customer)
             * })
             */ retrieve: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method creates an address for the logged-in customer. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [Create Address](https://docs.medusajs.com/api/store#customers_postcustomersmeaddresses)
             * API route.
             *
             * Related guides: [How to manage customer's addresses in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/addresses)
             *
             * @param body - The address's details.
             * @param query - Configure the fields to retrieve in the customer.
             * @param headers - Headers to pass in the request.
             * @returns The customer's details.
             *
             * @example
             * sdk.store.customer.createAddress({
             *   country_code: "us"
             * })
             * .then(({ customer }) => {
             *   console.log(customer)
             * })
             */ createAddress: (body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me/addresses`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method updates the address of the logged-in customer. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [Update Address](https://docs.medusajs.com/api/store#customers_postcustomersmeaddressesaddress_id)
             * API route.
             *
             * Related guides: [How to manage customer's addresses in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/addresses)
             *
             * @param addressId - The ID of the address to update.
             * @param body - The details to update in the address.
             * @param query - Configure the fields to retrieve in the customer.
             * @param headers - Headers to pass in the request.
             * @returns The customer's details.
             *
             * @example
             * sdk.store.customer.updateAddress(
             *   "caddr_123",
             *   {
             *     country_code: "us"
             *   }
             * )
             * .then(({ customer }) => {
             *   console.log(customer)
             * })
             */ updateAddress: (addressId, body, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
                        method: "POST",
                        headers,
                        body,
                        query
                    });
                }),
            /**
             * This method retrieves the logged-in customer's address. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [List Customer's Address](https://docs.medusajs.com/api/store#customers_getcustomersmeaddresses)
             * API route.
             *
             * Related guides: [How to manage customer's addresses in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/addresses)
             *
             * @param query - Configure the fields to retrieve in the addresses.
             * @param headers - Headers to pass in the request.
             * @returns The paginated list of addresses.
             *
             * @example
             * To retrieve the list of addresses:
             *
             * ```ts
             * sdk.store.customer.listAddress()
             * .then(({ addresses, count, offset, limit }) => {
             *   console.log(addresses)
             * })
             * ```
             *
             * To configure the pagination, pass the `limit` and `offset` query parameters.
             *
             * For example, to retrieve only 10 items and skip 10 items:
             *
             * ```ts
             * sdk.store.customer.listAddress({
             *   limit: 10,
             *   offset: 10
             * })
             * .then(({ addresses, count, offset, limit }) => {
             *   console.log(addresses)
             * })
             * ```
             *
             * Using the `fields` query parameter, you can specify the fields and relations to retrieve
             * in each address:
             *
             * ```ts
             * sdk.store.customer.listAddress({
             *   fields: "id,country_code"
             * })
             * .then(({ addresses, count, offset, limit }) => {
             *   console.log(addresses)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ listAddress: (query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me/addresses`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method retrieves an address of the logged-in customer. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [Get Address](https://docs.medusajs.com/api/store#customers_getcustomersmeaddressesaddress_id)
             * API route.
             *
             * Related guides: [How to manage customer's addresses in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/addresses)
             *
             * @param addressId - The address's ID.
             * @param query - Configure the fields to retrieve in the address.
             * @param headers - Headers to pass in the request.
             * @returns The address's details.
             *
             * @example
             * To retrieve an address by its ID:
             *
             * ```ts
             * sdk.store.customer.retrieveAddress(
             *   "caddr_123"
             * )
             * .then(({ address }) => {
             *   console.log(address)
             * })
             * ```
             *
             * To specify the fields and relations to retrieve:
             *
             * ```ts
             * sdk.store.customer.retrieveAddress(
             *   "caddr_123",
             *   {
             *     fields: "id,country_code"
             *   }
             * )
             * .then(({ address }) => {
             *   console.log(address)
             * })
             * ```
             *
             * Learn more about the `fields` property in the [API reference](https://docs.medusajs.com/api/store#select-fields-and-relations).
             */ retrieveAddress: (addressId, query, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
                        query,
                        headers
                    });
                }),
            /**
             * This method deletes an address of the logged-in customer. The customer must be logged in
             * first with the {@link Auth.login} method.
             *
             * It sends a request to the [Remove Address](https://docs.medusajs.com/api/store#customers_deletecustomersmeaddressesaddress_id)
             * API route.
             *
             * Related guides: [How to manage customer's addresses in the storefront](https://docs.medusajs.com/resources/storefront-development/customers/addresses)
             *
             * @param addressId - The address's ID.
             * @param headers - Headers to pass in the request.
             * @returns The deletion's details.
             *
             * @example
             * sdk.store.customer.deleteAddress("caddr_123")
             * .then(({ deleted, parent: customer }) => {
             *   console.log(customer)
             * })
             */ deleteAddress: (addressId, headers)=>__awaiter(this, void 0, void 0, function*() {
                    return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
                        method: "DELETE",
                        headers
                    });
                })
        };
        this.client = client;
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@medusajs/js-sdk/dist/esm/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/admin/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$auth$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/auth/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$store$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@medusajs/js-sdk/dist/esm/store/index.js [app-rsc] (ecmascript)");
;
;
;
;
class Medusa {
    constructor(config){
        this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Client"](config);
        this.admin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$admin$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Admin"](this.client);
        this.store = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$store$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Store"](this.client);
        this.auth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$medusajs$2f$js$2d$sdk$2f$dist$2f$esm$2f$auth$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Auth"](this.client, config);
    }
}
const __TURBOPACK__default__export__ = Medusa;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/server/lib/trace/constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Contains predefined constants for the trace span name in next/server.
 *
 * Currently, next/server/tracer is internal implementation only for tracking
 * next.js's implementation only with known span names defined here.
 **/ // eslint typescript has a bug with TS enums
/* eslint-disable no-shadow */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppRenderSpan: null,
    AppRouteRouteHandlersSpan: null,
    BaseServerSpan: null,
    LoadComponentsSpan: null,
    LogSpanAllowList: null,
    MiddlewareSpan: null,
    NextNodeServerSpan: null,
    NextServerSpan: null,
    NextVanillaSpanAllowlist: null,
    NodeSpan: null,
    RenderSpan: null,
    ResolveMetadataSpan: null,
    RouterSpan: null,
    StartServerSpan: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRenderSpan: function() {
        return AppRenderSpan;
    },
    AppRouteRouteHandlersSpan: function() {
        return AppRouteRouteHandlersSpan;
    },
    BaseServerSpan: function() {
        return BaseServerSpan;
    },
    LoadComponentsSpan: function() {
        return LoadComponentsSpan;
    },
    LogSpanAllowList: function() {
        return LogSpanAllowList;
    },
    MiddlewareSpan: function() {
        return MiddlewareSpan;
    },
    NextNodeServerSpan: function() {
        return NextNodeServerSpan;
    },
    NextServerSpan: function() {
        return NextServerSpan;
    },
    NextVanillaSpanAllowlist: function() {
        return NextVanillaSpanAllowlist;
    },
    NodeSpan: function() {
        return NodeSpan;
    },
    RenderSpan: function() {
        return RenderSpan;
    },
    ResolveMetadataSpan: function() {
        return ResolveMetadataSpan;
    },
    RouterSpan: function() {
        return RouterSpan;
    },
    StartServerSpan: function() {
        return StartServerSpan;
    }
});
var BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {
    BaseServerSpan["handleRequest"] = "BaseServer.handleRequest";
    BaseServerSpan["run"] = "BaseServer.run";
    BaseServerSpan["pipe"] = "BaseServer.pipe";
    BaseServerSpan["getStaticHTML"] = "BaseServer.getStaticHTML";
    BaseServerSpan["render"] = "BaseServer.render";
    BaseServerSpan["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
    BaseServerSpan["renderToResponse"] = "BaseServer.renderToResponse";
    BaseServerSpan["renderToHTML"] = "BaseServer.renderToHTML";
    BaseServerSpan["renderError"] = "BaseServer.renderError";
    BaseServerSpan["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
    BaseServerSpan["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
    BaseServerSpan["render404"] = "BaseServer.render404";
    return BaseServerSpan;
}(BaseServerSpan || {});
var LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {
    LoadComponentsSpan["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
    LoadComponentsSpan["loadComponents"] = "LoadComponents.loadComponents";
    return LoadComponentsSpan;
}(LoadComponentsSpan || {});
var NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {
    NextServerSpan["getRequestHandler"] = "NextServer.getRequestHandler";
    NextServerSpan["getServer"] = "NextServer.getServer";
    NextServerSpan["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
    NextServerSpan["createServer"] = "createServer.createServer";
    return NextServerSpan;
}(NextServerSpan || {});
var NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {
    NextNodeServerSpan["compression"] = "NextNodeServer.compression";
    NextNodeServerSpan["getBuildId"] = "NextNodeServer.getBuildId";
    NextNodeServerSpan["createComponentTree"] = "NextNodeServer.createComponentTree";
    NextNodeServerSpan["clientComponentLoading"] = "NextNodeServer.clientComponentLoading";
    NextNodeServerSpan["getLayoutOrPageModule"] = "NextNodeServer.getLayoutOrPageModule";
    NextNodeServerSpan["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
    NextNodeServerSpan["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
    NextNodeServerSpan["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
    NextNodeServerSpan["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
    NextNodeServerSpan["sendRenderResult"] = "NextNodeServer.sendRenderResult";
    NextNodeServerSpan["proxyRequest"] = "NextNodeServer.proxyRequest";
    NextNodeServerSpan["runApi"] = "NextNodeServer.runApi";
    NextNodeServerSpan["render"] = "NextNodeServer.render";
    NextNodeServerSpan["renderHTML"] = "NextNodeServer.renderHTML";
    NextNodeServerSpan["imageOptimizer"] = "NextNodeServer.imageOptimizer";
    NextNodeServerSpan["getPagePath"] = "NextNodeServer.getPagePath";
    NextNodeServerSpan["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
    NextNodeServerSpan["findPageComponents"] = "NextNodeServer.findPageComponents";
    NextNodeServerSpan["getFontManifest"] = "NextNodeServer.getFontManifest";
    NextNodeServerSpan["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
    NextNodeServerSpan["getRequestHandler"] = "NextNodeServer.getRequestHandler";
    NextNodeServerSpan["renderToHTML"] = "NextNodeServer.renderToHTML";
    NextNodeServerSpan["renderError"] = "NextNodeServer.renderError";
    NextNodeServerSpan["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
    NextNodeServerSpan["render404"] = "NextNodeServer.render404";
    NextNodeServerSpan["startResponse"] = "NextNodeServer.startResponse";
    // nested inner span, does not require parent scope name
    NextNodeServerSpan["route"] = "route";
    NextNodeServerSpan["onProxyReq"] = "onProxyReq";
    NextNodeServerSpan["apiResolver"] = "apiResolver";
    NextNodeServerSpan["internalFetch"] = "internalFetch";
    return NextNodeServerSpan;
}(NextNodeServerSpan || {});
var StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {
    StartServerSpan["startServer"] = "startServer.startServer";
    return StartServerSpan;
}(StartServerSpan || {});
var RenderSpan = /*#__PURE__*/ function(RenderSpan) {
    RenderSpan["getServerSideProps"] = "Render.getServerSideProps";
    RenderSpan["getStaticProps"] = "Render.getStaticProps";
    RenderSpan["renderToString"] = "Render.renderToString";
    RenderSpan["renderDocument"] = "Render.renderDocument";
    RenderSpan["createBodyResult"] = "Render.createBodyResult";
    return RenderSpan;
}(RenderSpan || {});
var AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {
    AppRenderSpan["renderToString"] = "AppRender.renderToString";
    AppRenderSpan["renderToReadableStream"] = "AppRender.renderToReadableStream";
    AppRenderSpan["getBodyResult"] = "AppRender.getBodyResult";
    AppRenderSpan["fetch"] = "AppRender.fetch";
    return AppRenderSpan;
}(AppRenderSpan || {});
var RouterSpan = /*#__PURE__*/ function(RouterSpan) {
    RouterSpan["executeRoute"] = "Router.executeRoute";
    return RouterSpan;
}(RouterSpan || {});
var NodeSpan = /*#__PURE__*/ function(NodeSpan) {
    NodeSpan["runHandler"] = "Node.runHandler";
    return NodeSpan;
}(NodeSpan || {});
var AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {
    AppRouteRouteHandlersSpan["runHandler"] = "AppRouteRouteHandlers.runHandler";
    return AppRouteRouteHandlersSpan;
}(AppRouteRouteHandlersSpan || {});
var ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {
    ResolveMetadataSpan["generateMetadata"] = "ResolveMetadata.generateMetadata";
    ResolveMetadataSpan["generateViewport"] = "ResolveMetadata.generateViewport";
    return ResolveMetadataSpan;
}(ResolveMetadataSpan || {});
var MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {
    MiddlewareSpan["execute"] = "Middleware.execute";
    return MiddlewareSpan;
}(MiddlewareSpan || {});
const NextVanillaSpanAllowlist = [
    "Middleware.execute",
    "BaseServer.handleRequest",
    "Render.getServerSideProps",
    "Render.getStaticProps",
    "AppRender.fetch",
    "AppRender.getBodyResult",
    "Render.renderDocument",
    "Node.runHandler",
    "AppRouteRouteHandlers.runHandler",
    "ResolveMetadata.generateMetadata",
    "ResolveMetadata.generateViewport",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.findPageComponents",
    "NextNodeServer.getLayoutOrPageModule",
    "NextNodeServer.startResponse",
    "NextNodeServer.clientComponentLoading"
];
const LogSpanAllowList = [
    "NextNodeServer.findPageComponents",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.clientComponentLoading"
]; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isThenable", {
    enumerable: true,
    get: function() {
        return isThenable;
    }
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}),
"[project]/node_modules/next/dist/server/lib/trace/tracer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BubbledError: null,
    SpanKind: null,
    SpanStatusCode: null,
    getTracer: null,
    isBubbledError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BubbledError: function() {
        return BubbledError;
    },
    SpanKind: function() {
        return SpanKind;
    },
    SpanStatusCode: function() {
        return SpanStatusCode;
    },
    getTracer: function() {
        return getTracer;
    },
    isBubbledError: function() {
        return isBubbledError;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/constants.js [app-rsc] (ecmascript)");
const _isthenable = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-rsc] (ecmascript)");
let api;
// we want to allow users to use their own version of @opentelemetry/api if they
// want to, so we try to require it first, and if it fails we fall back to the
// version that is bundled with Next.js
// this is because @opentelemetry/api has to be synced with the version of
// @opentelemetry/tracing that is used, and we don't want to force users to use
// the version that is bundled with Next.js.
// the API is ~stable, so this should be fine
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    try {
        api = __turbopack_context__.r("[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)");
    } catch (err) {
        api = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@opentelemetry/api/index.js [app-rsc] (ecmascript)");
    }
}
const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
class BubbledError extends Error {
    constructor(bubble, result){
        super(), this.bubble = bubble, this.result = result;
    }
}
function isBubbledError(error) {
    if (typeof error !== 'object' || error === null) return false;
    return error instanceof BubbledError;
}
const closeSpanWithError = (span, error)=>{
    if (isBubbledError(error) && error.bubble) {
        span.setAttribute('next.bubble', true);
    } else {
        if (error) {
            span.recordException(error);
            span.setAttribute('error.type', error.name);
        }
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error == null ? void 0 : error.message
        });
    }
    span.end();
};
/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();
const rootSpanIdKey = api.createContextKey('next.rootSpanId');
let lastSpanId = 0;
const getSpanId = ()=>lastSpanId++;
const clientTraceDataSetter = {
    set (carrier, key, value) {
        carrier.push({
            key,
            value
        });
    }
};
class NextTracerImpl {
    /**
   * Returns an instance to the trace with configured name.
   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,
   * This should be lazily evaluated.
   */ getTracerInstance() {
        return trace.getTracer('next.js', '0.0.1');
    }
    getContext() {
        return context;
    }
    getTracePropagationData() {
        const activeContext = context.active();
        const entries = [];
        propagation.inject(activeContext, entries, clientTraceDataSetter);
        return entries;
    }
    getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
    }
    withPropagatedContext(carrier, fn, getter) {
        const activeContext = context.active();
        if (trace.getSpanContext(activeContext)) {
            // Active span is already set, too late to propagate.
            return fn();
        }
        const remoteContext = propagation.extract(activeContext, carrier, getter);
        return context.with(remoteContext, fn);
    }
    trace(...args) {
        var _trace_getSpanContext;
        const [type, fnOrOptions, fnOrEmpty] = args;
        // coerce options form overload
        const { fn, options } = typeof fnOrOptions === 'function' ? {
            fn: fnOrOptions,
            options: {}
        } : {
            fn: fnOrEmpty,
            options: {
                ...fnOrOptions
            }
        };
        const spanName = options.spanName ?? type;
        if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {
            return fn();
        }
        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.
        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        let isRootSpan = false;
        if (!spanContext) {
            spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;
            isRootSpan = true;
        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {
            isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
            'next.span_name': spanName,
            'next.span_type': type,
            ...options.attributes
        };
        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{
                const startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;
                const onCleanup = ()=>{
                    rootSpanAttributesStore.delete(spanId);
                    if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && _constants.LogSpanAllowList.includes(type || '')) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match)=>'-' + match.toLowerCase())}`, {
                            start: startTime,
                            end: performance.now()
                        });
                    }
                };
                if (isRootSpan) {
                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
                }
                try {
                    if (fn.length > 1) {
                        return fn(span, (err)=>closeSpanWithError(span, err));
                    }
                    const result = fn(span);
                    if ((0, _isthenable.isThenable)(result)) {
                        // If there's error make sure it throws
                        return result.then((res)=>{
                            span.end();
                            // Need to pass down the promise result,
                            // it could be react stream response with error { error, stream }
                            return res;
                        }).catch((err)=>{
                            closeSpanWithError(span, err);
                            throw err;
                        }).finally(onCleanup);
                    } else {
                        span.end();
                        onCleanup();
                    }
                    return result;
                } catch (err) {
                    closeSpanWithError(span, err);
                    onCleanup();
                    throw err;
                }
            }));
    }
    wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [
            args[0],
            {},
            args[1]
        ];
        if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {
            return fn;
        }
        return function() {
            let optionsObj = options;
            if (typeof optionsObj === 'function' && typeof fn === 'function') {
                optionsObj = optionsObj.apply(this, arguments);
            }
            const lastArgId = arguments.length - 1;
            const cb = arguments[lastArgId];
            if (typeof cb === 'function') {
                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
                return tracer.trace(name, optionsObj, (_span, done)=>{
                    arguments[lastArgId] = function(err) {
                        done == null ? void 0 : done(err);
                        return scopeBoundCb.apply(this, arguments);
                    };
                    return fn.apply(this, arguments);
                });
            } else {
                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));
            }
        };
    }
    startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(type, options, spanContext);
    }
    getSpanContext(parentSpan) {
        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;
        return spanContext;
    }
    getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
    }
    setRootSpanAttribute(key, value) {
        const spanId = context.active().getValue(rootSpanIdKey);
        const attributes = rootSpanAttributesStore.get(spanId);
        if (attributes) {
            attributes.set(key, value);
        }
    }
}
const getTracer = (()=>{
    const tracer = new NextTracerImpl();
    return ()=>tracer;
})(); //# sourceMappingURL=tracer.js.map
}),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DynamicServerError: null,
    isDynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DynamicServerError: function() {
        return DynamicServerError;
    },
    isDynamicServerError: function() {
        return isDynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map
}),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    StaticGenBailoutError: null,
    isStaticGenBailoutError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    StaticGenBailoutError: function() {
        return StaticGenBailoutError;
    },
    isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
    }
});
const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;
    }
}
function isStaticGenBailoutError(error) {
    if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map
}),
"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isHangingPromiseRejectionError: null,
    makeDevtoolsIOAwarePromise: null,
    makeHangingPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isHangingPromiseRejectionError: function() {
        return isHangingPromiseRejectionError;
    },
    makeDevtoolsIOAwarePromise: function() {
        return makeDevtoolsIOAwarePromise;
    },
    makeHangingPromise: function() {
        return makeHangingPromise;
    }
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(route, expression){
        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route "${route}".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, route, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(route, expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {}
function makeDevtoolsIOAwarePromise(underlying) {
    // in React DevTools if we resolve in a setTimeout we will observe
    // the promise resolution as something that can suspend a boundary or root.
    return new Promise((resolve)=>{
        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.
        setTimeout(()=>{
            resolve(underlying);
        }, 0);
    });
} //# sourceMappingURL=dynamic-rendering-utils.js.map
}),
"[project]/node_modules/next/dist/lib/framework/boundary-constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    METADATA_BOUNDARY_NAME: null,
    OUTLET_BOUNDARY_NAME: null,
    ROOT_LAYOUT_BOUNDARY_NAME: null,
    VIEWPORT_BOUNDARY_NAME: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
    },
    OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
    },
    ROOT_LAYOUT_BOUNDARY_NAME: function() {
        return ROOT_LAYOUT_BOUNDARY_NAME;
    },
    VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
    }
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';
const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'; //# sourceMappingURL=boundary-constants.js.map
}),
"[project]/node_modules/next/dist/lib/scheduler.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    atLeastOneTask: null,
    scheduleImmediate: null,
    scheduleOnNextTick: null,
    waitAtLeastOneReactRenderTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    atLeastOneTask: function() {
        return atLeastOneTask;
    },
    scheduleImmediate: function() {
        return scheduleImmediate;
    },
    scheduleOnNextTick: function() {
        return scheduleOnNextTick;
    },
    waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
    }
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This has to be a shared module which is shared between client component error boundary and dynamic component
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
        return isBailoutToCSRError;
    }
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}),
"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "InvariantError", {
    enumerable: true,
    get: function() {
        return InvariantError;
    }
});
class InvariantError extends Error {
    constructor(message, options){
        super("Invariant: " + (message.endsWith('.') ? message : message + '.') + " This is a bug in Next.js.", options);
        this.name = 'InvariantError';
    }
} //# sourceMappingURL=invariant-error.js.map
}),
"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Postpone: null,
    PreludeState: null,
    abortAndThrowOnSynchronousRequestDataAccess: null,
    abortOnSynchronousPlatformIOAccess: null,
    accessedDynamicData: null,
    annotateDynamicAccess: null,
    consumeDynamicAccess: null,
    createDynamicTrackingState: null,
    createDynamicValidationState: null,
    createHangingInputAbortSignal: null,
    createRenderInBrowserAbortSignal: null,
    delayUntilRuntimeStage: null,
    formatDynamicAPIAccesses: null,
    getFirstDynamicReason: null,
    isDynamicPostpone: null,
    isPrerenderInterruptedError: null,
    logDisallowedDynamicError: null,
    markCurrentScopeAsDynamic: null,
    postponeWithTracking: null,
    throwIfDisallowedDynamic: null,
    throwToInterruptStaticGeneration: null,
    trackAllowedDynamicAccess: null,
    trackDynamicDataInDynamicRender: null,
    trackSynchronousPlatformIOAccessInDev: null,
    trackSynchronousRequestDataAccessInDev: null,
    useDynamicRouteParams: null,
    warnOnSyncDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Postpone: function() {
        return Postpone;
    },
    PreludeState: function() {
        return PreludeState;
    },
    abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
    },
    abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
    },
    accessedDynamicData: function() {
        return accessedDynamicData;
    },
    annotateDynamicAccess: function() {
        return annotateDynamicAccess;
    },
    consumeDynamicAccess: function() {
        return consumeDynamicAccess;
    },
    createDynamicTrackingState: function() {
        return createDynamicTrackingState;
    },
    createDynamicValidationState: function() {
        return createDynamicValidationState;
    },
    createHangingInputAbortSignal: function() {
        return createHangingInputAbortSignal;
    },
    createRenderInBrowserAbortSignal: function() {
        return createRenderInBrowserAbortSignal;
    },
    delayUntilRuntimeStage: function() {
        return delayUntilRuntimeStage;
    },
    formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
    },
    getFirstDynamicReason: function() {
        return getFirstDynamicReason;
    },
    isDynamicPostpone: function() {
        return isDynamicPostpone;
    },
    isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
    },
    logDisallowedDynamicError: function() {
        return logDisallowedDynamicError;
    },
    markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
    },
    postponeWithTracking: function() {
        return postponeWithTracking;
    },
    throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
    },
    throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
    },
    trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
    },
    trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
    },
    trackSynchronousPlatformIOAccessInDev: function() {
        return trackSynchronousPlatformIOAccessInDev;
    },
    trackSynchronousRequestDataAccessInDev: function() {
        return trackSynchronousRequestDataAccessInDev;
    },
    useDynamicRouteParams: function() {
        return useDynamicRouteParams;
    },
    warnOnSyncDynamicError: function() {
        return warnOnSyncDynamicError;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"));
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
const _boundaryconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/framework/boundary-constants.js [app-rsc] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-rsc] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const hasPostpone = typeof _react.default.unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'cache':
            case 'unstable-cache':
                // Inside cache scopes, marking a scope as dynamic has no effect,
                // because the outer cache scope creates a cache boundary. This is
                // subtly different from reading a dynamic data source, which is
                // forbidden inside a cache scope.
                return;
            case 'private-cache':
                // A private cache scope is already dynamic by definition.
                return;
            case 'prerender-legacy':
            case 'prerender-ppr':
            case 'request':
                break;
            default:
                workUnitStore;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender-ppr':
                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
            case 'prerender-legacy':
                workUnitStore.revalidate = 0;
                // We aren't prerendering, but we are generating a static page. We need
                // to bail out of static generation.
                const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                    value: "E550",
                    enumerable: false,
                    configurable: true
                });
                store.dynamicUsageDescription = expression;
                store.dynamicUsageStack = err.stack;
                throw err;
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    workUnitStore.usedDynamic = true;
                }
                break;
            default:
                workUnitStore;
        }
    }
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(workUnitStore) {
    switch(workUnitStore.type){
        case 'cache':
        case 'unstable-cache':
            // Inside cache scopes, marking a scope as dynamic has no effect,
            // because the outer cache scope creates a cache boundary. This is
            // subtly different from reading a dynamic data source, which is
            // forbidden inside a cache scope.
            return;
        case 'private-cache':
            // A private cache scope is already dynamic by definition.
            return;
        case 'prerender':
        case 'prerender-runtime':
        case 'prerender-legacy':
        case 'prerender-ppr':
        case 'prerender-client':
            break;
        case 'request':
            if ("TURBOPACK compile-time truthy", 1) {
                workUnitStore.usedDynamic = true;
            }
            break;
        default:
            workUnitStore;
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
}
function warnOnSyncDynamicError(dynamicTracking) {
    if (dynamicTracking.syncDynamicErrorWithStack) {
        // the server did something sync dynamic, likely
        // leading to an early termination of the prerender.
        console.error(dynamicTracking.syncDynamicErrorWithStack);
    }
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone({ reason, route }) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    _react.default.unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createRenderInBrowserAbortSignal() {
    const controller = new AbortController();
    controller.abort(Object.defineProperty(new _bailouttocsr.BailoutToCSRError('Render in Browser'), "__NEXT_ERROR_CODE", {
        value: "E721",
        enumerable: false,
        configurable: true
    }));
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    switch(workUnitStore.type){
        case 'prerender':
        case 'prerender-runtime':
            const controller = new AbortController();
            if (workUnitStore.cacheSignal) {
                // If we have a cacheSignal it means we're in a prospective render. If
                // the input we're waiting on is coming from another cache, we do want
                // to wait for it so that we can resolve this cache entry too.
                workUnitStore.cacheSignal.inputReady().then(()=>{
                    controller.abort();
                });
            } else {
                // Otherwise we're in the final render and we should already have all
                // our caches filled.
                // If the prerender uses stages, we have wait until the runtime stage,
                // at which point all runtime inputs will be resolved.
                // (otherwise, a runtime prerender might consider `cookies()` hanging
                //  even though they'd resolve in the next task.)
                //
                // We might still be waiting on some microtasks so we
                // wait one tick before giving up. When we give up, we still want to
                // render the content of this cache as deeply as we can so that we can
                // suspend as deeply as possible in the tree or not at all if we don't
                // end up waiting for the input.
                const runtimeStagePromise = (0, _workunitasyncstorageexternal.getRuntimeStagePromise)(workUnitStore);
                if (runtimeStagePromise) {
                    runtimeStagePromise.then(()=>(0, _scheduler.scheduleOnNextTick)(()=>controller.abort()));
                } else {
                    (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());
                }
            }
            return controller.signal;
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
            return undefined;
        default:
            workUnitStore;
    }
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore && workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender-client':
            case 'prerender':
                {
                    const fallbackParams = workUnitStore.fallbackRouteParams;
                    if (fallbackParams && fallbackParams.size > 0) {
                        // We are in a prerender with cacheComponents semantics. We are going to
                        // hang here and never resolve. This will cause the currently
                        // rendering component to effectively be a dynamic hole.
                        _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));
                    }
                    break;
                }
            case 'prerender-ppr':
                {
                    const fallbackParams = workUnitStore.fallbackRouteParams;
                    if (fallbackParams && fallbackParams.size > 0) {
                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
                    }
                    break;
                }
            case 'prerender-runtime':
                throw Object.defineProperty(new _invarianterror.InvariantError(`\`${expression}\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                    value: "E771",
                    enumerable: false,
                    configurable: true
                });
            case 'cache':
            case 'private-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError(`\`${expression}\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                    value: "E745",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-legacy':
            case 'request':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
// Common implicit body tags that React will treat as body when placed directly in html
const bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';
// Detects when RootLayoutBoundary (our framework marker component) appears
// after Suspense in the component stack, indicating the root layout is wrapped
// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.
//
// Example matches:
//   at Suspense (<anonymous>)
//   at __next_root_layout_boundary__ (<anonymous>)
//
// Or with other components in between (but not body/html/implicit-body):
//   at Suspense (<anonymous>)
//   at SomeComponent (<anonymous>)
//   at __next_root_layout_boundary__ (<anonymous>)
const hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\n\\s+at Suspense \\(<anonymous>\\)(?:(?!\\n\\s+at (?:${bodyAndImplicitTags}) \\(<anonymous>\\))[\\s\\S])*?\\n\\s+at ${_boundaryconstants.ROOT_LAYOUT_BOUNDARY_NAME} \\([^\\n]*\\)`);
const hasMetadataRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`);
const hasViewportRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`);
const hasOutletRegex = new RegExp(`\\n\\s+at ${_boundaryconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {
        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.
        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense
        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = `Route "${workStore.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.`);
        } else {
            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`);
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error(`Route "${workStore.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    }
}
function delayUntilRuntimeStage(prerenderStore, result) {
    if (prerenderStore.runtimeStagePromise) {
        return prerenderStore.runtimeStagePromise.then(()=>result);
    }
    return result;
} //# sourceMappingURL=dynamic-rendering.js.map
}),
"[project]/node_modules/next/dist/server/lib/clone-response.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cloneResponse", {
    enumerable: true,
    get: function() {
        return cloneResponse;
    }
});
const noop = ()=>{};
let registry;
if (globalThis.FinalizationRegistry) {
    registry = new FinalizationRegistry((weakRef)=>{
        const stream = weakRef.deref();
        if (stream && !stream.locked) {
            stream.cancel('Response object has been garbage collected').then(noop);
        }
    });
}
function cloneResponse(original) {
    // If the response has no body, then we can just return the original response
    // twice because it's immutable.
    if (!original.body) {
        return [
            original,
            original
        ];
    }
    const [body1, body2] = original.body.tee();
    const cloned1 = new Response(body1, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers
    });
    Object.defineProperty(cloned1, 'url', {
        value: original.url,
        // How the original response.url behaves
        configurable: true,
        enumerable: true,
        writable: false
    });
    // The Fetch Standard allows users to skip consuming the response body by
    // relying on garbage collection to release connection resources.
    // https://github.com/nodejs/undici?tab=readme-ov-file#garbage-collection
    //
    // To cancel the stream you then need to cancel both resulting branches.
    // Teeing a stream will generally lock it for the duration, preventing other
    // readers from locking it.
    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee
    // cloned2 is stored in a react cache and cloned for subsequent requests.
    // It is the original request, and is is garbage collected by a
    // FinalizationRegistry in Undici, but since we're tee-ing the stream
    // ourselves, we need to cancel clone1's stream (the response returned from
    // our dedupe fetch) when clone1 is reclaimed, otherwise we leak memory.
    if (registry && cloned1.body) {
        registry.register(cloned1, new WeakRef(cloned1.body));
    }
    const cloned2 = new Response(body2, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers
    });
    Object.defineProperty(cloned2, 'url', {
        value: original.url,
        // How the original response.url behaves
        configurable: true,
        enumerable: true,
        writable: false
    });
    return [
        cloned1,
        cloned2
    ];
} //# sourceMappingURL=clone-response.js.map
}),
"[project]/node_modules/next/dist/server/lib/dedupe-fetch.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createDedupeFetch", {
    enumerable: true,
    get: function() {
        return createDedupeFetch;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"));
const _cloneresponse = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/clone-response.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]' // generateCacheKey(new Request('https://blank'));
;
function generateCacheKey(request) {
    // We pick the fields that goes into the key used to dedupe requests.
    // We don't include the `cache` field, because we end up using whatever
    // caching resulted from the first request.
    // Notably we currently don't consider non-standard (or future) options.
    // This might not be safe. TODO: warn for non-standard extensions differing.
    // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.
    return JSON.stringify([
        request.method,
        Array.from(request.headers.entries()),
        request.mode,
        request.redirect,
        request.credentials,
        request.referrer,
        request.referrerPolicy,
        request.integrity
    ]);
}
function createDedupeFetch(originalFetch) {
    const getCacheEntries = _react.cache((url)=>[]);
    return function dedupeFetch(resource, options) {
        if (options && options.signal) {
            // If we're passed a signal, then we assume that
            // someone else controls the lifetime of this object and opts out of
            // caching. It's effectively the opt-out mechanism.
            // Ideally we should be able to check this on the Request but
            // it always gets initialized with its own signal so we don't
            // know if it's supposed to override - unless we also override the
            // Request constructor.
            return originalFetch(resource, options);
        }
        // Normalize the Request
        let url;
        let cacheKey;
        if (typeof resource === 'string' && !options) {
            // Fast path.
            cacheKey = simpleCacheKey;
            url = resource;
        } else {
            // Normalize the request.
            // if resource is not a string or a URL (its an instance of Request)
            // then do not instantiate a new Request but instead
            // reuse the request as to not disturb the body in the event it's a ReadableStream.
            const request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;
            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {
                // We currently don't dedupe requests that might have side-effects. Those
                // have to be explicitly cached. We assume that the request doesn't have a
                // body if it's GET or HEAD.
                // keepalive gets treated the same as if you passed a custom cache signal.
                return originalFetch(resource, options);
            }
            cacheKey = generateCacheKey(request);
            url = request.url;
        }
        const cacheEntries = getCacheEntries(url);
        for(let i = 0, j = cacheEntries.length; i < j; i += 1){
            const [key, promise] = cacheEntries[i];
            if (key === cacheKey) {
                return promise.then(()=>{
                    const response = cacheEntries[i][2];
                    if (!response) throw Object.defineProperty(new _invarianterror.InvariantError('No cached response'), "__NEXT_ERROR_CODE", {
                        value: "E579",
                        enumerable: false,
                        configurable: true
                    });
                    // We're cloning the response using this utility because there exists
                    // a bug in the undici library around response cloning. See the
                    // following pull request for more details:
                    // https://github.com/vercel/next.js/pull/73274
                    const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
                    cacheEntries[i][2] = cloned2;
                    return cloned1;
                });
            }
        }
        // We pass the original arguments here in case normalizing the Request
        // doesn't include all the options in this environment.
        const promise = originalFetch(resource, options);
        const entry = [
            cacheKey,
            promise,
            null
        ];
        cacheEntries.push(entry);
        return promise.then((response)=>{
            // We're cloning the response using this utility because there exists
            // a bug in the undici library around response cloning. See the
            // following pull request for more details:
            // https://github.com/vercel/next.js/pull/73274
            const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
            entry[2] = cloned2;
            return cloned1;
        });
    };
} //# sourceMappingURL=dedupe-fetch.js.map
}),
"[project]/node_modules/next/dist/server/response-cache/types.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    CachedRouteKind: null,
    IncrementalCacheKind: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    CachedRouteKind: function() {
        return CachedRouteKind;
    },
    IncrementalCacheKind: function() {
        return IncrementalCacheKind;
    }
});
var CachedRouteKind = /*#__PURE__*/ function(CachedRouteKind) {
    CachedRouteKind["APP_PAGE"] = "APP_PAGE";
    CachedRouteKind["APP_ROUTE"] = "APP_ROUTE";
    CachedRouteKind["PAGES"] = "PAGES";
    CachedRouteKind["FETCH"] = "FETCH";
    CachedRouteKind["REDIRECT"] = "REDIRECT";
    CachedRouteKind["IMAGE"] = "IMAGE";
    return CachedRouteKind;
}({});
var IncrementalCacheKind = /*#__PURE__*/ function(IncrementalCacheKind) {
    IncrementalCacheKind["APP_PAGE"] = "APP_PAGE";
    IncrementalCacheKind["APP_ROUTE"] = "APP_ROUTE";
    IncrementalCacheKind["PAGES"] = "PAGES";
    IncrementalCacheKind["FETCH"] = "FETCH";
    IncrementalCacheKind["IMAGE"] = "IMAGE";
    return IncrementalCacheKind;
}({}); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/next/dist/lib/detached-promise.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A `Promise.withResolvers` implementation that exposes the `resolve` and
 * `reject` functions on a `Promise`.
 *
 * @see https://tc39.es/proposal-promise-with-resolvers/
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "DetachedPromise", {
    enumerable: true,
    get: function() {
        return DetachedPromise;
    }
});
class DetachedPromise {
    constructor(){
        let resolve;
        let reject;
        // Create the promise and assign the resolvers to the object.
        this.promise = new Promise((res, rej)=>{
            resolve = res;
            reject = rej;
        });
        // We know that resolvers is defined because the Promise constructor runs
        // synchronously.
        this.resolve = resolve;
        this.reject = reject;
    }
} //# sourceMappingURL=detached-promise.js.map
}),
"[project]/node_modules/next/dist/lib/batcher.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Batcher", {
    enumerable: true,
    get: function() {
        return Batcher;
    }
});
const _detachedpromise = __turbopack_context__.r("[project]/node_modules/next/dist/lib/detached-promise.js [app-rsc] (ecmascript)");
class Batcher {
    constructor(cacheKeyFn, /**
     * A function that will be called to schedule the wrapped function to be
     * executed. This defaults to a function that will execute the function
     * immediately.
     */ schedulerFn = (fn)=>fn()){
        this.cacheKeyFn = cacheKeyFn;
        this.schedulerFn = schedulerFn;
        this.pending = new Map();
    }
    static create(options) {
        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);
    }
    /**
   * Wraps a function in a promise that will be resolved or rejected only once
   * for a given key. This will allow multiple calls to the function to be
   * made, but only one will be executed at a time. The result of the first
   * call will be returned to all callers.
   *
   * @param key the key to use for the cache
   * @param fn the function to wrap
   * @returns a promise that resolves to the result of the function
   */ async batch(key, fn) {
        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;
        if (cacheKey === null) {
            return fn(cacheKey, Promise.resolve);
        }
        const pending = this.pending.get(cacheKey);
        if (pending) return pending;
        const { promise, resolve, reject } = new _detachedpromise.DetachedPromise();
        this.pending.set(cacheKey, promise);
        this.schedulerFn(async ()=>{
            try {
                const result = await fn(cacheKey, resolve);
                // Resolving a promise multiple times is a no-op, so we can safely
                // resolve all pending promises with the same result.
                resolve(result);
            } catch (err) {
                reject(err);
            } finally{
                this.pending.delete(cacheKey);
            }
        });
        return promise;
    }
} //# sourceMappingURL=batcher.js.map
}),
"[project]/node_modules/next/dist/server/stream-utils/encoded-tags.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ENCODED_TAGS", {
    enumerable: true,
    get: function() {
        return ENCODED_TAGS;
    }
});
const ENCODED_TAGS = {
    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`
    OPENING: {
        // <html
        HTML: new Uint8Array([
            60,
            104,
            116,
            109,
            108
        ]),
        // <body
        BODY: new Uint8Array([
            60,
            98,
            111,
            100,
            121
        ])
    },
    CLOSED: {
        // </head>
        HEAD: new Uint8Array([
            60,
            47,
            104,
            101,
            97,
            100,
            62
        ]),
        // </body>
        BODY: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62
        ]),
        // </html>
        HTML: new Uint8Array([
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ]),
        // </body></html>
        BODY_AND_HTML: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62,
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ])
    },
    META: {
        // Only the match the prefix cause the suffix can be different wether it's xml compatible or not ">" or "/>"
        // <meta name="nxt-icon"
        // This is a special mark that will be replaced by the icon insertion script tag.
        ICON_MARK: new Uint8Array([
            60,
            109,
            101,
            116,
            97,
            32,
            110,
            97,
            109,
            101,
            61,
            34,
            194,
            171,
            110,
            120,
            116,
            45,
            105,
            99,
            111,
            110,
            194,
            187,
            34
        ])
    }
}; //# sourceMappingURL=encoded-tags.js.map
}),
"[project]/node_modules/next/dist/server/stream-utils/uint8array-helpers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Find the starting index of Uint8Array `b` within Uint8Array `a`.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    indexOfUint8Array: null,
    isEquivalentUint8Arrays: null,
    removeFromUint8Array: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    indexOfUint8Array: function() {
        return indexOfUint8Array;
    },
    isEquivalentUint8Arrays: function() {
        return isEquivalentUint8Arrays;
    },
    removeFromUint8Array: function() {
        return removeFromUint8Array;
    }
});
function indexOfUint8Array(a, b) {
    if (b.length === 0) return 0;
    if (a.length === 0 || b.length > a.length) return -1;
    // start iterating through `a`
    for(let i = 0; i <= a.length - b.length; i++){
        let completeMatch = true;
        // from index `i`, iterate through `b` and check for mismatch
        for(let j = 0; j < b.length; j++){
            // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.
            if (a[i + j] !== b[j]) {
                completeMatch = false;
                break;
            }
        }
        if (completeMatch) {
            return i;
        }
    }
    return -1;
}
function isEquivalentUint8Arrays(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function removeFromUint8Array(a, b) {
    const tagIndex = indexOfUint8Array(a, b);
    if (tagIndex === 0) return a.subarray(b.length);
    if (tagIndex > -1) {
        const removed = new Uint8Array(a.length - b.length);
        removed.set(a.slice(0, tagIndex));
        removed.set(a.slice(tagIndex + b.length), tagIndex);
        return removed;
    } else {
        return a;
    }
} //# sourceMappingURL=uint8array-helpers.js.map
}),
"[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MISSING_ROOT_TAGS_ERROR", {
    enumerable: true,
    get: function() {
        return MISSING_ROOT_TAGS_ERROR;
    }
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/shared/lib/segment-cache/output-export-prefetch-encoding.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// In output: export mode, the build id is added to the start of the HTML
// document, directly after the doctype declaration. During a prefetch, the
// client performs a range request to get the build id, so it can check whether
// the target page belongs to the same build.
//
// The first 64 bytes of the document are requested. The exact number isn't
// too important; it must be larger than the build id + doctype + closing and
// ending comment markers, but it doesn't need to match the end of the
// comment exactly.
//
// Build ids are 21 bytes long in the default implementation, though this
// can be overridden in the Next.js config. For the purposes of this check,
// it's OK to only match the start of the id, so we'll truncate it if exceeds
// a certain length.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DOC_PREFETCH_RANGE_HEADER_VALUE: null,
    doesExportedHtmlMatchBuildId: null,
    insertBuildIdComment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DOC_PREFETCH_RANGE_HEADER_VALUE: function() {
        return DOC_PREFETCH_RANGE_HEADER_VALUE;
    },
    doesExportedHtmlMatchBuildId: function() {
        return doesExportedHtmlMatchBuildId;
    },
    insertBuildIdComment: function() {
        return insertBuildIdComment;
    }
});
const DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes
;
const MAX_BUILD_ID_LENGTH = 24;
const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';
function escapeBuildId(buildId) {
    // If the build id is longer than the given limit, it's OK for our purposes
    // to only match the beginning.
    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);
    // Replace hyphens with underscores so it doesn't break the HTML comment.
    // (Unlikely, but if this did happen it would break the whole document.)
    return truncated.replace(/-/g, '_');
}
function insertBuildIdComment(originalHtml, buildId) {
    if (buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it
    // isn't present. Shouldn't happen; suggests an issue elsewhere.
    !originalHtml.startsWith(DOCTYPE_PREFIX)) {
        // Return the original HTML unchanged. This means the document will not
        // be prefetched.
        // TODO: The build id comment is currently only used during prefetches, but
        // if we eventually use this mechanism for regular navigations, we may need
        // to error during build if we fail to insert it for some reason.
        return originalHtml;
    }
    // The comment must be inserted after the doctype.
    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
}
function doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {
    // Check whether the document starts with the expected buildId.
    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
} //# sourceMappingURL=output-export-prefetch-encoding.js.map
}),
"[project]/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    chainStreams: null,
    continueDynamicHTMLResume: null,
    continueDynamicPrerender: null,
    continueFizzStream: null,
    continueStaticPrerender: null,
    createBufferedTransformStream: null,
    createDocumentClosingStream: null,
    createRootLayoutValidatorStream: null,
    renderToInitialFizzStream: null,
    streamFromBuffer: null,
    streamFromString: null,
    streamToBuffer: null,
    streamToString: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    chainStreams: function() {
        return chainStreams;
    },
    continueDynamicHTMLResume: function() {
        return continueDynamicHTMLResume;
    },
    continueDynamicPrerender: function() {
        return continueDynamicPrerender;
    },
    continueFizzStream: function() {
        return continueFizzStream;
    },
    continueStaticPrerender: function() {
        return continueStaticPrerender;
    },
    createBufferedTransformStream: function() {
        return createBufferedTransformStream;
    },
    createDocumentClosingStream: function() {
        return createDocumentClosingStream;
    },
    createRootLayoutValidatorStream: function() {
        return createRootLayoutValidatorStream;
    },
    renderToInitialFizzStream: function() {
        return renderToInitialFizzStream;
    },
    streamFromBuffer: function() {
        return streamFromBuffer;
    },
    streamFromString: function() {
        return streamFromString;
    },
    streamToBuffer: function() {
        return streamToBuffer;
    },
    streamToString: function() {
        return streamToString;
    }
});
const _tracer = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/constants.js [app-rsc] (ecmascript)");
const _detachedpromise = __turbopack_context__.r("[project]/node_modules/next/dist/lib/detached-promise.js [app-rsc] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-rsc] (ecmascript)");
const _encodedtags = __turbopack_context__.r("[project]/node_modules/next/dist/server/stream-utils/encoded-tags.js [app-rsc] (ecmascript)");
const _uint8arrayhelpers = __turbopack_context__.r("[project]/node_modules/next/dist/server/stream-utils/uint8array-helpers.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-rsc] (ecmascript)");
const _outputexportprefetchencoding = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment-cache/output-export-prefetch-encoding.js [app-rsc] (ecmascript)");
function voidCatch() {
// this catcher is designed to be used with pipeTo where we expect the underlying
// pipe implementation to forward errors but we don't want the pipeTo promise to reject
// and be unhandled
}
// We can share the same encoder instance everywhere
// Notably we cannot do the same for TextDecoder because it is stateful
// when handling streaming data
const encoder = new TextEncoder();
function chainStreams(...streams) {
    // If we have no streams, return an empty stream. This behavior is
    // intentional as we're now providing the `RenderResult.EMPTY` value.
    if (streams.length === 0) {
        return new ReadableStream({
            start (controller) {
                controller.close();
            }
        });
    }
    // If we only have 1 stream we fast path it by returning just this stream
    if (streams.length === 1) {
        return streams[0];
    }
    const { readable, writable } = new TransformStream();
    // We always initiate pipeTo immediately. We know we have at least 2 streams
    // so we need to avoid closing the writable when this one finishes.
    let promise = streams[0].pipeTo(writable, {
        preventClose: true
    });
    let i = 1;
    for(; i < streams.length - 1; i++){
        const nextStream = streams[i];
        promise = promise.then(()=>nextStream.pipeTo(writable, {
                preventClose: true
            }));
    }
    // We can omit the length check because we halted before the last stream and there
    // is at least two streams so the lastStream here will always be defined
    const lastStream = streams[i];
    promise = promise.then(()=>lastStream.pipeTo(writable));
    // Catch any errors from the streams and ignore them, they will be handled
    // by whatever is consuming the readable stream.
    promise.catch(voidCatch);
    return readable;
}
function streamFromString(str) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(encoder.encode(str));
            controller.close();
        }
    });
}
function streamFromBuffer(chunk) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(chunk);
            controller.close();
        }
    });
}
async function streamToBuffer(stream) {
    const reader = stream.getReader();
    const chunks = [];
    while(true){
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        chunks.push(value);
    }
    return Buffer.concat(chunks);
}
async function streamToString(stream, signal) {
    const decoder = new TextDecoder('utf-8', {
        fatal: true
    });
    let string = '';
    for await (const chunk of stream){
        if (signal == null ? void 0 : signal.aborted) {
            return string;
        }
        string += decoder.decode(chunk, {
            stream: true
        });
    }
    string += decoder.decode();
    return string;
}
function createBufferedTransformStream() {
    let bufferedChunks = [];
    let bufferByteLength = 0;
    let pending;
    const flush = (controller)=>{
        // If we already have a pending flush, then return early.
        if (pending) return;
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(()=>{
            try {
                const chunk = new Uint8Array(bufferByteLength);
                let copiedBytes = 0;
                for(let i = 0; i < bufferedChunks.length; i++){
                    const bufferedChunk = bufferedChunks[i];
                    chunk.set(bufferedChunk, copiedBytes);
                    copiedBytes += bufferedChunk.byteLength;
                }
                // We just wrote all the buffered chunks so we need to reset the bufferedChunks array
                // and our bufferByteLength to prepare for the next round of buffered chunks
                bufferedChunks.length = 0;
                bufferByteLength = 0;
                controller.enqueue(chunk);
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            // Combine the previous buffer with the new chunk.
            bufferedChunks.push(chunk);
            bufferByteLength += chunk.byteLength;
            // Flush the buffer to the controller.
            flush(controller);
        },
        flush () {
            if (!pending) return;
            return pending.promise;
        }
    });
}
function createPrefetchCommentStream(isBuildTimePrerendering, buildId) {
    // Insert an extra comment at the beginning of the HTML document. This must
    // come after the DOCTYPE, which is inserted by React.
    //
    // The first chunk sent by React will contain the doctype. After that, we can
    // pass through the rest of the chunks as-is.
    let didTransformFirstChunk = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (isBuildTimePrerendering && !didTransformFirstChunk) {
                didTransformFirstChunk = true;
                const decoder = new TextDecoder('utf-8', {
                    fatal: true
                });
                const chunkStr = decoder.decode(chunk, {
                    stream: true
                });
                const updatedChunkStr = (0, _outputexportprefetchencoding.insertBuildIdComment)(chunkStr, buildId);
                controller.enqueue(encoder.encode(updatedChunkStr));
                return;
            }
            controller.enqueue(chunk);
        }
    });
}
function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {
    return (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));
}
function createMetadataTransformStream(insert) {
    let chunkIndex = -1;
    let isMarkRemoved = false;
    return new TransformStream({
        async transform (chunk, controller) {
            let iconMarkIndex = -1;
            let closedHeadIndex = -1;
            chunkIndex++;
            if (isMarkRemoved) {
                controller.enqueue(chunk);
                return;
            }
            let iconMarkLength = 0;
            // Only search for the closed head tag once
            if (iconMarkIndex === -1) {
                iconMarkIndex = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.META.ICON_MARK);
                if (iconMarkIndex === -1) {
                    controller.enqueue(chunk);
                    return;
                } else {
                    // When we found the `<meta name="nxt-icon"` tag prefix, we will remove it from the chunk.
                    // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.
                    iconMarkLength = _encodedtags.ENCODED_TAGS.META.ICON_MARK.length;
                    // Check if next char is /, this is for xml mode.
                    if (chunk[iconMarkIndex + iconMarkLength] === 47) {
                        iconMarkLength += 2;
                    } else {
                        // The last char is `>`
                        iconMarkLength++;
                    }
                }
            }
            // Check if icon mark is inside <head> tag in the first chunk.
            if (chunkIndex === 0) {
                closedHeadIndex = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HEAD);
                if (iconMarkIndex !== -1) {
                    // The mark icon is located in the 1st chunk before the head tag.
                    // We do not need to insert the script tag in this case because it's in the head.
                    // Just remove the icon mark from the chunk.
                    if (iconMarkIndex < closedHeadIndex) {
                        const replaced = new Uint8Array(chunk.length - iconMarkLength);
                        // Remove the icon mark from the chunk.
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);
                        chunk = replaced;
                    } else {
                        // The icon mark is after the head tag, replace and insert the script tag at that position.
                        const insertion = await insert();
                        const encodedInsertion = encoder.encode(insertion);
                        const insertionLength = encodedInsertion.length;
                        const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(encodedInsertion, iconMarkIndex);
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                        chunk = replaced;
                    }
                    isMarkRemoved = true;
                }
            // If there's no icon mark located, it will be handled later when if present in the following chunks.
            } else {
                // When it's appeared in the following chunks, we'll need to
                // remove the mark and then insert the script tag at that position.
                const insertion = await insert();
                const encodedInsertion = encoder.encode(insertion);
                const insertionLength = encodedInsertion.length;
                // Replace the icon mark with the hoist script or empty string.
                const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                // Set the first part of the chunk, before the icon mark.
                replaced.set(chunk.subarray(0, iconMarkIndex));
                // Set the insertion after the icon mark.
                replaced.set(encodedInsertion, iconMarkIndex);
                // Set the rest of the chunk after the icon mark.
                replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                chunk = replaced;
                isMarkRemoved = true;
            }
            controller.enqueue(chunk);
        }
    });
}
function createHeadInsertionTransformStream(insert) {
    let inserted = false;
    // We need to track if this transform saw any bytes because if it didn't
    // we won't want to insert any server HTML at all
    let hasBytes = false;
    return new TransformStream({
        async transform (chunk, controller) {
            hasBytes = true;
            const insertion = await insert();
            if (inserted) {
                if (insertion) {
                    const encodedInsertion = encoder.encode(insertion);
                    controller.enqueue(encodedInsertion);
                }
                controller.enqueue(chunk);
            } else {
                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.
                const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HEAD);
                // In fully static rendering or non PPR rendering cases:
                // `/head>` will always be found in the chunk in first chunk rendering.
                if (index !== -1) {
                    if (insertion) {
                        const encodedInsertion = encoder.encode(insertion);
                        // Get the total count of the bytes in the chunk and the insertion
                        // e.g.
                        // chunk = <head><meta charset="utf-8"></head>
                        // insertion = <script>...</script>
                        // output = <head><meta charset="utf-8"> [ <script>...</script> ] </head>
                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);
                        // Append the first part of the chunk, before the head tag
                        insertedHeadContent.set(chunk.slice(0, index));
                        // Append the server inserted content
                        insertedHeadContent.set(encodedInsertion, index);
                        // Append the rest of the chunk
                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);
                        controller.enqueue(insertedHeadContent);
                    } else {
                        controller.enqueue(chunk);
                    }
                    inserted = true;
                } else {
                    // This will happens in PPR rendering during next start, when the page is partially rendered.
                    // When the page resumes, the head tag will be found in the middle of the chunk.
                    // Where we just need to append the insertion and chunk to the current stream.
                    // e.g.
                    // PPR-static: <head>...</head><body> [ resume content ] </body>
                    // PPR-resume: [ insertion ] [ rest content ]
                    if (insertion) {
                        controller.enqueue(encoder.encode(insertion));
                    }
                    controller.enqueue(chunk);
                    inserted = true;
                }
            }
        },
        async flush (controller) {
            // Check before closing if there's anything remaining to insert.
            if (hasBytes) {
                const insertion = await insert();
                if (insertion) {
                    controller.enqueue(encoder.encode(insertion));
                }
            }
        }
    });
}
// Suffix after main body content - scripts before </body>,
// but wait for the major chunks to be enqueued.
function createDeferredSuffixStream(suffix) {
    let flushed = false;
    let pending;
    const flush = (controller)=>{
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(()=>{
            try {
                controller.enqueue(encoder.encode(suffix));
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // If we've already flushed, we're done.
            if (flushed) return;
            // Schedule the flush to happen.
            flushed = true;
            flush(controller);
        },
        flush (controller) {
            if (pending) return pending.promise;
            if (flushed) return;
            // Flush now.
            controller.enqueue(encoder.encode(suffix));
        }
    });
}
function createFlightDataInjectionTransformStream(stream, delayDataUntilFirstHtmlChunk) {
    let htmlStreamFinished = false;
    let pull = null;
    let donePulling = false;
    function startOrContinuePulling(controller) {
        if (!pull) {
            pull = startPulling(controller);
        }
        return pull;
    }
    async function startPulling(controller) {
        const reader = stream.getReader();
        if (delayDataUntilFirstHtmlChunk) {
            // NOTE: streaming flush
            // We are buffering here for the inlined data stream because the
            // "shell" stream might be chunkenized again by the underlying stream
            // implementation, e.g. with a specific high-water mark. To ensure it's
            // the safe timing to pipe the data stream, this extra tick is
            // necessary.
            // We don't start reading until we've left the current Task to ensure
            // that it's inserted after flushing the shell. Note that this implementation
            // might get stale if impl details of Fizz change in the future.
            await (0, _scheduler.atLeastOneTask)();
        }
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    donePulling = true;
                    return;
                }
                // We want to prioritize HTML over RSC data.
                // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,
                // we're likely to produce an HTML chunk as well, so give it a chance to flush first.
                if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {
                    await (0, _scheduler.atLeastOneTask)();
                }
                controller.enqueue(value);
            }
        } catch (err) {
            controller.error(err);
        }
    }
    return new TransformStream({
        start (controller) {
            if (!delayDataUntilFirstHtmlChunk) {
                startOrContinuePulling(controller);
            }
        },
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // Start the streaming if it hasn't already been started yet.
            if (delayDataUntilFirstHtmlChunk) {
                startOrContinuePulling(controller);
            }
        },
        flush (controller) {
            htmlStreamFinished = true;
            if (donePulling) {
                return;
            }
            return startOrContinuePulling(controller);
        }
    });
}
const CLOSE_TAG = '</body></html>';
/**
 * This transform stream moves the suffix to the end of the stream, so results
 * like `</body></html><script>...</script>` will be transformed to
 * `<script>...</script></body></html>`.
 */ function createMoveSuffixStream() {
    let foundSuffix = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (foundSuffix) {
                return controller.enqueue(chunk);
            }
            const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
            if (index > -1) {
                foundSuffix = true;
                // If the whole chunk is the suffix, then don't write anything, it will
                // be written in the flush.
                if (chunk.length === _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {
                    return;
                }
                // Write out the part before the suffix.
                const before = chunk.slice(0, index);
                controller.enqueue(before);
                // In the case where the suffix is in the middle of the chunk, we need
                // to split the chunk into two parts.
                if (chunk.length > _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {
                    // Write out the part after the suffix.
                    const after = chunk.slice(index + _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);
                    controller.enqueue(after);
                }
            } else {
                controller.enqueue(chunk);
            }
        },
        flush (controller) {
            // Even if we didn't find the suffix, the HTML is not valid if we don't
            // add it, so insert it at the end.
            controller.enqueue(_encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
        }
    });
}
function createStripDocumentClosingTagsTransform() {
    return new TransformStream({
        transform (chunk, controller) {
            // We rely on the assumption that chunks will never break across a code unit.
            // This is reasonable because we currently concat all of React's output from a single
            // flush into one chunk before streaming it forward which means the chunk will represent
            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no
            // longer do this large buffered chunk
            if ((0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HTML)) {
                // the entire chunk is the closing tags; return without enqueueing anything.
                return;
            }
            // We assume these tags will go at together at the end of the document and that
            // they won't appear anywhere else in the document. This is not really a safe assumption
            // but until we revamp our streaming infra this is a performant way to string the tags
            chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY);
            chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HTML);
            controller.enqueue(chunk);
        }
    });
}
function createRootLayoutValidatorStream() {
    let foundHtml = false;
    let foundBody = false;
    return new TransformStream({
        async transform (chunk, controller) {
            // Peek into the streamed chunk to see if the tags are present.
            if (!foundHtml && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.OPENING.HTML) > -1) {
                foundHtml = true;
            }
            if (!foundBody && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.OPENING.BODY) > -1) {
                foundBody = true;
            }
            controller.enqueue(chunk);
        },
        flush (controller) {
            const missingTags = [];
            if (!foundHtml) missingTags.push('html');
            if (!foundBody) missingTags.push('body');
            if (!missingTags.length) return;
            controller.enqueue(encoder.encode(`<html id="__next_error__">
            <template
              data-next-error-message="Missing ${missingTags.map((c)=>`<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags"
              data-next-error-digest="${_constants1.MISSING_ROOT_TAGS_ERROR}"
              data-next-error-stack=""
            ></template>
          `));
        }
    });
}
function chainTransformers(readable, transformers) {
    let stream = readable;
    for (const transformer of transformers){
        if (!transformer) continue;
        stream = stream.pipeThrough(transformer);
    }
    return stream;
}
async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {
    // Suffix itself might contain close tags at the end, so we need to split it.
    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;
    // If we're generating static HTML we need to wait for it to resolve before continuing.
    if (isStaticGeneration) {
        await renderStream.allReady;
    }
    return chainTransformers(renderStream, [
        // Buffer everything to avoid flushing too frequently
        createBufferedTransformStream(),
        // Add build id comment to start of the HTML document (in export mode)
        createPrefetchCommentStream(isBuildTimePrerendering, buildId),
        // Transform metadata
        createMetadataTransformStream(getServerInsertedMetadata),
        // Insert suffix content
        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,
        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        inlinedDataStream ? createFlightDataInjectionTransformStream(inlinedDataStream, true) : null,
        // Validate the root layout for missing html or body tags
        validateRootLayout ? createRootLayoutValidatorStream() : null,
        // Close tags should always be deferred to the end
        createMoveSuffixStream(),
        // Special head insertions
        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid
        // hydration errors. Remove this once it's ready to be handled by react itself.
        createHeadInsertionTransformStream(getServerInsertedHTML)
    ]);
}
async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));
}
async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Add build id comment to start of the HTML document (in export mode)
    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId)) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, true)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
async function continueDynamicHTMLResume(renderStream, { delayDataUntilFirstHtmlChunk, inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {
    return renderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, delayDataUntilFirstHtmlChunk)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
function createDocumentClosingStream() {
    return streamFromString(CLOSE_TAG);
} //# sourceMappingURL=node-web-streams-helper.js.map
}),
"[project]/node_modules/next/dist/server/request-meta.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable no-redeclare */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NEXT_REQUEST_META: null,
    addRequestMeta: null,
    getRequestMeta: null,
    removeRequestMeta: null,
    setRequestMeta: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXT_REQUEST_META: function() {
        return NEXT_REQUEST_META;
    },
    addRequestMeta: function() {
        return addRequestMeta;
    },
    getRequestMeta: function() {
        return getRequestMeta;
    },
    removeRequestMeta: function() {
        return removeRequestMeta;
    },
    setRequestMeta: function() {
        return setRequestMeta;
    }
});
const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
function getRequestMeta(req, key) {
    const meta = req[NEXT_REQUEST_META] || {};
    return typeof key === 'string' ? meta[key] : meta;
}
function setRequestMeta(req, meta) {
    req[NEXT_REQUEST_META] = meta;
    return meta;
}
function addRequestMeta(request, key, value) {
    const meta = getRequestMeta(request);
    meta[key] = value;
    return setRequestMeta(request, meta);
}
function removeRequestMeta(request, key) {
    const meta = getRequestMeta(request);
    delete meta[key];
    return setRequestMeta(request, meta);
} //# sourceMappingURL=request-meta.js.map
}),
"[project]/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "detectDomainLocale", {
    enumerable: true,
    get: function() {
        return detectDomainLocale;
    }
});
function detectDomainLocale(domainItems, hostname, detectedLocale) {
    if (!domainItems) return;
    if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
    }
    for (const item of domainItems){
        var _item_domain, _item_locales;
        // remove port if present
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(':', 1)[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {
            return item;
        }
    }
} //# sourceMappingURL=detect-domain-locale.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parsePath", {
    enumerable: true,
    get: function() {
        return parsePath;
    }
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathPrefix", {
    enumerable: true,
    get: function() {
        return addPathPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathSuffix", {
    enumerable: true,
    get: function() {
        return addPathSuffix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
function addPathSuffix(path, suffix) {
    if (!path.startsWith('/') || !suffix) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    return "" + pathname + suffix + query + hash;
} //# sourceMappingURL=add-path-suffix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pathHasPrefix", {
    enumerable: true,
    get: function() {
        return pathHasPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, _parsepath.parsePath)(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-locale.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addLocale", {
    enumerable: true,
    get: function() {
        return addLocale;
    }
});
const _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)");
const _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    // If no locale was given or the locale is the default locale, we don't need
    // to prefix the path.
    if (!locale || locale === defaultLocale) return path;
    const lower = path.toLowerCase();
    // If the path is an API path or the path already has the locale prefix, we
    // don't need to prefix the path.
    if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, '/api')) return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/" + locale.toLowerCase())) return path;
    }
    // Add the locale prefix to the path.
    return (0, _addpathprefix.addPathPrefix)(path, "/" + locale);
} //# sourceMappingURL=add-locale.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "formatNextPathnameInfo", {
    enumerable: true,
    get: function() {
        return formatNextPathnameInfo;
    }
});
const _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-rsc] (ecmascript)");
const _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)");
const _addpathsuffix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js [app-rsc] (ecmascript)");
const _addlocale = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-locale.js [app-rsc] (ecmascript)");
function formatNextPathnameInfo(info) {
    let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
    if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/" + info.buildId), info.pathname === '/' ? 'index.json' : '.json');
    }
    pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, _addpathsuffix.addPathSuffix)(pathname, '/') : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
} //# sourceMappingURL=format-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/shared/lib/get-hostname.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getHostname", {
    enumerable: true,
    get: function() {
        return getHostname;
    }
});
function getHostname(parsed, headers) {
    // Get the hostname from the headers if it exists, otherwise use the parsed
    // hostname.
    let hostname;
    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(':', 1)[0];
    } else if (parsed.hostname) {
        hostname = parsed.hostname;
    } else return;
    return hostname.toLowerCase();
} //# sourceMappingURL=get-hostname.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removePathPrefix", {
    enumerable: true,
    get: function() {
        return removePathPrefix;
    }
});
const _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
function removePathPrefix(path, prefix) {
    // If the path doesn't start with the prefix we can return it as is. This
    // protects us from situations where the prefix is a substring of the path
    // prefix such as:
    //
    // For prefix: /blog
    //
    //   /blog -> true
    //   /blog/ -> true
    //   /blog/1 -> true
    //   /blogging -> false
    //   /blogging/ -> false
    //   /blogging/1 -> false
    if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
    }
    // Remove the prefix from the path via slicing.
    const withoutPrefix = path.slice(prefix.length);
    // If the path without the prefix starts with a `/` we can return it as is.
    if (withoutPrefix.startsWith('/')) {
        return withoutPrefix;
    }
    // If the path without the prefix doesn't start with a `/` we need to add it
    // back to the path to make sure it's a valid path.
    return "/" + withoutPrefix;
} //# sourceMappingURL=remove-path-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextPathnameInfo", {
    enumerable: true,
    get: function() {
        return getNextPathnameInfo;
    }
});
const _normalizelocalepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js [app-rsc] (ecmascript)");
const _removepathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js [app-rsc] (ecmascript)");
const _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
function getNextPathnameInfo(pathname, options) {
    var _options_nextConfig;
    const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
    const info = {
        pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash
    };
    if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
    }
    let pathnameNoDataPrefix = info.pathname;
    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        const paths = info.pathname.replace(/^\/_next\/data\//, '').replace(/\.json$/, '').split('/');
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== 'index' ? "/" + paths.slice(1).join('/') : '/';
        // update pathname with normalized if enabled although
        // we use normalized to populate locale info still
        if (options.parseData === true) {
            info.pathname = pathnameNoDataPrefix;
        }
    }
    // If provided, use the locale route normalizer to detect the locale instead
    // of the function below.
    if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);
            if (result.detectedLocale) {
                info.locale = result.detectedLocale;
            }
        }
    }
    return info;
} //# sourceMappingURL=get-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/server/web/next-url.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NextURL", {
    enumerable: true,
    get: function() {
        return NextURL;
    }
});
const _detectdomainlocale = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js [app-rsc] (ecmascript)");
const _formatnextpathnameinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js [app-rsc] (ecmascript)");
const _gethostname = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-hostname.js [app-rsc] (ecmascript)");
const _getnextpathnameinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js [app-rsc] (ecmascript)");
const REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
function parseURL(url, base) {
    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'));
}
const Internal = Symbol('NextURLInternal');
class NextURL {
    constructor(input, baseOrOpts, opts){
        let base;
        let options;
        if (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts || typeof baseOrOpts === 'string') {
            base = baseOrOpts;
            options = opts || {};
        } else {
            options = opts || baseOrOpts || {};
        }
        this[Internal] = {
            url: parseURL(input, base ?? options.base),
            options: options,
            basePath: ''
        };
        this.analyze();
    }
    analyze() {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;
        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(this[Internal].url.pathname, {
            nextConfig: this[Internal].options.nextConfig,
            parseData: !("TURBOPACK compile-time value", void 0),
            i18nProvider: this[Internal].options.i18nProvider
        });
        const hostname = (0, _gethostname.getHostname)(this[Internal].url, this[Internal].options.headers);
        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, _detectdomainlocale.detectDomainLocale)((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);
        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? '';
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
    }
    formatPathname() {
        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
            basePath: this[Internal].basePath,
            buildId: this[Internal].buildId,
            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,
            locale: this[Internal].locale,
            pathname: this[Internal].url.pathname,
            trailingSlash: this[Internal].trailingSlash
        });
    }
    formatSearch() {
        return this[Internal].url.search;
    }
    get buildId() {
        return this[Internal].buildId;
    }
    set buildId(buildId) {
        this[Internal].buildId = buildId;
    }
    get locale() {
        return this[Internal].locale ?? '';
    }
    set locale(locale) {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;
        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {
            throw Object.defineProperty(new TypeError(`The NextURL configuration includes no locale "${locale}"`), "__NEXT_ERROR_CODE", {
                value: "E597",
                enumerable: false,
                configurable: true
            });
        }
        this[Internal].locale = locale;
    }
    get defaultLocale() {
        return this[Internal].defaultLocale;
    }
    get domainLocale() {
        return this[Internal].domainLocale;
    }
    get searchParams() {
        return this[Internal].url.searchParams;
    }
    get host() {
        return this[Internal].url.host;
    }
    set host(value) {
        this[Internal].url.host = value;
    }
    get hostname() {
        return this[Internal].url.hostname;
    }
    set hostname(value) {
        this[Internal].url.hostname = value;
    }
    get port() {
        return this[Internal].url.port;
    }
    set port(value) {
        this[Internal].url.port = value;
    }
    get protocol() {
        return this[Internal].url.protocol;
    }
    set protocol(value) {
        this[Internal].url.protocol = value;
    }
    get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
    }
    set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
    }
    get origin() {
        return this[Internal].url.origin;
    }
    get pathname() {
        return this[Internal].url.pathname;
    }
    set pathname(value) {
        this[Internal].url.pathname = value;
    }
    get hash() {
        return this[Internal].url.hash;
    }
    set hash(value) {
        this[Internal].url.hash = value;
    }
    get search() {
        return this[Internal].url.search;
    }
    set search(value) {
        this[Internal].url.search = value;
    }
    get password() {
        return this[Internal].url.password;
    }
    set password(value) {
        this[Internal].url.password = value;
    }
    get username() {
        return this[Internal].url.username;
    }
    set username(value) {
        this[Internal].url.username = value;
    }
    get basePath() {
        return this[Internal].basePath;
    }
    set basePath(value) {
        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;
    }
    toString() {
        return this.href;
    }
    toJSON() {
        return this.href;
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            href: this.href,
            origin: this.origin,
            protocol: this.protocol,
            username: this.username,
            password: this.password,
            host: this.host,
            hostname: this.hostname,
            port: this.port,
            pathname: this.pathname,
            search: this.search,
            searchParams: this.searchParams,
            hash: this.hash
        };
    }
    clone() {
        return new NextURL(String(this), this[Internal].options);
    }
} //# sourceMappingURL=next-url.js.map
}),
"[project]/node_modules/next/dist/server/web/error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PageSignatureError: null,
    RemovedPageError: null,
    RemovedUAError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PageSignatureError: function() {
        return PageSignatureError;
    },
    RemovedPageError: function() {
        return RemovedPageError;
    },
    RemovedUAError: function() {
        return RemovedUAError;
    }
});
class PageSignatureError extends Error {
    constructor({ page }){
        super(`The middleware "${page}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
    }
}
class RemovedPageError extends Error {
    constructor(){
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
    }
}
class RemovedUAError extends Error {
    constructor(){
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
    }
} //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RequestCookies: null,
    ResponseCookies: null,
    stringifyCookie: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RequestCookies: function() {
        return _cookies.RequestCookies;
    },
    ResponseCookies: function() {
        return _cookies.ResponseCookies;
    },
    stringifyCookie: function() {
        return _cookies.stringifyCookie;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-rsc] (ecmascript)"); //# sourceMappingURL=cookies.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/request.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    INTERNALS: null,
    NextRequest: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERNALS: function() {
        return INTERNALS;
    },
    NextRequest: function() {
        return NextRequest;
    }
});
const _nexturl = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/next-url.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/utils.js [app-rsc] (ecmascript)");
const _error = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/error.js [app-rsc] (ecmascript)");
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-rsc] (ecmascript)");
const INTERNALS = Symbol('internal request');
class NextRequest extends Request {
    constructor(input, init = {}){
        const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);
        (0, _utils.validateURL)(url);
        // node Request instance requires duplex option when a body
        // is present or it errors, we don't handle this for
        // Request being passed in since it would have already
        // errored if this wasn't configured
        if ("TURBOPACK compile-time truthy", 1) {
            if (init.body && init.duplex !== 'half') {
                init.duplex = 'half';
            }
        }
        if (input instanceof Request) super(input, init);
        else super(url, init);
        const nextUrl = new _nexturl.NextURL(url, {
            headers: (0, _utils.toNodeOutgoingHttpHeaders)(this.headers),
            nextConfig: init.nextConfig
        });
        this[INTERNALS] = {
            cookies: new _cookies.RequestCookies(this.headers),
            nextUrl,
            url: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : nextUrl.toString()
        };
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            cookies: this.cookies,
            nextUrl: this.nextUrl,
            url: this.url,
            // rest of props come from Request
            bodyUsed: this.bodyUsed,
            cache: this.cache,
            credentials: this.credentials,
            destination: this.destination,
            headers: Object.fromEntries(this.headers),
            integrity: this.integrity,
            keepalive: this.keepalive,
            method: this.method,
            mode: this.mode,
            redirect: this.redirect,
            referrer: this.referrer,
            referrerPolicy: this.referrerPolicy,
            signal: this.signal
        };
    }
    get cookies() {
        return this[INTERNALS].cookies;
    }
    get nextUrl() {
        return this[INTERNALS].nextUrl;
    }
    /**
   * @deprecated
   * `page` has been deprecated in favour of `URLPattern`.
   * Read more: https://nextjs.org/docs/messages/middleware-request-page
   */ get page() {
        throw new _error.RemovedPageError();
    }
    /**
   * @deprecated
   * `ua` has been removed in favour of \`userAgent\` function.
   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
   */ get ua() {
        throw new _error.RemovedUAError();
    }
    get url() {
        return this[INTERNALS].url;
    }
} //# sourceMappingURL=request.js.map
}),
"[project]/node_modules/next/dist/server/base-http/helpers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isNodeNextRequest: null,
    isNodeNextResponse: null,
    isWebNextRequest: null,
    isWebNextResponse: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isNodeNextRequest: function() {
        return isNodeNextRequest;
    },
    isNodeNextResponse: function() {
        return isNodeNextResponse;
    },
    isWebNextRequest: function() {
        return isWebNextRequest;
    },
    isWebNextResponse: function() {
        return isWebNextResponse;
    }
});
const isWebNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isWebNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isNodeNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") !== 'edge';
const isNodeNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") !== 'edge'; //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NextRequestAdapter: null,
    ResponseAborted: null,
    ResponseAbortedName: null,
    createAbortController: null,
    signalFromNodeResponse: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NextRequestAdapter: function() {
        return NextRequestAdapter;
    },
    ResponseAborted: function() {
        return ResponseAborted;
    },
    ResponseAbortedName: function() {
        return ResponseAbortedName;
    },
    createAbortController: function() {
        return createAbortController;
    },
    signalFromNodeResponse: function() {
        return signalFromNodeResponse;
    }
});
const _requestmeta = __turbopack_context__.r("[project]/node_modules/next/dist/server/request-meta.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/utils.js [app-rsc] (ecmascript)");
const _request = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/request.js [app-rsc] (ecmascript)");
const _helpers = __turbopack_context__.r("[project]/node_modules/next/dist/server/base-http/helpers.js [app-rsc] (ecmascript)");
const ResponseAbortedName = 'ResponseAborted';
class ResponseAborted extends Error {
    constructor(...args){
        super(...args), this.name = ResponseAbortedName;
    }
}
function createAbortController(response) {
    const controller = new AbortController();
    // If `finish` fires first, then `res.end()` has been called and the close is
    // just us finishing the stream on our side. If `close` fires first, then we
    // know the client disconnected before we finished.
    response.once('close', ()=>{
        if (response.writableFinished) return;
        controller.abort(new ResponseAborted());
    });
    return controller;
}
function signalFromNodeResponse(response) {
    const { errored, destroyed } = response;
    if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
    }
    const { signal } = createAbortController(response);
    return signal;
}
class NextRequestAdapter {
    static fromBaseNextRequest(request, signal) {
        if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") === 'edge' && (0, _helpers.isWebNextRequest)(request)) //TURBOPACK unreachable
        ;
        else if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") !== 'edge' && (0, _helpers.isNodeNextRequest)(request)) {
            return NextRequestAdapter.fromNodeNextRequest(request, signal);
        } else {
            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), "__NEXT_ERROR_CODE", {
                value: "E345",
                enumerable: false,
                configurable: true
            });
        }
    }
    static fromNodeNextRequest(request, signal) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {
            // @ts-expect-error - this is handled by undici, when streams/web land use it instead
            body = request.body;
        }
        let url;
        if (request.url.startsWith('http')) {
            url = new URL(request.url);
        } else {
            // Grab the full URL from the request metadata.
            const base = (0, _requestmeta.getRequestMeta)(request, 'initURL');
            if (!base || !base.startsWith('http')) {
                // Because the URL construction relies on the fact that the URL provided
                // is absolute, we need to provide a base URL. We can't use the request
                // URL because it's relative, so we use a dummy URL instead.
                url = new URL(request.url, 'http://n');
            } else {
                url = new URL(request.url, base);
            }
        }
        return new _request.NextRequest(url, {
            method: request.method,
            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
            duplex: 'half',
            signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...signal.aborted ? {} : {
                body
            }
        });
    }
    static fromWebNextRequest(request) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
            body = request.body;
        }
        return new _request.NextRequest(request.url, {
            method: request.method,
            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
            duplex: 'half',
            signal: request.request.signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...request.request.signal.aborted ? {} : {
                body
            }
        });
    }
} //# sourceMappingURL=next-request.js.map
}),
"[project]/node_modules/next/dist/server/client-component-renderer-logger.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getClientComponentLoaderMetrics: null,
    wrapClientComponentLoader: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getClientComponentLoaderMetrics: function() {
        return getClientComponentLoaderMetrics;
    },
    wrapClientComponentLoader: function() {
        return wrapClientComponentLoader;
    }
});
// Combined load times for loading client components
let clientComponentLoadStart = 0;
let clientComponentLoadTimes = 0;
let clientComponentLoadCount = 0;
function wrapClientComponentLoader(ComponentMod) {
    if (!('performance' in globalThis)) {
        return ComponentMod.__next_app__;
    }
    return {
        require: (...args)=>{
            const startTime = performance.now();
            if (clientComponentLoadStart === 0) {
                clientComponentLoadStart = startTime;
            }
            try {
                clientComponentLoadCount += 1;
                return ComponentMod.__next_app__.require(...args);
            } finally{
                clientComponentLoadTimes += performance.now() - startTime;
            }
        },
        loadChunk: (...args)=>{
            const startTime = performance.now();
            const result = ComponentMod.__next_app__.loadChunk(...args);
            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.
            // We only need to know when it's settled.
            result.finally(()=>{
                clientComponentLoadTimes += performance.now() - startTime;
            });
            return result;
        }
    };
}
function getClientComponentLoaderMetrics(options = {}) {
    const metrics = clientComponentLoadStart === 0 ? undefined : {
        clientComponentLoadStart,
        clientComponentLoadTimes,
        clientComponentLoadCount
    };
    if (options.reset) {
        clientComponentLoadStart = 0;
        clientComponentLoadTimes = 0;
        clientComponentLoadCount = 0;
    }
    return metrics;
} //# sourceMappingURL=client-component-renderer-logger.js.map
}),
"[project]/node_modules/next/dist/server/pipe-readable.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isAbortError: null,
    pipeToNodeResponse: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isAbortError: function() {
        return isAbortError;
    },
    pipeToNodeResponse: function() {
        return pipeToNodeResponse;
    }
});
const _nextrequest = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js [app-rsc] (ecmascript)");
const _detachedpromise = __turbopack_context__.r("[project]/node_modules/next/dist/lib/detached-promise.js [app-rsc] (ecmascript)");
const _tracer = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/constants.js [app-rsc] (ecmascript)");
const _clientcomponentrendererlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/client-component-renderer-logger.js [app-rsc] (ecmascript)");
function isAbortError(e) {
    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === _nextrequest.ResponseAbortedName;
}
function createWriterFromResponse(res, waitUntilForEnd) {
    let started = false;
    // Create a promise that will resolve once the response has drained. See
    // https://nodejs.org/api/stream.html#stream_event_drain
    let drained = new _detachedpromise.DetachedPromise();
    function onDrain() {
        drained.resolve();
    }
    res.on('drain', onDrain);
    // If the finish event fires, it means we shouldn't block and wait for the
    // drain event.
    res.once('close', ()=>{
        res.off('drain', onDrain);
        drained.resolve();
    });
    // Create a promise that will resolve once the response has finished. See
    // https://nodejs.org/api/http.html#event-finish_1
    const finished = new _detachedpromise.DetachedPromise();
    res.once('finish', ()=>{
        finished.resolve();
    });
    // Create a writable stream that will write to the response.
    return new WritableStream({
        write: async (chunk)=>{
            // You'd think we'd want to use `start` instead of placing this in `write`
            // but this ensures that we don't actually flush the headers until we've
            // started writing chunks.
            if (!started) {
                started = true;
                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {
                    const metrics = (0, _clientcomponentrendererlogger.getClientComponentLoaderMetrics)();
                    if (metrics) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {
                            start: metrics.clientComponentLoadStart,
                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes
                        });
                    }
                }
                res.flushHeaders();
                (0, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.startResponse, {
                    spanName: 'start response'
                }, ()=>undefined);
            }
            try {
                const ok = res.write(chunk);
                // Added by the `compression` middleware, this is a function that will
                // flush the partially-compressed response to the client.
                if ('flush' in res && typeof res.flush === 'function') {
                    res.flush();
                }
                // If the write returns false, it means there's some backpressure, so
                // wait until it's streamed before continuing.
                if (!ok) {
                    await drained.promise;
                    // Reset the drained promise so that we can wait for the next drain event.
                    drained = new _detachedpromise.DetachedPromise();
                }
            } catch (err) {
                res.end();
                throw Object.defineProperty(new Error('failed to write chunk to response', {
                    cause: err
                }), "__NEXT_ERROR_CODE", {
                    value: "E321",
                    enumerable: false,
                    configurable: true
                });
            }
        },
        abort: (err)=>{
            if (res.writableFinished) return;
            res.destroy(err);
        },
        close: async ()=>{
            // if a waitUntil promise was passed, wait for it to resolve before
            // ending the response.
            if (waitUntilForEnd) {
                await waitUntilForEnd;
            }
            if (res.writableFinished) return;
            res.end();
            return finished.promise;
        }
    });
}
async function pipeToNodeResponse(readable, res, waitUntilForEnd) {
    try {
        // If the response has already errored, then just return now.
        const { errored, destroyed } = res;
        if (errored || destroyed) return;
        // Create a new AbortController so that we can abort the readable if the
        // client disconnects.
        const controller = (0, _nextrequest.createAbortController)(res);
        const writer = createWriterFromResponse(res, waitUntilForEnd);
        await readable.pipeTo(writer, {
            signal: controller.signal
        });
    } catch (err) {
        // If this isn't related to an abort error, re-throw it.
        if (isAbortError(err)) return;
        throw Object.defineProperty(new Error('failed to pipe response', {
            cause: err
        }), "__NEXT_ERROR_CODE", {
            value: "E180",
            enumerable: false,
            configurable: true
        });
    }
} //# sourceMappingURL=pipe-readable.js.map
}),
"[project]/node_modules/next/dist/server/render-result.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return RenderResult;
    }
});
const _nodewebstreamshelper = __turbopack_context__.r("[project]/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js [app-rsc] (ecmascript)");
const _pipereadable = __turbopack_context__.r("[project]/node_modules/next/dist/server/pipe-readable.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
class RenderResult {
    static #_ = /**
   * A render result that represents an empty response. This is used to
   * represent a response that was not found or was already sent.
   */ this.EMPTY = new RenderResult(null, {
        metadata: {},
        contentType: null
    });
    /**
   * Creates a new RenderResult instance from a static response.
   *
   * @param value the static response value
   * @param contentType the content type of the response
   * @returns a new RenderResult instance
   */ static fromStatic(value, contentType) {
        return new RenderResult(value, {
            metadata: {},
            contentType
        });
    }
    constructor(response, { contentType, waitUntil, metadata }){
        this.response = response;
        this.contentType = contentType;
        this.metadata = metadata;
        this.waitUntil = waitUntil;
    }
    assignMetadata(metadata) {
        Object.assign(this.metadata, metadata);
    }
    /**
   * Returns true if the response is null. It can be null if the response was
   * not found or was already sent.
   */ get isNull() {
        return this.response === null;
    }
    /**
   * Returns false if the response is a string. It can be a string if the page
   * was prerendered. If it's not, then it was generated dynamically.
   */ get isDynamic() {
        return typeof this.response !== 'string';
    }
    toUnchunkedString(stream = false) {
        if (this.response === null) {
            // If the response is null, return an empty string. This behavior is
            // intentional as we're now providing the `RenderResult.EMPTY` value.
            return '';
        }
        if (typeof this.response !== 'string') {
            if (!stream) {
                throw Object.defineProperty(new _invarianterror.InvariantError('dynamic responses cannot be unchunked. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                    value: "E732",
                    enumerable: false,
                    configurable: true
                });
            }
            return (0, _nodewebstreamshelper.streamToString)(this.readable);
        }
        return this.response;
    }
    /**
   * Returns a readable stream of the response.
   */ get readable() {
        if (this.response === null) {
            // If the response is null, return an empty stream. This behavior is
            // intentional as we're now providing the `RenderResult.EMPTY` value.
            return new ReadableStream({
                start (controller) {
                    controller.close();
                }
            });
        }
        if (typeof this.response === 'string') {
            return (0, _nodewebstreamshelper.streamFromString)(this.response);
        }
        if (Buffer.isBuffer(this.response)) {
            return (0, _nodewebstreamshelper.streamFromBuffer)(this.response);
        }
        // If the response is an array of streams, then chain them together.
        if (Array.isArray(this.response)) {
            return (0, _nodewebstreamshelper.chainStreams)(...this.response);
        }
        return this.response;
    }
    /**
   * Coerces the response to an array of streams. This will convert the response
   * to an array of streams if it is not already one.
   *
   * @returns An array of streams
   */ coerce() {
        if (this.response === null) {
            // If the response is null, return an empty stream. This behavior is
            // intentional as we're now providing the `RenderResult.EMPTY` value.
            return [];
        }
        if (typeof this.response === 'string') {
            return [
                (0, _nodewebstreamshelper.streamFromString)(this.response)
            ];
        } else if (Array.isArray(this.response)) {
            return this.response;
        } else if (Buffer.isBuffer(this.response)) {
            return [
                (0, _nodewebstreamshelper.streamFromBuffer)(this.response)
            ];
        } else {
            return [
                this.response
            ];
        }
    }
    /**
   * Unshifts a new stream to the response. This will convert the response to an
   * array of streams if it is not already one and will add the new stream to
   * the start of the array. When this response is piped, all of the streams
   * will be piped one after the other.
   *
   * @param readable The new stream to unshift
   */ unshift(readable) {
        // Coerce the response to an array of streams.
        this.response = this.coerce();
        // Add the new stream to the start of the array.
        this.response.unshift(readable);
    }
    /**
   * Chains a new stream to the response. This will convert the response to an
   * array of streams if it is not already one and will add the new stream to
   * the end. When this response is piped, all of the streams will be piped
   * one after the other.
   *
   * @param readable The new stream to chain
   */ push(readable) {
        // Coerce the response to an array of streams.
        this.response = this.coerce();
        // Add the new stream to the end of the array.
        this.response.push(readable);
    }
    /**
   * Pipes the response to a writable stream. This will close/cancel the
   * writable stream if an error is encountered. If this doesn't throw, then
   * the writable stream will be closed or aborted.
   *
   * @param writable Writable stream to pipe the response to
   */ async pipeTo(writable) {
        try {
            await this.readable.pipeTo(writable, {
                // We want to close the writable stream ourselves so that we can wait
                // for the waitUntil promise to resolve before closing it. If an error
                // is encountered, we'll abort the writable stream if we swallowed the
                // error.
                preventClose: true
            });
            // If there is a waitUntil promise, wait for it to resolve before
            // closing the writable stream.
            if (this.waitUntil) await this.waitUntil;
            // Close the writable stream.
            await writable.close();
        } catch (err) {
            // If this is an abort error, we should abort the writable stream (as we
            // took ownership of it when we started piping). We don't need to re-throw
            // because we handled the error.
            if ((0, _pipereadable.isAbortError)(err)) {
                // Abort the writable stream if an error is encountered.
                await writable.abort(err);
                return;
            }
            // We're not aborting the writer here as when this method throws it's not
            // clear as to how so the caller should assume it's their responsibility
            // to clean up the writer.
            throw err;
        }
    }
    /**
   * Pipes the response to a node response. This will close/cancel the node
   * response if an error is encountered.
   *
   * @param res
   */ async pipeToNodeResponse(res) {
        await (0, _pipereadable.pipeToNodeResponse)(this.readable, res, this.waitUntil);
    }
} //# sourceMappingURL=render-result.js.map
}),
"[project]/node_modules/next/dist/server/route-kind.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouteKind", {
    enumerable: true,
    get: function() {
        return RouteKind;
    }
});
var RouteKind = /*#__PURE__*/ function(RouteKind) {
    /**
   * `PAGES` represents all the React pages that are under `pages/`.
   */ RouteKind["PAGES"] = "PAGES";
    /**
   * `PAGES_API` represents all the API routes under `pages/api/`.
   */ RouteKind["PAGES_API"] = "PAGES_API";
    /**
   * `APP_PAGE` represents all the React pages that are under `app/` with the
   * filename of `page.{j,t}s{,x}`.
   */ RouteKind["APP_PAGE"] = "APP_PAGE";
    /**
   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the
   * filename of `route.{j,t}s{,x}`.
   */ RouteKind["APP_ROUTE"] = "APP_ROUTE";
    /**
   * `IMAGE` represents all the images that are generated by `next/image`.
   */ RouteKind["IMAGE"] = "IMAGE";
    return RouteKind;
}({}); //# sourceMappingURL=route-kind.js.map
}),
"[project]/node_modules/next/dist/server/response-cache/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    fromResponseCacheEntry: null,
    routeKindToIncrementalCacheKind: null,
    toResponseCacheEntry: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fromResponseCacheEntry: function() {
        return fromResponseCacheEntry;
    },
    routeKindToIncrementalCacheKind: function() {
        return routeKindToIncrementalCacheKind;
    },
    toResponseCacheEntry: function() {
        return toResponseCacheEntry;
    }
});
const _types = __turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/types.js [app-rsc] (ecmascript)");
const _renderresult = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/render-result.js [app-rsc] (ecmascript)"));
const _routekind = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-kind.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function fromResponseCacheEntry(cacheEntry) {
    var _cacheEntry_value, _cacheEntry_value1;
    return {
        ...cacheEntry,
        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === _types.CachedRouteKind.PAGES ? {
            kind: _types.CachedRouteKind.PAGES,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            pageData: cacheEntry.value.pageData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status
        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === _types.CachedRouteKind.APP_PAGE ? {
            kind: _types.CachedRouteKind.APP_PAGE,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            postponed: cacheEntry.value.postponed,
            rscData: cacheEntry.value.rscData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status,
            segmentData: cacheEntry.value.segmentData
        } : cacheEntry.value
    };
}
async function toResponseCacheEntry(response) {
    var _response_value, _response_value1;
    if (!response) return null;
    return {
        isMiss: response.isMiss,
        isStale: response.isStale,
        cacheControl: response.cacheControl,
        value: ((_response_value = response.value) == null ? void 0 : _response_value.kind) === _types.CachedRouteKind.PAGES ? {
            kind: _types.CachedRouteKind.PAGES,
            html: _renderresult.default.fromStatic(response.value.html, _constants.HTML_CONTENT_TYPE_HEADER),
            pageData: response.value.pageData,
            headers: response.value.headers,
            status: response.value.status
        } : ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === _types.CachedRouteKind.APP_PAGE ? {
            kind: _types.CachedRouteKind.APP_PAGE,
            html: _renderresult.default.fromStatic(response.value.html, _constants.HTML_CONTENT_TYPE_HEADER),
            rscData: response.value.rscData,
            headers: response.value.headers,
            status: response.value.status,
            postponed: response.value.postponed,
            segmentData: response.value.segmentData
        } : response.value
    };
}
function routeKindToIncrementalCacheKind(routeKind) {
    switch(routeKind){
        case _routekind.RouteKind.PAGES:
            return _types.IncrementalCacheKind.PAGES;
        case _routekind.RouteKind.APP_PAGE:
            return _types.IncrementalCacheKind.APP_PAGE;
        case _routekind.RouteKind.IMAGE:
            return _types.IncrementalCacheKind.IMAGE;
        case _routekind.RouteKind.APP_ROUTE:
            return _types.IncrementalCacheKind.APP_ROUTE;
        case _routekind.RouteKind.PAGES_API:
            // Pages Router API routes are not cached in the incremental cache.
            throw Object.defineProperty(new Error(`Unexpected route kind ${routeKind}`), "__NEXT_ERROR_CODE", {
                value: "E64",
                enumerable: false,
                configurable: true
            });
        default:
            return routeKind;
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/server/response-cache/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return ResponseCache;
    }
});
0 && __export(__turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/types.js [app-rsc] (ecmascript)"));
const _batcher = __turbopack_context__.r("[project]/node_modules/next/dist/lib/batcher.js [app-rsc] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/utils.js [app-rsc] (ecmascript)");
_export_star(__turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/types.js [app-rsc] (ecmascript)"), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
}
class ResponseCache {
    constructor(minimal_mode){
        this.batcher = _batcher.Batcher.create({
            // Ensure on-demand revalidate doesn't block normal requests, it should be
            // safe to run an on-demand revalidate for the same key as a normal request.
            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,
            // We wait to do any async work until after we've added our promise to
            // `pendingResponses` to ensure that any any other calls will reuse the
            // same promise until we've fully finished our work.
            schedulerFn: _scheduler.scheduleOnNextTick
        });
        this.minimal_mode = minimal_mode;
    }
    async get(key, responseGenerator, context) {
        // If there is no key for the cache, we can't possibly look this up in the
        // cache so just return the result of the response generator.
        if (!key) {
            return responseGenerator({
                hasResolved: false,
                previousCacheEntry: null
            });
        }
        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false, waitUntil } = context;
        const response = await this.batcher.batch({
            key,
            isOnDemandRevalidate
        }, (cacheKey, resolve)=>{
            const prom = (async ()=>{
                var _this_previousCacheItem;
                // We keep the previous cache entry around to leverage when the
                // incremental cache is disabled in minimal mode.
                if (this.minimal_mode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {
                    return this.previousCacheItem.entry;
                }
                // Coerce the kindHint into a given kind for the incremental cache.
                const kind = (0, _utils.routeKindToIncrementalCacheKind)(context.routeKind);
                let resolved = false;
                let cachedResponse = null;
                try {
                    cachedResponse = !this.minimal_mode ? await incrementalCache.get(key, {
                        kind,
                        isRoutePPREnabled: context.isRoutePPREnabled,
                        isFallback
                    }) : null;
                    if (cachedResponse && !isOnDemandRevalidate) {
                        resolve(cachedResponse);
                        resolved = true;
                        if (!cachedResponse.isStale || context.isPrefetch) {
                            // The cached value is still valid, so we don't need
                            // to update it yet.
                            return null;
                        }
                    }
                    const cacheEntry = await responseGenerator({
                        hasResolved: resolved,
                        previousCacheEntry: cachedResponse,
                        isRevalidating: true
                    });
                    // If the cache entry couldn't be generated, we don't want to cache
                    // the result.
                    if (!cacheEntry) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    const resolveValue = await (0, _utils.fromResponseCacheEntry)({
                        ...cacheEntry,
                        isMiss: !cachedResponse
                    });
                    if (!resolveValue) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    // For on-demand revalidate wait to resolve until cache is set.
                    // Otherwise resolve now.
                    if (!isOnDemandRevalidate && !resolved) {
                        resolve(resolveValue);
                        resolved = true;
                    }
                    // We want to persist the result only if it has a cache control value
                    // defined.
                    if (resolveValue.cacheControl) {
                        if (this.minimal_mode) {
                            this.previousCacheItem = {
                                key: cacheKey,
                                entry: resolveValue,
                                expiresAt: Date.now() + 1000
                            };
                        } else {
                            await incrementalCache.set(key, resolveValue.value, {
                                cacheControl: resolveValue.cacheControl,
                                isRoutePPREnabled,
                                isFallback
                            });
                        }
                    }
                    return resolveValue;
                } catch (err) {
                    // When a path is erroring we automatically re-set the existing cache
                    // with new revalidate and expire times to prevent non-stop retrying.
                    if (cachedResponse == null ? void 0 : cachedResponse.cacheControl) {
                        const newRevalidate = Math.min(Math.max(cachedResponse.cacheControl.revalidate || 3, 3), 30);
                        const newExpire = cachedResponse.cacheControl.expire === undefined ? undefined : Math.max(newRevalidate + 3, cachedResponse.cacheControl.expire);
                        await incrementalCache.set(key, cachedResponse.value, {
                            cacheControl: {
                                revalidate: newRevalidate,
                                expire: newExpire
                            },
                            isRoutePPREnabled,
                            isFallback
                        });
                    }
                    // While revalidating in the background we can't reject as we already
                    // resolved the cache entry so log the error here.
                    if (resolved) {
                        console.error(err);
                        return null;
                    }
                    // We haven't resolved yet, so let's throw to indicate an error.
                    throw err;
                }
            })();
            // we need to ensure background revalidates are
            // passed to waitUntil
            if (waitUntil) {
                waitUntil(prom);
            }
            return prom;
        });
        return (0, _utils.toResponseCacheEntry)(response);
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/server/lib/patch-fetch.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NEXT_PATCH_SYMBOL: null,
    createPatchedFetcher: null,
    patchFetch: null,
    validateRevalidate: null,
    validateTags: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXT_PATCH_SYMBOL: function() {
        return NEXT_PATCH_SYMBOL;
    },
    createPatchedFetcher: function() {
        return createPatchedFetcher;
    },
    patchFetch: function() {
        return patchFetch;
    },
    validateRevalidate: function() {
        return validateRevalidate;
    },
    validateTags: function() {
        return validateTags;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/constants.js [app-rsc] (ecmascript)");
const _tracer = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
const _dedupefetch = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/dedupe-fetch.js [app-rsc] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _responsecache = __turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/index.js [app-rsc] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-rsc] (ecmascript)");
const _cloneresponse = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/clone-response.js [app-rsc] (ecmascript)");
const isEdgeRuntime = ("TURBOPACK compile-time value", "nodejs") === 'edge';
const NEXT_PATCH_SYMBOL = Symbol.for('next-patch');
function isFetchPatched() {
    return globalThis[NEXT_PATCH_SYMBOL] === true;
}
function validateRevalidate(revalidateVal, route) {
    try {
        let normalizedRevalidate = undefined;
        if (revalidateVal === false) {
            normalizedRevalidate = _constants1.INFINITE_CACHE;
        } else if (typeof revalidateVal === 'number' && !isNaN(revalidateVal) && revalidateVal > -1) {
            normalizedRevalidate = revalidateVal;
        } else if (typeof revalidateVal !== 'undefined') {
            throw Object.defineProperty(new Error(`Invalid revalidate value "${revalidateVal}" on "${route}", must be a non-negative number or false`), "__NEXT_ERROR_CODE", {
                value: "E179",
                enumerable: false,
                configurable: true
            });
        }
        return normalizedRevalidate;
    } catch (err) {
        // handle client component error from attempting to check revalidate value
        if (err instanceof Error && err.message.includes('Invalid revalidate')) {
            throw err;
        }
        return undefined;
    }
}
function validateTags(tags, description) {
    const validTags = [];
    const invalidTags = [];
    for(let i = 0; i < tags.length; i++){
        const tag = tags[i];
        if (typeof tag !== 'string') {
            invalidTags.push({
                tag,
                reason: 'invalid type, must be a string'
            });
        } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {
            invalidTags.push({
                tag,
                reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`
            });
        } else {
            validTags.push(tag);
        }
        if (validTags.length > _constants1.NEXT_CACHE_TAG_MAX_ITEMS) {
            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(', '));
            break;
        }
    }
    if (invalidTags.length > 0) {
        console.warn(`Warning: invalid tags passed to ${description}: `);
        for (const { tag, reason } of invalidTags){
            console.log(`tag: "${tag}" ${reason}`);
        }
    }
    return validTags;
}
function trackFetchMetric(workStore, ctx) {
    if (!workStore.shouldTrackFetchMetrics) {
        return;
    }
    workStore.fetchMetrics ??= [];
    workStore.fetchMetrics.push({
        ...ctx,
        end: performance.timeOrigin + performance.now(),
        idx: workStore.nextFetchId || 0
    });
}
async function createCachedPrerenderResponse(res, cacheKey, incrementalCacheContext, incrementalCache, revalidate, handleUnlock) {
    // We are prerendering at build time or revalidate time with cacheComponents so we
    // need to buffer the response so we can guarantee it can be read in a
    // microtask.
    const bodyBuffer = await res.arrayBuffer();
    const fetchedData = {
        headers: Object.fromEntries(res.headers.entries()),
        body: Buffer.from(bodyBuffer).toString('base64'),
        status: res.status,
        url: res.url
    };
    // We can skip setting the serverComponentsHmrCache because we aren't in dev
    // mode.
    if (incrementalCacheContext) {
        await incrementalCache.set(cacheKey, {
            kind: _responsecache.CachedRouteKind.FETCH,
            data: fetchedData,
            revalidate
        }, incrementalCacheContext);
    }
    await handleUnlock();
    // We return a new Response to the caller.
    return new Response(bodyBuffer, {
        headers: res.headers,
        status: res.status,
        statusText: res.statusText
    });
}
async function createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheContext, incrementalCache, serverComponentsHmrCache, revalidate, input, handleUnlock) {
    // We're cloning the response using this utility because there exists a bug in
    // the undici library around response cloning. See the following pull request
    // for more details: https://github.com/vercel/next.js/pull/73274
    const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(res);
    // We are dynamically rendering including dev mode. We want to return the
    // response to the caller as soon as possible because it might stream over a
    // very long time.
    const cacheSetPromise = cloned1.arrayBuffer().then(async (arrayBuffer)=>{
        const bodyBuffer = Buffer.from(arrayBuffer);
        const fetchedData = {
            headers: Object.fromEntries(cloned1.headers.entries()),
            body: bodyBuffer.toString('base64'),
            status: cloned1.status,
            url: cloned1.url
        };
        serverComponentsHmrCache == null ? void 0 : serverComponentsHmrCache.set(cacheKey, fetchedData);
        if (incrementalCacheContext) {
            await incrementalCache.set(cacheKey, {
                kind: _responsecache.CachedRouteKind.FETCH,
                data: fetchedData,
                revalidate
            }, incrementalCacheContext);
        }
    }).catch((error)=>console.warn(`Failed to set fetch cache`, input, error)).finally(handleUnlock);
    const pendingRevalidateKey = `cache-set-${cacheKey}`;
    workStore.pendingRevalidates ??= {};
    if (pendingRevalidateKey in workStore.pendingRevalidates) {
        // there is already a pending revalidate entry that we need to await to
        // avoid race conditions
        await workStore.pendingRevalidates[pendingRevalidateKey];
    }
    workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(()=>{
        var _workStore_pendingRevalidates;
        // If the pending revalidate is not present in the store, then we have
        // nothing to delete.
        if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {
            return;
        }
        delete workStore.pendingRevalidates[pendingRevalidateKey];
    });
    return cloned2;
}
function createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {
    // Create the patched fetch function.
    const patched = async function fetch(input, init) {
        var _init_method, _init_next;
        let url;
        try {
            url = new URL(input instanceof Request ? input.url : input);
            url.username = '';
            url.password = '';
        } catch  {
            // Error caused by malformed URL should be handled by native fetch
            url = undefined;
        }
        const fetchUrl = (url == null ? void 0 : url.href) ?? '';
        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || 'GET';
        // Do create a new span trace for internal fetches in the
        // non-verbose mode.
        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;
        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';
        // We don't track fetch metrics for internal fetches
        // so it's not critical that we have a start time, as it won't be recorded.
        // This is to workaround a flaky issue where performance APIs might
        // not be available and will require follow-up investigation.
        const fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();
        const workStore = workAsyncStorage.getStore();
        const workUnitStore = workUnitAsyncStorage.getStore();
        // During static generation we track cache reads so we can reason about when they fill
        let cacheSignal = workUnitStore ? (0, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : null;
        if (cacheSignal) {
            cacheSignal.beginRead();
        }
        const result = (0, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {
            hideSpan,
            kind: _tracer.SpanKind.CLIENT,
            spanName: [
                'fetch',
                method,
                fetchUrl
            ].filter(Boolean).join(' '),
            attributes: {
                'http.url': fetchUrl,
                'http.method': method,
                'net.peer.name': url == null ? void 0 : url.hostname,
                'net.peer.port': (url == null ? void 0 : url.port) || undefined
            }
        }, async ()=>{
            var _getRequestMeta;
            // If this is an internal fetch, we should not do any special treatment.
            if (isInternal) {
                return originFetch(input, init);
            }
            // If the workStore is not available, we can't do any
            // special treatment of fetch, therefore fallback to the original
            // fetch implementation.
            if (!workStore) {
                return originFetch(input, init);
            }
            // We should also fallback to the original fetch implementation if we
            // are in draft mode, it does not constitute a static generation.
            if (workStore.isDraftMode) {
                return originFetch(input, init);
            }
            const isRequestInput = input && typeof input === 'object' && typeof input.method === 'string';
            const getRequestMeta = (field)=>{
                // If request input is present but init is not, retrieve from input first.
                const value = init == null ? void 0 : init[field];
                return value || (isRequestInput ? input[field] : null);
            };
            let finalRevalidate = undefined;
            const getNextField = (field)=>{
                var _init_next, _init_next1, _input_next;
                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== 'undefined' ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;
            };
            // RequestInit doesn't keep extra fields e.g. next so it's
            // only available if init is used separate
            const originalFetchRevalidate = getNextField('revalidate');
            let currentFetchRevalidate = originalFetchRevalidate;
            const tags = validateTags(getNextField('tags') || [], `fetch ${input.toString()}`);
            let revalidateStore;
            if (workUnitStore) {
                switch(workUnitStore.type){
                    case 'prerender':
                    case 'prerender-runtime':
                    // TODO: Stop accumulating tags in client prerender. (fallthrough)
                    case 'prerender-client':
                    case 'prerender-ppr':
                    case 'prerender-legacy':
                    case 'cache':
                    case 'private-cache':
                        revalidateStore = workUnitStore;
                        break;
                    case 'request':
                    case 'unstable-cache':
                        break;
                    default:
                        workUnitStore;
                }
            }
            if (revalidateStore) {
                if (Array.isArray(tags)) {
                    // Collect tags onto parent caches or parent prerenders.
                    const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);
                    for (const tag of tags){
                        if (!collectedTags.includes(tag)) {
                            collectedTags.push(tag);
                        }
                    }
                }
            }
            const implicitTags = workUnitStore == null ? void 0 : workUnitStore.implicitTags;
            let pageFetchCacheMode = workStore.fetchCache;
            if (workUnitStore) {
                switch(workUnitStore.type){
                    case 'unstable-cache':
                        // Inside unstable-cache we treat it the same as force-no-store on
                        // the page.
                        pageFetchCacheMode = 'force-no-store';
                        break;
                    case 'prerender':
                    case 'prerender-client':
                    case 'prerender-runtime':
                    case 'prerender-ppr':
                    case 'prerender-legacy':
                    case 'request':
                    case 'cache':
                    case 'private-cache':
                        break;
                    default:
                        workUnitStore;
                }
            }
            const isUsingNoStore = !!workStore.isUnstableNoStore;
            let currentFetchCacheConfig = getRequestMeta('cache');
            let cacheReason = '';
            let cacheWarning;
            if (typeof currentFetchCacheConfig === 'string' && typeof currentFetchRevalidate !== 'undefined') {
                // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.
                const isConflictingRevalidate = currentFetchCacheConfig === 'force-cache' && currentFetchRevalidate === 0 || // revalidate: >0 or revalidate: false and cache: no-store
                currentFetchCacheConfig === 'no-store' && (currentFetchRevalidate > 0 || currentFetchRevalidate === false);
                if (isConflictingRevalidate) {
                    cacheWarning = `Specified "cache: ${currentFetchCacheConfig}" and "revalidate: ${currentFetchRevalidate}", only one should be specified.`;
                    currentFetchCacheConfig = undefined;
                    currentFetchRevalidate = undefined;
                }
            }
            const hasExplicitFetchCacheOptOut = currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache
            // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.
            pageFetchCacheMode === 'force-no-store' || pageFetchCacheMode === 'only-no-store';
            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,
            // we shouldn't consider caching the fetch. This is because the `dynamic` cache
            // is considered a "top-level" cache mode, whereas something like `fetchCache` is more
            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the
            // other configurations.
            const noFetchConfigAndForceDynamic = !pageFetchCacheMode && !currentFetchCacheConfig && !currentFetchRevalidate && workStore.forceDynamic;
            if (// which will signal the cache to not revalidate
            currentFetchCacheConfig === 'force-cache' && typeof currentFetchRevalidate === 'undefined') {
                currentFetchRevalidate = false;
            } else if (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic) {
                currentFetchRevalidate = 0;
            }
            if (currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store') {
                cacheReason = `cache: ${currentFetchCacheConfig}`;
            }
            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);
            const _headers = getRequestMeta('headers');
            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === 'function' ? _headers : new Headers(_headers || {});
            const hasUnCacheableHeader = initHeaders.get('authorization') || initHeaders.get('cookie');
            const isUnCacheableMethod = ![
                'get',
                'head'
            ].includes(((_getRequestMeta = getRequestMeta('method')) == null ? void 0 : _getRequestMeta.toLowerCase()) || 'get');
            /**
         * We automatically disable fetch caching under the following conditions:
         * - Fetch cache configs are not set. Specifically:
         *    - A page fetch cache mode is not set (export const fetchCache=...)
         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))
         *      or the fetch cache mode is set to 'default'
         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))
         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())
         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)
         */ const hasNoExplicitCacheConfig = pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq
            (currentFetchCacheConfig == undefined || // when considering whether to opt into the default "no-cache" fetch semantics,
            // a "default" cache config should be treated the same as no cache config
            currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq
            currentFetchRevalidate == undefined;
            let autoNoCache = Boolean((hasUnCacheableHeader || isUnCacheableMethod) && (revalidateStore == null ? void 0 : revalidateStore.revalidate) === 0);
            let isImplicitBuildTimeCache = false;
            if (!autoNoCache && hasNoExplicitCacheConfig) {
                // We don't enable automatic no-cache behavior during build-time
                // prerendering so that we can still leverage the fetch cache between
                // export workers.
                if (workStore.isBuildTimePrerendering) {
                    isImplicitBuildTimeCache = true;
                } else {
                    autoNoCache = true;
                }
            }
            // If we have no cache config, and we're in Dynamic I/O prerendering,
            // it'll be a dynamic call. We don't have to issue that dynamic call.
            if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {
                switch(workUnitStore.type){
                    case 'prerender':
                    case 'prerender-runtime':
                    // While we don't want to do caching in the client scope we know the
                    // fetch will be dynamic for cacheComponents so we may as well avoid the
                    // call here. (fallthrough)
                    case 'prerender-client':
                        if (cacheSignal) {
                            cacheSignal.endRead();
                            cacheSignal = null;
                        }
                        return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, 'fetch()');
                    case 'prerender-ppr':
                    case 'prerender-legacy':
                    case 'request':
                    case 'cache':
                    case 'private-cache':
                    case 'unstable-cache':
                        break;
                    default:
                        workUnitStore;
                }
            }
            switch(pageFetchCacheMode){
                case 'force-no-store':
                    {
                        cacheReason = 'fetchCache = force-no-store';
                        break;
                    }
                case 'only-no-store':
                    {
                        if (currentFetchCacheConfig === 'force-cache' || typeof finalRevalidate !== 'undefined' && finalRevalidate > 0) {
                            throw Object.defineProperty(new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`), "__NEXT_ERROR_CODE", {
                                value: "E448",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        cacheReason = 'fetchCache = only-no-store';
                        break;
                    }
                case 'only-cache':
                    {
                        if (currentFetchCacheConfig === 'no-store') {
                            throw Object.defineProperty(new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`), "__NEXT_ERROR_CODE", {
                                value: "E521",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        break;
                    }
                case 'force-cache':
                    {
                        if (typeof currentFetchRevalidate === 'undefined' || currentFetchRevalidate === 0) {
                            cacheReason = 'fetchCache = force-cache';
                            finalRevalidate = _constants1.INFINITE_CACHE;
                        }
                        break;
                    }
                case 'default-cache':
                case 'default-no-store':
                case 'auto':
                case undefined:
                    break;
                default:
                    pageFetchCacheMode;
            }
            if (typeof finalRevalidate === 'undefined') {
                if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {
                    finalRevalidate = _constants1.INFINITE_CACHE;
                    cacheReason = 'fetchCache = default-cache';
                } else if (pageFetchCacheMode === 'default-no-store') {
                    finalRevalidate = 0;
                    cacheReason = 'fetchCache = default-no-store';
                } else if (isUsingNoStore) {
                    finalRevalidate = 0;
                    cacheReason = 'noStore call';
                } else if (autoNoCache) {
                    finalRevalidate = 0;
                    cacheReason = 'auto no cache';
                } else {
                    // TODO: should we consider this case an invariant?
                    cacheReason = 'auto cache';
                    finalRevalidate = revalidateStore ? revalidateStore.revalidate : _constants1.INFINITE_CACHE;
                }
            } else if (!cacheReason) {
                cacheReason = `revalidate: ${finalRevalidate}`;
            }
            if (// `revalidate: 0` values
            !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR
            !autoNoCache && // If the revalidate value isn't currently set or the value is less
            // than the current revalidate value, we should update the revalidate
            // value.
            revalidateStore && finalRevalidate < revalidateStore.revalidate) {
                // If we were setting the revalidate value to 0, we should try to
                // postpone instead first.
                if (finalRevalidate === 0) {
                    if (workUnitStore) {
                        switch(workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                            case 'prerender-runtime':
                                if (cacheSignal) {
                                    cacheSignal.endRead();
                                    cacheSignal = null;
                                }
                                return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, 'fetch()');
                            case 'prerender-ppr':
                            case 'prerender-legacy':
                            case 'request':
                            case 'cache':
                            case 'private-cache':
                            case 'unstable-cache':
                                break;
                            default:
                                workUnitStore;
                        }
                    }
                    (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);
                }
                // We only want to set the revalidate store's revalidate time if it
                // was explicitly set for the fetch call, i.e.
                // originalFetchRevalidate.
                if (revalidateStore && originalFetchRevalidate === finalRevalidate) {
                    revalidateStore.revalidate = finalRevalidate;
                }
            }
            const isCacheableRevalidate = typeof finalRevalidate === 'number' && finalRevalidate > 0;
            let cacheKey;
            const { incrementalCache } = workStore;
            let isHmrRefresh = false;
            let serverComponentsHmrCache;
            if (workUnitStore) {
                switch(workUnitStore.type){
                    case 'request':
                    case 'cache':
                    case 'private-cache':
                        isHmrRefresh = workUnitStore.isHmrRefresh ?? false;
                        serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache;
                        break;
                    case 'prerender':
                    case 'prerender-client':
                    case 'prerender-runtime':
                    case 'prerender-ppr':
                    case 'prerender-legacy':
                    case 'unstable-cache':
                        break;
                    default:
                        workUnitStore;
                }
            }
            if (incrementalCache && (isCacheableRevalidate || serverComponentsHmrCache)) {
                try {
                    cacheKey = await incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);
                } catch (err) {
                    console.error(`Failed to generate cache key for`, input);
                }
            }
            const fetchIdx = workStore.nextFetchId ?? 1;
            workStore.nextFetchId = fetchIdx + 1;
            let handleUnlock = ()=>{};
            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{
                const requestInputFields = [
                    'cache',
                    'credentials',
                    'headers',
                    'integrity',
                    'keepalive',
                    'method',
                    'mode',
                    'redirect',
                    'referrer',
                    'referrerPolicy',
                    'window',
                    'duplex',
                    // don't pass through signal when revalidating
                    ...isStale ? [] : [
                        'signal'
                    ]
                ];
                if (isRequestInput) {
                    const reqInput = input;
                    const reqOptions = {
                        body: reqInput._ogBody || reqInput.body
                    };
                    for (const field of requestInputFields){
                        // @ts-expect-error custom fields
                        reqOptions[field] = reqInput[field];
                    }
                    input = new Request(reqInput.url, reqOptions);
                } else if (init) {
                    const { _ogBody, body, signal, ...otherInput } = init;
                    init = {
                        ...otherInput,
                        body: _ogBody || body,
                        signal: isStale ? undefined : signal
                    };
                }
                // add metadata to init without editing the original
                const clonedInit = {
                    ...init,
                    next: {
                        ...init == null ? void 0 : init.next,
                        fetchType: 'origin',
                        fetchIdx
                    }
                };
                return originFetch(input, clonedInit).then(async (res)=>{
                    if (!isStale && fetchStart) {
                        trackFetchMetric(workStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason: cacheReasonOverride || cacheReason,
                            cacheStatus: finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',
                            cacheWarning,
                            status: res.status,
                            method: clonedInit.method || 'GET'
                        });
                    }
                    if (res.status === 200 && incrementalCache && cacheKey && (isCacheableRevalidate || serverComponentsHmrCache)) {
                        const normalizedRevalidate = finalRevalidate >= _constants1.INFINITE_CACHE ? _constants1.CACHE_ONE_YEAR : finalRevalidate;
                        const incrementalCacheConfig = isCacheableRevalidate ? {
                            fetchCache: true,
                            fetchUrl,
                            fetchIdx,
                            tags,
                            isImplicitBuildTimeCache
                        } : undefined;
                        switch(workUnitStore == null ? void 0 : workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                            case 'prerender-runtime':
                                return createCachedPrerenderResponse(res, cacheKey, incrementalCacheConfig, incrementalCache, normalizedRevalidate, handleUnlock);
                            case 'prerender-ppr':
                            case 'prerender-legacy':
                            case 'request':
                            case 'cache':
                            case 'private-cache':
                            case 'unstable-cache':
                            case undefined:
                                return createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheConfig, incrementalCache, serverComponentsHmrCache, normalizedRevalidate, input, handleUnlock);
                            default:
                                workUnitStore;
                        }
                    }
                    // we had response that we determined shouldn't be cached so we return it
                    // and don't cache it. This also needs to unlock the cache lock we acquired.
                    await handleUnlock();
                    return res;
                }).catch((error)=>{
                    handleUnlock();
                    throw error;
                });
            };
            let cacheReasonOverride;
            let isForegroundRevalidate = false;
            let isHmrRefreshCache = false;
            if (cacheKey && incrementalCache) {
                let cachedFetchData;
                if (isHmrRefresh && serverComponentsHmrCache) {
                    cachedFetchData = serverComponentsHmrCache.get(cacheKey);
                    isHmrRefreshCache = true;
                }
                if (isCacheableRevalidate && !cachedFetchData) {
                    handleUnlock = await incrementalCache.lock(cacheKey);
                    const entry = workStore.isOnDemandRevalidate ? null : await incrementalCache.get(cacheKey, {
                        kind: _responsecache.IncrementalCacheKind.FETCH,
                        revalidate: finalRevalidate,
                        fetchUrl,
                        fetchIdx,
                        tags,
                        softTags: implicitTags == null ? void 0 : implicitTags.tags
                    });
                    if (hasNoExplicitCacheConfig && workUnitStore) {
                        switch(workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                            case 'prerender-runtime':
                                // We sometimes use the cache to dedupe fetches that do not
                                // specify a cache configuration. In these cases we want to
                                // make sure we still exclude them from prerenders if
                                // cacheComponents is on so we introduce an artificial task boundary
                                // here.
                                await (0, _scheduler.waitAtLeastOneReactRenderTask)();
                                break;
                            case 'prerender-ppr':
                            case 'prerender-legacy':
                            case 'request':
                            case 'cache':
                            case 'private-cache':
                            case 'unstable-cache':
                                break;
                            default:
                                workUnitStore;
                        }
                    }
                    if (entry) {
                        await handleUnlock();
                    } else {
                        // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers
                        cacheReasonOverride = 'cache-control: no-cache (hard refresh)';
                    }
                    if ((entry == null ? void 0 : entry.value) && entry.value.kind === _responsecache.CachedRouteKind.FETCH) {
                        // when stale and is revalidating we wait for fresh data
                        // so the revalidated entry has the updated data
                        if (workStore.isRevalidate && entry.isStale) {
                            isForegroundRevalidate = true;
                        } else {
                            if (entry.isStale) {
                                workStore.pendingRevalidates ??= {};
                                if (!workStore.pendingRevalidates[cacheKey]) {
                                    const pendingRevalidate = doOriginalFetch(true).then(async (response)=>({
                                            body: await response.arrayBuffer(),
                                            headers: response.headers,
                                            status: response.status,
                                            statusText: response.statusText
                                        })).finally(()=>{
                                        workStore.pendingRevalidates ??= {};
                                        delete workStore.pendingRevalidates[cacheKey || ''];
                                    });
                                    // Attach the empty catch here so we don't get a "unhandled
                                    // promise rejection" warning.
                                    pendingRevalidate.catch(console.error);
                                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate;
                                }
                            }
                            cachedFetchData = entry.value.data;
                        }
                    }
                }
                if (cachedFetchData) {
                    if (fetchStart) {
                        trackFetchMetric(workStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason,
                            cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',
                            cacheWarning,
                            status: cachedFetchData.status || 200,
                            method: (init == null ? void 0 : init.method) || 'GET'
                        });
                    }
                    const response = new Response(Buffer.from(cachedFetchData.body, 'base64'), {
                        headers: cachedFetchData.headers,
                        status: cachedFetchData.status
                    });
                    Object.defineProperty(response, 'url', {
                        value: cachedFetchData.url
                    });
                    return response;
                }
            }
            if (workStore.isStaticGeneration && init && typeof init === 'object') {
                const { cache } = init;
                // Delete `cache` property as Cloudflare Workers will throw an error
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                if (cache === 'no-store') {
                    // If enabled, we should bail out of static generation.
                    if (workUnitStore) {
                        switch(workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                            case 'prerender-runtime':
                                if (cacheSignal) {
                                    cacheSignal.endRead();
                                    cacheSignal = null;
                                }
                                return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, 'fetch()');
                            case 'prerender-ppr':
                            case 'prerender-legacy':
                            case 'request':
                            case 'cache':
                            case 'private-cache':
                            case 'unstable-cache':
                                break;
                            default:
                                workUnitStore;
                        }
                    }
                    (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `no-store fetch ${input} ${workStore.route}`);
                }
                const hasNextConfig = 'next' in init;
                const { next = {} } = init;
                if (typeof next.revalidate === 'number' && revalidateStore && next.revalidate < revalidateStore.revalidate) {
                    if (next.revalidate === 0) {
                        // If enabled, we should bail out of static generation.
                        if (workUnitStore) {
                            switch(workUnitStore.type){
                                case 'prerender':
                                case 'prerender-client':
                                case 'prerender-runtime':
                                    return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, 'fetch()');
                                case 'request':
                                case 'cache':
                                case 'private-cache':
                                case 'unstable-cache':
                                case 'prerender-legacy':
                                case 'prerender-ppr':
                                    break;
                                default:
                                    workUnitStore;
                            }
                        }
                        (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);
                    }
                    if (!workStore.forceStatic || next.revalidate !== 0) {
                        revalidateStore.revalidate = next.revalidate;
                    }
                }
                if (hasNextConfig) delete init.next;
            }
            // if we are revalidating the whole page via time or on-demand and
            // the fetch cache entry is stale we should still de-dupe the
            // origin hit if it's a cache-able entry
            if (cacheKey && isForegroundRevalidate) {
                const pendingRevalidateKey = cacheKey;
                workStore.pendingRevalidates ??= {};
                let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];
                if (pendingRevalidate) {
                    const revalidatedResult = await pendingRevalidate;
                    return new Response(revalidatedResult.body, {
                        headers: revalidatedResult.headers,
                        status: revalidatedResult.status,
                        statusText: revalidatedResult.statusText
                    });
                }
                // We used to just resolve the Response and clone it however for
                // static generation with cacheComponents we need the response to be able to
                // be resolved in a microtask and cloning the response will never have
                // a body that can resolve in a microtask in node (as observed through
                // experimentation) So instead we await the body and then when it is
                // available we construct manually cloned Response objects with the
                // body as an ArrayBuffer. This will be resolvable in a microtask
                // making it compatible with cacheComponents.
                const pendingResponse = doOriginalFetch(true, cacheReasonOverride) // We're cloning the response using this utility because there
                // exists a bug in the undici library around response cloning.
                // See the following pull request for more details:
                // https://github.com/vercel/next.js/pull/73274
                .then(_cloneresponse.cloneResponse);
                pendingRevalidate = pendingResponse.then(async (responses)=>{
                    const response = responses[0];
                    return {
                        body: await response.arrayBuffer(),
                        headers: response.headers,
                        status: response.status,
                        statusText: response.statusText
                    };
                }).finally(()=>{
                    var _workStore_pendingRevalidates;
                    // If the pending revalidate is not present in the store, then
                    // we have nothing to delete.
                    if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {
                        return;
                    }
                    delete workStore.pendingRevalidates[pendingRevalidateKey];
                });
                // Attach the empty catch here so we don't get a "unhandled promise
                // rejection" warning
                pendingRevalidate.catch(()=>{});
                workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;
                return pendingResponse.then((responses)=>responses[1]);
            } else {
                return doOriginalFetch(false, cacheReasonOverride);
            }
        });
        if (cacheSignal) {
            try {
                return await result;
            } finally{
                if (cacheSignal) {
                    cacheSignal.endRead();
                }
            }
        }
        return result;
    };
    // Attach the necessary properties to the patched fetch function.
    // We don't use this to determine if the fetch function has been patched,
    // but for external consumers to determine if the fetch function has been
    // patched.
    patched.__nextPatched = true;
    patched.__nextGetStaticStore = ()=>workAsyncStorage;
    patched._nextOriginalFetch = originFetch;
    globalThis[NEXT_PATCH_SYMBOL] = true;
    // Assign the function name also as a name property, so that it's preserved
    // even when mangling is enabled.
    Object.defineProperty(patched, 'name', {
        value: 'fetch',
        writable: false
    });
    return patched;
}
function patchFetch(options) {
    // If we've already patched fetch, we should not patch it again.
    if (isFetchPatched()) return;
    // Grab the original fetch function. We'll attach this so we can use it in
    // the patched fetch function.
    const original = (0, _dedupefetch.createDedupeFetch)(globalThis.fetch);
    // Set the global fetch to the patched fetch.
    globalThis.fetch = createPatchedFetcher(original, options);
} //# sourceMappingURL=patch-fetch.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/unstable-cache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_cache", {
    enumerable: true,
    get: function() {
        return unstable_cache;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _patchfetch = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/patch-fetch.js [app-rsc] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _responsecache = __turbopack_context__.r("[project]/node_modules/next/dist/server/response-cache/index.js [app-rsc] (ecmascript)");
let noStoreFetchIdx = 0;
async function cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {
    await incrementalCache.set(cacheKey, {
        kind: _responsecache.CachedRouteKind.FETCH,
        data: {
            headers: {},
            // TODO: handle non-JSON values?
            body: JSON.stringify(result),
            status: 200,
            url: ''
        },
        revalidate: typeof revalidate !== 'number' ? _constants.CACHE_ONE_YEAR : revalidate
    }, {
        fetchCache: true,
        tags,
        fetchIdx,
        fetchUrl
    });
    return;
}
function unstable_cache(cb, keyParts, options = {}) {
    if (options.revalidate === 0) {
        throw Object.defineProperty(new Error(`Invariant revalidate: 0 can not be passed to unstable_cache(), must be "false" or "> 0" ${cb.toString()}`), "__NEXT_ERROR_CODE", {
            value: "E57",
            enumerable: false,
            configurable: true
        });
    }
    // Validate the tags provided are valid
    const tags = options.tags ? (0, _patchfetch.validateTags)(options.tags, `unstable_cache ${cb.toString()}`) : [];
    // Validate the revalidate options
    (0, _patchfetch.validateRevalidate)(options.revalidate, `unstable_cache ${cb.name || cb.toString()}`);
    // Stash the fixed part of the key at construction time. The invocation key will combine
    // the fixed key with the arguments when actually called
    // @TODO if cb.toString() is long we should hash it
    // @TODO come up with a collision-free way to combine keyParts
    // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees
    // and the error produced by accidentally using something that cannot be safely coerced is likely
    // hard to debug
    const fixedKey = `${cb.toString()}-${Array.isArray(keyParts) && keyParts.join(',')}`;
    const cachedCb = async (...args)=>{
        const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        // We must be able to find the incremental cache otherwise we throw
        const maybeIncrementalCache = (workStore == null ? void 0 : workStore.incrementalCache) || globalThis.__incrementalCache;
        if (!maybeIncrementalCache) {
            throw Object.defineProperty(new Error(`Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`), "__NEXT_ERROR_CODE", {
                value: "E469",
                enumerable: false,
                configurable: true
            });
        }
        const incrementalCache = maybeIncrementalCache;
        const cacheSignal = workUnitStore ? (0, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : null;
        if (cacheSignal) {
            cacheSignal.beginRead();
        }
        try {
            // If there's no request store, we aren't in a request (or we're not in
            // app router) and if there's no static generation store, we aren't in app
            // router. Default to an empty pathname and search params when there's no
            // request store or static generation store available.
            const fetchUrlPrefix = workStore && workUnitStore ? getFetchUrlPrefix(workStore, workUnitStore) : '';
            // Construct the complete cache key for this function invocation
            // @TODO stringify is likely not safe here. We will coerce undefined to null which will make
            // the keyspace smaller than the execution space
            const invocationKey = `${fixedKey}-${JSON.stringify(args)}`;
            const cacheKey = await incrementalCache.generateCacheKey(invocationKey);
            // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse
            const fetchUrl = `unstable_cache ${fetchUrlPrefix} ${cb.name ? ` ${cb.name}` : cacheKey}`;
            const fetchIdx = (workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? 1;
            const implicitTags = workUnitStore == null ? void 0 : workUnitStore.implicitTags;
            const innerCacheStore = {
                type: 'unstable-cache',
                phase: 'render',
                implicitTags,
                draftMode: workUnitStore && workStore && (0, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, workUnitStore)
            };
            if (workStore) {
                workStore.nextFetchId = fetchIdx + 1;
                // We are in an App Router context. We try to return the cached entry if it exists and is valid
                // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in
                // the background. If the entry is missing or invalid we generate a new entry and return it.
                let isNestedUnstableCache = false;
                if (workUnitStore) {
                    switch(workUnitStore.type){
                        case 'cache':
                        case 'private-cache':
                        case 'prerender':
                        case 'prerender-runtime':
                        case 'prerender-ppr':
                        case 'prerender-legacy':
                            // We update the store's revalidate property if the option.revalidate is a higher precedence
                            // options.revalidate === undefined doesn't affect timing.
                            // options.revalidate === false doesn't shrink timing. it stays at the maximum.
                            if (typeof options.revalidate === 'number') {
                                if (workUnitStore.revalidate < options.revalidate) {
                                // The store is already revalidating on a shorter time interval, leave it alone
                                } else {
                                    workUnitStore.revalidate = options.revalidate;
                                }
                            }
                            // We need to accumulate the tags for this invocation within the store
                            const collectedTags = workUnitStore.tags;
                            if (collectedTags === null) {
                                workUnitStore.tags = tags.slice();
                            } else {
                                for (const tag of tags){
                                    // @TODO refactor tags to be a set to avoid this O(n) lookup
                                    if (!collectedTags.includes(tag)) {
                                        collectedTags.push(tag);
                                    }
                                }
                            }
                            break;
                        case 'unstable-cache':
                            isNestedUnstableCache = true;
                            break;
                        case 'prerender-client':
                        case 'request':
                            break;
                        default:
                            workUnitStore;
                    }
                }
                if (// we should bypass cache similar to fetches
                !isNestedUnstableCache && workStore.fetchCache !== 'force-no-store' && !workStore.isOnDemandRevalidate && !incrementalCache.isOnDemandRevalidate && !workStore.isDraftMode) {
                    // We attempt to get the current cache entry from the incremental cache.
                    const cacheEntry = await incrementalCache.get(cacheKey, {
                        kind: _responsecache.IncrementalCacheKind.FETCH,
                        revalidate: options.revalidate,
                        tags,
                        softTags: implicitTags == null ? void 0 : implicitTags.tags,
                        fetchIdx,
                        fetchUrl
                    });
                    if (cacheEntry && cacheEntry.value) {
                        // The entry exists and has a value
                        if (cacheEntry.value.kind !== _responsecache.CachedRouteKind.FETCH) {
                            // The entry is invalid and we need a special warning
                            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced
                            // so bugs can be reported
                            // @TODO the invocation key can have sensitive data in it. we should not log this entire object
                            console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);
                        // will fall through to generating a new cache entry below
                        } else {
                            // We have a valid cache entry so we will be returning it. We also check to see if we need
                            // to background revalidate it by checking if it is stale.
                            const cachedResponse = cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;
                            if (cacheEntry.isStale) {
                                // In App Router we return the stale result and revalidate in the background
                                if (!workStore.pendingRevalidates) {
                                    workStore.pendingRevalidates = {};
                                }
                                // We run the cache function asynchronously and save the result when it completes
                                workStore.pendingRevalidates[invocationKey] = _workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args).then((result)=>{
                                    return cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
                                }) // @TODO This error handling seems wrong. We swallow the error?
                                .catch((err)=>console.error(`revalidating cache with key: ${invocationKey}`, err));
                            }
                            // We had a valid cache entry so we return it here
                            return cachedResponse;
                        }
                    }
                }
                // If we got this far then we had an invalid cache entry and need to generate a new one
                const result = await _workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args);
                if (!workStore.isDraftMode) {
                    if (!workStore.pendingRevalidates) {
                        workStore.pendingRevalidates = {};
                    }
                    // We need to push the cache result promise to pending
                    // revalidates otherwise it won't be awaited and is just
                    // dangling
                    workStore.pendingRevalidates[invocationKey] = cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
                }
                return result;
            } else {
                noStoreFetchIdx += 1;
                // We are in Pages Router or were called outside of a render. We don't have a store
                // so we just call the callback directly when it needs to run.
                // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in
                // the background. If the entry is missing or invalid we generate a new entry and return it.
                if (!incrementalCache.isOnDemandRevalidate) {
                    // We aren't doing an on demand revalidation so we check use the cache if valid
                    const cacheEntry = await incrementalCache.get(cacheKey, {
                        kind: _responsecache.IncrementalCacheKind.FETCH,
                        revalidate: options.revalidate,
                        tags,
                        fetchIdx,
                        fetchUrl,
                        softTags: implicitTags == null ? void 0 : implicitTags.tags
                    });
                    if (cacheEntry && cacheEntry.value) {
                        // The entry exists and has a value
                        if (cacheEntry.value.kind !== _responsecache.CachedRouteKind.FETCH) {
                            // The entry is invalid and we need a special warning
                            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced
                            // so bugs can be reported
                            console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);
                        // will fall through to generating a new cache entry below
                        } else if (!cacheEntry.isStale) {
                            // We have a valid cache entry and it is fresh so we return it
                            return cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;
                        }
                    }
                }
                // If we got this far then we had an invalid cache entry and need to generate a new one
                const result = await _workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args);
                // we need to wait setting the new cache result here as
                // we don't have pending revalidates on workStore to
                // push to and we can't have a dangling promise
                await cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
                return result;
            }
        } finally{
            if (cacheSignal) {
                cacheSignal.endRead();
            }
        }
    };
    // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary
    return cachedCb;
}
function getFetchUrlPrefix(workStore, workUnitStore) {
    switch(workUnitStore.type){
        case 'request':
            const pathname = workUnitStore.url.pathname;
            const searchParams = new URLSearchParams(workUnitStore.url.search);
            const sortedSearch = [
                ...searchParams.keys()
            ].sort((a, b)=>a.localeCompare(b)).map((key)=>`${key}=${searchParams.get(key)}`).join('&');
            return `${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch}`;
        case 'prerender':
        case 'prerender-client':
        case 'prerender-runtime':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
            return workStore.route;
        default:
            return workUnitStore;
    }
} //# sourceMappingURL=unstable-cache.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getSortedRouteObjects: null,
    getSortedRoutes: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getSortedRouteObjects: function() {
        return getSortedRouteObjects;
    },
    getSortedRoutes: function() {
        return getSortedRoutes;
    }
});
class UrlNode {
    insert(urlPath) {
        this._insert(urlPath.split('/').filter(Boolean), [], false);
    }
    smoosh() {
        return this._smoosh();
    }
    _smoosh(prefix) {
        if (prefix === void 0) prefix = '/';
        const childrenPaths = [
            ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);
        }
        if (this.restSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);
        }
        if (this.optionalRestSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);
        }
        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh("" + prefix + c + "/")).reduce((prev, curr)=>[
                ...prev,
                ...curr
            ], []);
        if (this.slugName !== null) {
            routes.push(...this.children.get('[]')._smoosh(prefix + "[" + this.slugName + "]/"));
        }
        if (!this.placeholder) {
            const r = prefix === '/' ? '/' : prefix.slice(0, -1);
            if (this.optionalRestSlugName != null) {
                throw Object.defineProperty(new Error('You cannot define a route with the same specificity as a optional catch-all route ("' + r + '" and "' + r + "[[..." + this.optionalRestSlugName + ']]").'), "__NEXT_ERROR_CODE", {
                    value: "E458",
                    enumerable: false,
                    configurable: true
                });
            }
            routes.unshift(r);
        }
        if (this.restSlugName !== null) {
            routes.push(...this.children.get('[...]')._smoosh(prefix + "[..." + this.restSlugName + "]/"));
        }
        if (this.optionalRestSlugName !== null) {
            routes.push(...this.children.get('[[...]]')._smoosh(prefix + "[[..." + this.optionalRestSlugName + "]]/"));
        }
        return routes;
    }
    _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
            this.placeholder = false;
            return;
        }
        if (isCatchAll) {
            throw Object.defineProperty(new Error("Catch-all must be the last part of the URL."), "__NEXT_ERROR_CODE", {
                value: "E392",
                enumerable: false,
                configurable: true
            });
        }
        // The next segment in the urlPaths list
        let nextSegment = urlPaths[0];
        // Check if the segment matches `[something]`
        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {
            // Strip `[` and `]`, leaving only `something`
            let segmentName = nextSegment.slice(1, -1);
            let isOptional = false;
            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {
                // Strip optional `[` and `]`, leaving only `something`
                segmentName = segmentName.slice(1, -1);
                isOptional = true;
            }
            if (segmentName.startsWith('')) {
                throw Object.defineProperty(new Error("Detected a three-dot character ('') at ('" + segmentName + "'). Did you mean ('...')?"), "__NEXT_ERROR_CODE", {
                    value: "E147",
                    enumerable: false,
                    configurable: true
                });
            }
            if (segmentName.startsWith('...')) {
                // Strip `...`, leaving only `something`
                segmentName = segmentName.substring(3);
                isCatchAll = true;
            }
            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {
                throw Object.defineProperty(new Error("Segment names may not start or end with extra brackets ('" + segmentName + "')."), "__NEXT_ERROR_CODE", {
                    value: "E421",
                    enumerable: false,
                    configurable: true
                });
            }
            if (segmentName.startsWith('.')) {
                throw Object.defineProperty(new Error("Segment names may not start with erroneous periods ('" + segmentName + "')."), "__NEXT_ERROR_CODE", {
                    value: "E288",
                    enumerable: false,
                    configurable: true
                });
            }
            function handleSlug(previousSlug, nextSlug) {
                if (previousSlug !== null) {
                    // If the specific segment already has a slug but the slug is not `something`
                    // This prevents collisions like:
                    // pages/[post]/index.js
                    // pages/[id]/index.js
                    // Because currently multiple dynamic params on the same segment level are not supported
                    if (previousSlug !== nextSlug) {
                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.
                        throw Object.defineProperty(new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "')."), "__NEXT_ERROR_CODE", {
                            value: "E337",
                            enumerable: false,
                            configurable: true
                        });
                    }
                }
                slugNames.forEach((slug)=>{
                    if (slug === nextSlug) {
                        throw Object.defineProperty(new Error('You cannot have the same slug name "' + nextSlug + '" repeat within a single dynamic path'), "__NEXT_ERROR_CODE", {
                            value: "E247",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    if (slug.replace(/\W/g, '') === nextSegment.replace(/\W/g, '')) {
                        throw Object.defineProperty(new Error('You cannot have the slug names "' + slug + '" and "' + nextSlug + '" differ only by non-word symbols within a single dynamic path'), "__NEXT_ERROR_CODE", {
                            value: "E499",
                            enumerable: false,
                            configurable: true
                        });
                    }
                });
                slugNames.push(nextSlug);
            }
            if (isCatchAll) {
                if (isOptional) {
                    if (this.restSlugName != null) {
                        throw Object.defineProperty(new Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + urlPaths[0] + '" ).'), "__NEXT_ERROR_CODE", {
                            value: "E299",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    handleSlug(this.optionalRestSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.optionalRestSlugName = segmentName;
                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically
                    nextSegment = '[[...]]';
                } else {
                    if (this.optionalRestSlugName != null) {
                        throw Object.defineProperty(new Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + urlPaths[0] + '").'), "__NEXT_ERROR_CODE", {
                            value: "E300",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    handleSlug(this.restSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.restSlugName = segmentName;
                    // nextSegment is overwritten to [...] so that it can later be sorted specifically
                    nextSegment = '[...]';
                }
            } else {
                if (isOptional) {
                    throw Object.defineProperty(new Error('Optional route parameters are not yet supported ("' + urlPaths[0] + '").'), "__NEXT_ERROR_CODE", {
                        value: "E435",
                        enumerable: false,
                        configurable: true
                    });
                }
                handleSlug(this.slugName, segmentName);
                // slugName is kept as it can only be one particular slugName
                this.slugName = segmentName;
                // nextSegment is overwritten to [] so that it can later be sorted specifically
                nextSegment = '[]';
            }
        }
        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode
        if (!this.children.has(nextSegment)) {
            this.children.set(nextSegment, new UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
    }
    constructor(){
        this.placeholder = true;
        this.children = new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
    }
}
function getSortedRoutes(normalizedPages) {
    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment
    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js
    // Only 1 dynamic segment per nesting level
    // So in the case that is test/integration/dynamic-routing it'll be this:
    // pages/[post]/comments.js
    // pages/blog/[post]/comment/[id].js
    // Both are fine because `pages/[post]` and `pages/blog` are on the same level
    // So in this case `UrlNode` created here has `this.slugName === 'post'`
    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities
    // Instead what has to be passed through is the upwards path's dynamic names
    const root = new UrlNode();
    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels
    normalizedPages.forEach((pagePath)=>root.insert(pagePath));
    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority
    return root.smoosh();
}
function getSortedRouteObjects(objects, getter) {
    // We're assuming here that all the pathnames are unique, that way we can
    // sort the list and use the index as the key.
    const indexes = {};
    const pathnames = [];
    for(let i = 0; i < objects.length; i++){
        const pathname = getter(objects[i]);
        indexes[pathname] = i;
        pathnames[i] = pathname;
    }
    // Sort the pathnames.
    const sorted = getSortedRoutes(pathnames);
    // Map the sorted pathnames back to the original objects using the new sorted
    // index.
    return sorted.map((pathname)=>objects[indexes[pathname]]);
} //# sourceMappingURL=sorted-routes.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isDynamicRoute", {
    enumerable: true,
    get: function() {
        return isDynamicRoute;
    }
});
const _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-rsc] (ecmascript)");
// Identify /.*[param].*/ in route string
const TEST_ROUTE = /\/[^/]*\[[^/]+\][^/]*(?=\/|$)/;
// Identify /[param]/ in route string
const TEST_STRICT_ROUTE = /\/\[[^/]+\](?=\/|$)/;
function isDynamicRoute(route, strict) {
    if (strict === void 0) strict = true;
    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
    }
    if (strict) {
        return TEST_STRICT_ROUTE.test(route);
    }
    return TEST_ROUTE.test(route);
} //# sourceMappingURL=is-dynamic.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getSortedRouteObjects: null,
    getSortedRoutes: null,
    isDynamicRoute: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getSortedRouteObjects: function() {
        return _sortedroutes.getSortedRouteObjects;
    },
    getSortedRoutes: function() {
        return _sortedroutes.getSortedRoutes;
    },
    isDynamicRoute: function() {
        return _isdynamic.isDynamicRoute;
    }
});
const _sortedroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js [app-rsc] (ecmascript)");
const _isdynamic = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js [app-rsc] (ecmascript)"); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/revalidate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    revalidatePath: null,
    revalidateTag: null,
    unstable_expirePath: null,
    unstable_expireTag: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    revalidatePath: function() {
        return revalidatePath;
    },
    revalidateTag: function() {
        return revalidateTag;
    },
    unstable_expirePath: function() {
        return unstable_expirePath;
    },
    unstable_expireTag: function() {
        return unstable_expireTag;
    }
});
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
function revalidateTag(tag) {
    return revalidate([
        tag
    ], `revalidateTag ${tag}`);
}
function unstable_expirePath(originalPath, type) {
    if (originalPath.length > _constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {
        console.warn(`Warning: expirePath received "${originalPath}" which exceeded max length of ${_constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/unstable_expirePath`);
        return;
    }
    let normalizedPath = `${_constants.NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;
    if (type) {
        normalizedPath += `${normalizedPath.endsWith('/') ? '' : '/'}${type}`;
    } else if ((0, _utils.isDynamicRoute)(originalPath)) {
        console.warn(`Warning: a dynamic page path "${originalPath}" was passed to "expirePath", but the "type" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/unstable_expirePath`);
    }
    return revalidate([
        normalizedPath
    ], `unstable_expirePath ${originalPath}`);
}
function unstable_expireTag(...tags) {
    return revalidate(tags, `unstable_expireTag ${tags.join(', ')}`);
}
function revalidatePath(originalPath, type) {
    if (originalPath.length > _constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {
        console.warn(`Warning: revalidatePath received "${originalPath}" which exceeded max length of ${_constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);
        return;
    }
    let normalizedPath = `${_constants.NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;
    if (type) {
        normalizedPath += `${normalizedPath.endsWith('/') ? '' : '/'}${type}`;
    } else if ((0, _utils.isDynamicRoute)(originalPath)) {
        console.warn(`Warning: a dynamic page path "${originalPath}" was passed to "revalidatePath", but the "type" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);
    }
    return revalidate([
        normalizedPath
    ], `revalidatePath ${originalPath}`);
}
function revalidate(tags, expression) {
    const store = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (!store || !store.incrementalCache) {
        throw Object.defineProperty(new Error(`Invariant: static generation store missing in ${expression}`), "__NEXT_ERROR_CODE", {
            value: "E263",
            enumerable: false,
            configurable: true
        });
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        if (workUnitStore.phase === 'render') {
            throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" during render which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E7",
                enumerable: false,
                configurable: true
            });
        }
        switch(workUnitStore.type){
            case 'cache':
            case 'private-cache':
                throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" inside a "use cache" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                    value: "E181",
                    enumerable: false,
                    configurable: true
                });
            case 'unstable-cache':
                throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" inside a function cached with "unstable_cache(...)" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                    value: "E306",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender':
            case 'prerender-runtime':
                // cacheComponents Prerender
                const error = Object.defineProperty(new Error(`Route ${store.route} used ${expression} without first calling \`await connection()\`.`), "__NEXT_ERROR_CODE", {
                    value: "E406",
                    enumerable: false,
                    configurable: true
                });
                return (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(store.route, expression, error, workUnitStore);
            case 'prerender-client':
                throw Object.defineProperty(new _invarianterror.InvariantError(`${expression} must not be used within a client component. Next.js should be preventing ${expression} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                    value: "E693",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-ppr':
                return (0, _dynamicrendering.postponeWithTracking)(store.route, expression, workUnitStore.dynamicTracking);
            case 'prerender-legacy':
                workUnitStore.revalidate = 0;
                const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                    value: "E558",
                    enumerable: false,
                    configurable: true
                });
                store.dynamicUsageDescription = expression;
                store.dynamicUsageStack = err.stack;
                throw err;
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    // TODO: This is most likely incorrect. It would lead to the ISR
                    // status being flipped when revalidating a static page with a server
                    // action.
                    workUnitStore.usedDynamic = true;
                }
                break;
            default:
                workUnitStore;
        }
    }
    if (!store.pendingRevalidatedTags) {
        store.pendingRevalidatedTags = [];
    }
    for (const tag of tags){
        if (!store.pendingRevalidatedTags.includes(tag)) {
            store.pendingRevalidatedTags.push(tag);
        }
    }
    // TODO: only revalidate if the path matches
    store.pathWasRevalidated = true;
} //# sourceMappingURL=revalidate.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/unstable-no-store.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_noStore", {
    enumerable: true,
    get: function() {
        return unstable_noStore;
    }
});
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
function unstable_noStore() {
    const callingExpression = 'unstable_noStore()';
    const store = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!store) {
        // This generally implies we are being called in Pages router. We should probably not support
        // unstable_noStore in contexts outside of `react-server` condition but since we historically
        // have not errored here previously, we maintain that behavior for now.
        return;
    } else if (store.forceStatic) {
        return;
    } else {
        store.isUnstableNoStore = true;
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                case 'prerender-client':
                case 'prerender-runtime':
                    // unstable_noStore() is a noop in Dynamic I/O.
                    return;
                case 'prerender-ppr':
                case 'prerender-legacy':
                case 'request':
                case 'cache':
                case 'private-cache':
                case 'unstable-cache':
                    break;
                default:
                    workUnitStore;
            }
        }
        (0, _dynamicrendering.markCurrentScopeAsDynamic)(store, workUnitStore, callingExpression);
    }
} //# sourceMappingURL=unstable-no-store.js.map
}),
"[project]/node_modules/next/dist/server/use-cache/cache-life.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cacheLife", {
    enumerable: true,
    get: function() {
        return cacheLife;
    }
});
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
function validateCacheLife(profile) {
    if (profile.stale !== undefined) {
        if (profile.stale === false) {
            throw Object.defineProperty(new Error('Pass `Infinity` instead of `false` if you want to cache on the client forever ' + 'without checking with the server.'), "__NEXT_ERROR_CODE", {
                value: "E407",
                enumerable: false,
                configurable: true
            });
        } else if (typeof profile.stale !== 'number') {
            throw Object.defineProperty(new Error('The stale option must be a number of seconds.'), "__NEXT_ERROR_CODE", {
                value: "E308",
                enumerable: false,
                configurable: true
            });
        }
    }
    if (profile.revalidate !== undefined) {
        if (profile.revalidate === false) {
            throw Object.defineProperty(new Error('Pass `Infinity` instead of `false` if you do not want to revalidate by time.'), "__NEXT_ERROR_CODE", {
                value: "E104",
                enumerable: false,
                configurable: true
            });
        } else if (typeof profile.revalidate !== 'number') {
            throw Object.defineProperty(new Error('The revalidate option must be a number of seconds.'), "__NEXT_ERROR_CODE", {
                value: "E233",
                enumerable: false,
                configurable: true
            });
        }
    }
    if (profile.expire !== undefined) {
        if (profile.expire === false) {
            throw Object.defineProperty(new Error('Pass `Infinity` instead of `false` if you want to cache on the server forever ' + 'without checking with the origin.'), "__NEXT_ERROR_CODE", {
                value: "E658",
                enumerable: false,
                configurable: true
            });
        } else if (typeof profile.expire !== 'number') {
            throw Object.defineProperty(new Error('The expire option must be a number of seconds.'), "__NEXT_ERROR_CODE", {
                value: "E3",
                enumerable: false,
                configurable: true
            });
        }
    }
    if (profile.revalidate !== undefined && profile.expire !== undefined) {
        if (profile.revalidate > profile.expire) {
            throw Object.defineProperty(new Error('If providing both the revalidate and expire options, ' + 'the expire option must be greater than the revalidate option. ' + 'The expire option indicates how many seconds from the start ' + 'until it can no longer be used.'), "__NEXT_ERROR_CODE", {
                value: "E656",
                enumerable: false,
                configurable: true
            });
        }
    }
    if (profile.stale !== undefined && profile.expire !== undefined) {
        if (profile.stale > profile.expire) {
            throw Object.defineProperty(new Error('If providing both the stale and expire options, ' + 'the expire option must be greater than the stale option. ' + 'The expire option indicates how many seconds from the start ' + 'until it can no longer be used.'), "__NEXT_ERROR_CODE", {
                value: "E655",
                enumerable: false,
                configurable: true
            });
        }
    }
}
function cacheLife(profile) {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error('cacheLife() is only available with the experimental.useCache config.'), "__NEXT_ERROR_CODE", {
            value: "E627",
            enumerable: false,
            configurable: true
        });
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    switch(workUnitStore == null ? void 0 : workUnitStore.type){
        case 'prerender':
        case 'prerender-client':
        case 'prerender-runtime':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'unstable-cache':
        case undefined:
            throw Object.defineProperty(new Error('cacheLife() can only be called inside a "use cache" function.'), "__NEXT_ERROR_CODE", {
                value: "E250",
                enumerable: false,
                configurable: true
            });
        case 'cache':
        case 'private-cache':
            break;
        default:
            workUnitStore;
    }
    if (typeof profile === 'string') {
        const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
        if (!workStore) {
            throw Object.defineProperty(new Error('cacheLife() can only be called during App Router rendering at the moment.'), "__NEXT_ERROR_CODE", {
                value: "E94",
                enumerable: false,
                configurable: true
            });
        }
        if (!workStore.cacheLifeProfiles) {
            throw Object.defineProperty(new Error('cacheLifeProfiles should always be provided. This is a bug in Next.js.'), "__NEXT_ERROR_CODE", {
                value: "E294",
                enumerable: false,
                configurable: true
            });
        }
        // TODO: This should be globally available and not require an AsyncLocalStorage.
        const configuredProfile = workStore.cacheLifeProfiles[profile];
        if (configuredProfile === undefined) {
            if (workStore.cacheLifeProfiles[profile.trim()]) {
                throw Object.defineProperty(new Error(`Unknown cacheLife profile "${profile}" is not configured in next.config.js\n` + `Did you mean "${profile.trim()}" without the spaces?`), "__NEXT_ERROR_CODE", {
                    value: "E16",
                    enumerable: false,
                    configurable: true
                });
            }
            throw Object.defineProperty(new Error(`Unknown cacheLife profile "${profile}" is not configured in next.config.js\n` + 'module.exports = {\n' + '  experimental: {\n' + '    cacheLife: {\n' + `      "${profile}": ...\n` + '    }\n' + '  }\n' + '}'), "__NEXT_ERROR_CODE", {
                value: "E137",
                enumerable: false,
                configurable: true
            });
        }
        profile = configuredProfile;
    } else if (typeof profile !== 'object' || profile === null || Array.isArray(profile)) {
        throw Object.defineProperty(new Error('Invalid cacheLife() option. Either pass a profile name or object.'), "__NEXT_ERROR_CODE", {
            value: "E110",
            enumerable: false,
            configurable: true
        });
    } else {
        validateCacheLife(profile);
    }
    if (profile.revalidate !== undefined) {
        // Track the explicit revalidate time.
        if (workUnitStore.explicitRevalidate === undefined || workUnitStore.explicitRevalidate > profile.revalidate) {
            workUnitStore.explicitRevalidate = profile.revalidate;
        }
    }
    if (profile.expire !== undefined) {
        // Track the explicit expire time.
        if (workUnitStore.explicitExpire === undefined || workUnitStore.explicitExpire > profile.expire) {
            workUnitStore.explicitExpire = profile.expire;
        }
    }
    if (profile.stale !== undefined) {
        // Track the explicit stale time.
        if (workUnitStore.explicitStale === undefined || workUnitStore.explicitStale > profile.stale) {
            workUnitStore.explicitStale = profile.stale;
        }
    }
} //# sourceMappingURL=cache-life.js.map
}),
"[project]/node_modules/next/dist/server/use-cache/cache-tag.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cacheTag", {
    enumerable: true,
    get: function() {
        return cacheTag;
    }
});
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _patchfetch = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/patch-fetch.js [app-rsc] (ecmascript)");
function cacheTag(...tags) {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error('cacheTag() is only available with the experimental.useCache config.'), "__NEXT_ERROR_CODE", {
            value: "E628",
            enumerable: false,
            configurable: true
        });
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    switch(workUnitStore == null ? void 0 : workUnitStore.type){
        case 'prerender':
        case 'prerender-client':
        case 'prerender-runtime':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'unstable-cache':
        case undefined:
            throw Object.defineProperty(new Error('cacheTag() can only be called inside a "use cache" function.'), "__NEXT_ERROR_CODE", {
                value: "E177",
                enumerable: false,
                configurable: true
            });
        case 'cache':
        case 'private-cache':
            break;
        default:
            workUnitStore;
    }
    const validTags = (0, _patchfetch.validateTags)(tags, 'cacheTag()');
    if (!workUnitStore.tags) {
        workUnitStore.tags = validTags;
    } else {
        workUnitStore.tags.push(...validTags);
    }
} //# sourceMappingURL=cache-tag.js.map
}),
"[project]/node_modules/next/cache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const cacheExports = {
    unstable_cache: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/unstable-cache.js [app-rsc] (ecmascript)").unstable_cache,
    revalidateTag: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/revalidate.js [app-rsc] (ecmascript)").revalidateTag,
    revalidatePath: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/revalidate.js [app-rsc] (ecmascript)").revalidatePath,
    unstable_expireTag: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/revalidate.js [app-rsc] (ecmascript)").unstable_expireTag,
    unstable_expirePath: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/revalidate.js [app-rsc] (ecmascript)").unstable_expirePath,
    unstable_noStore: __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/unstable-no-store.js [app-rsc] (ecmascript)").unstable_noStore,
    unstable_cacheLife: __turbopack_context__.r("[project]/node_modules/next/dist/server/use-cache/cache-life.js [app-rsc] (ecmascript)").cacheLife,
    unstable_cacheTag: __turbopack_context__.r("[project]/node_modules/next/dist/server/use-cache/cache-tag.js [app-rsc] (ecmascript)").cacheTag
};
// https://nodejs.org/api/esm.html#commonjs-namespaces
// When importing CommonJS modules, the module.exports object is provided as the default export
module.exports = cacheExports;
// make import { xxx } from 'next/cache' work
exports.unstable_cache = cacheExports.unstable_cache;
exports.revalidatePath = cacheExports.revalidatePath;
exports.revalidateTag = cacheExports.revalidateTag;
exports.unstable_expireTag = cacheExports.unstable_expireTag;
exports.unstable_expirePath = cacheExports.unstable_expirePath;
exports.unstable_noStore = cacheExports.unstable_noStore;
exports.unstable_cacheLife = cacheExports.unstable_cacheLife;
exports.unstable_cacheTag = cacheExports.unstable_cacheTag;
}),
"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RedirectStatusCode", {
    enumerable: true,
    get: function() {
        return RedirectStatusCode;
    }
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-status-code.js.map
}),
"[project]/node_modules/next/dist/client/components/redirect-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REDIRECT_ERROR_CODE: null,
    RedirectType: null,
    isRedirectError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REDIRECT_ERROR_CODE: function() {
        return REDIRECT_ERROR_CODE;
    },
    RedirectType: function() {
        return RedirectType;
    },
    isRedirectError: function() {
        return isRedirectError;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-rsc] (ecmascript)");
const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
var RedirectType = /*#__PURE__*/ function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
    return RedirectType;
}({});
function isRedirectError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const digest = error.digest.split(';');
    const [errorCode, type] = digest;
    const destination = digest.slice(2, -2).join(';');
    const status = digest.at(-2);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-error.js.map
}),
"[project]/node_modules/next/dist/client/components/redirect.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getRedirectError: null,
    getRedirectStatusCodeFromError: null,
    getRedirectTypeFromError: null,
    getURLFromRedirectError: null,
    permanentRedirect: null,
    redirect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getRedirectError: function() {
        return getRedirectError;
    },
    getRedirectStatusCodeFromError: function() {
        return getRedirectStatusCodeFromError;
    },
    getRedirectTypeFromError: function() {
        return getRedirectTypeFromError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    },
    permanentRedirect: function() {
        return permanentRedirect;
    },
    redirect: function() {
        return redirect;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-rsc] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-rsc] (ecmascript)");
const actionAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)").actionAsyncStorage : "TURBOPACK unreachable";
function getRedirectError(url, type, statusCode) {
    if (statusCode === void 0) statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = _redirecterror.REDIRECT_ERROR_CODE + ";" + type + ";" + url + ";" + statusCode + ";";
    return error;
}
function redirect(/** The URL to redirect to */ url, type) {
    var _actionAsyncStorage_getStore;
    type != null ? type : type = (actionAsyncStorage == null ? void 0 : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null ? void 0 : _actionAsyncStorage_getStore.isAction) ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
}
function permanentRedirect(/** The URL to redirect to */ url, type) {
    if (type === void 0) type = _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);
}
function getURLFromRedirectError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.split(';').slice(2, -2).join(';');
}
function getRedirectTypeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return error.digest.split(';', 2)[1];
}
function getRedirectStatusCodeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return Number(error.digest.split(';').at(-2));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map
}),
"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTTPAccessErrorStatus: null,
    HTTP_ERROR_FALLBACK_ERROR_CODE: null,
    getAccessFallbackErrorTypeByStatus: null,
    getAccessFallbackHTTPStatus: null,
    isHTTPAccessFallbackError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTTPAccessErrorStatus: function() {
        return HTTPAccessErrorStatus;
    },
    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
    },
    getAccessFallbackErrorTypeByStatus: function() {
        return getAccessFallbackErrorTypeByStatus;
    },
    getAccessFallbackHTTPStatus: function() {
        return getAccessFallbackHTTPStatus;
    },
    isHTTPAccessFallbackError: function() {
        return isHTTPAccessFallbackError;
    }
});
const HTTPAccessErrorStatus = {
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    UNAUTHORIZED: 401
};
const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
function isHTTPAccessFallbackError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const [prefix, httpStatus] = error.digest.split(';');
    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));
}
function getAccessFallbackHTTPStatus(error) {
    const httpStatus = error.digest.split(';')[1];
    return Number(httpStatus);
}
function getAccessFallbackErrorTypeByStatus(status) {
    switch(status){
        case 401:
            return 'unauthorized';
        case 403:
            return 'forbidden';
        case 404:
            return 'not-found';
        default:
            return;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=http-access-fallback.js.map
}),
"[project]/node_modules/next/dist/client/components/not-found.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "notFound", {
    enumerable: true,
    get: function() {
        return notFound;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
/**
 * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
 * within a route segment as well as inject a tag.
 *
 * `notFound()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * - In a Server Component, this will insert a `<meta name="robots" content="noindex" />` meta tag and set the status code to 404.
 * - In a Route Handler or Server Action, it will serve a 404 to the caller.
 *
 * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";404";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map
}),
"[project]/node_modules/next/dist/client/components/forbidden.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "forbidden", {
    enumerable: true,
    get: function() {
        return forbidden;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
// TODO: Add `forbidden` docs
/**
 * @experimental
 * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)
 * within a route segment as well as inject a tag.
 *
 * `forbidden()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";403";
function forbidden() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E488",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forbidden.js.map
}),
"[project]/node_modules/next/dist/client/components/unauthorized.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unauthorized", {
    enumerable: true,
    get: function() {
        return unauthorized;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
// TODO: Add `unauthorized` docs
/**
 * @experimental
 * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)
 * within a route segment as well as inject a tag.
 *
 * `unauthorized()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 *
 * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";401";
function unauthorized() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E411",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unauthorized.js.map
}),
"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isPostpone", {
    enumerable: true,
    get: function() {
        return isPostpone;
    }
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}),
"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNextRouterError", {
    enumerable: true,
    get: function() {
        return isNextRouterError;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-rsc] (ecmascript)");
function isNextRouterError(error) {
    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-next-router-error.js.map
}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
const _ispostpone = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-rsc] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-rsc] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-rsc] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
function unstable_rethrow(error) {
    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {
        throw error;
    }
    if (error instanceof Error && 'cause' in error) {
        unstable_rethrow(error.cause);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.server.js.map
}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.
 * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.
 * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.
 *
 * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const unstable_rethrow = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-rsc] (ecmascript)").unstable_rethrow : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.js.map
}),
"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @internal */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_isUnrecognizedActionError: null,
    unstable_rethrow: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _redirecterror.RedirectType;
    },
    forbidden: function() {
        return _forbidden.forbidden;
    },
    notFound: function() {
        return _notfound.notFound;
    },
    permanentRedirect: function() {
        return _redirect.permanentRedirect;
    },
    redirect: function() {
        return _redirect.redirect;
    },
    unauthorized: function() {
        return _unauthorized.unauthorized;
    },
    unstable_isUnrecognizedActionError: function() {
        return unstable_isUnrecognizedActionError;
    },
    unstable_rethrow: function() {
        return _unstablerethrow.unstable_rethrow;
    }
});
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-rsc] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-rsc] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-rsc] (ecmascript)");
const _forbidden = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/forbidden.js [app-rsc] (ecmascript)");
const _unauthorized = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unauthorized.js [app-rsc] (ecmascript)");
const _unstablerethrow = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-rsc] (ecmascript)");
class ReadonlyURLSearchParamsError extends Error {
    constructor(){
        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');
    }
}
class ReadonlyURLSearchParams extends URLSearchParams {
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {
        throw new ReadonlyURLSearchParamsError();
    }
}
function unstable_isUnrecognizedActionError() {
    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), "__NEXT_ERROR_CODE", {
        value: "E776",
        enumerable: false,
        configurable: true
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.react-server.js.map
}),
"[project]/node_modules/next/dist/api/navigation.react-server.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-rsc] (ecmascript)"); //# sourceMappingURL=navigation.react-server.js.map
;
}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    MutableRequestCookiesAdapter: null,
    ReadonlyRequestCookiesError: null,
    RequestCookiesAdapter: null,
    appendMutableCookies: null,
    areCookiesMutableInCurrentPhase: null,
    createCookiesWithMutableAccessCheck: null,
    getModifiedCookieValues: null,
    responseCookiesToRequestCookies: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
    },
    ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
    },
    appendMutableCookies: function() {
        return appendMutableCookies;
    },
    areCookiesMutableInCurrentPhase: function() {
        return areCookiesMutableInCurrentPhase;
    },
    createCookiesWithMutableAccessCheck: function() {
        return createCookiesWithMutableAccessCheck;
    },
    getModifiedCookieValues: function() {
        return getModifiedCookieValues;
    },
    responseCookiesToRequestCookies: function() {
        return responseCookiesToRequestCookies;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-rsc] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
class ReadonlyRequestCookiesError extends Error {
    constructor(){
        super('Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options');
    }
    static callable() {
        throw new ReadonlyRequestCookiesError();
    }
}
class RequestCookiesAdapter {
    static seal(cookies) {
        return new Proxy(cookies, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'clear':
                    case 'delete':
                    case 'set':
                        return ReadonlyRequestCookiesError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}
const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies');
function getModifiedCookieValues(cookies) {
    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
    if (!modified || !Array.isArray(modified) || modified.length === 0) {
        return [];
    }
    return modified;
}
function appendMutableCookies(headers, mutableCookies) {
    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
    if (modifiedCookieValues.length === 0) {
        return false;
    }
    // Return a new response that extends the response with
    // the modified cookies as fallbacks. `res` cookies
    // will still take precedence.
    const resCookies = new _cookies.ResponseCookies(headers);
    const returnedCookies = resCookies.getAll();
    // Set the modified cookies as fallbacks.
    for (const cookie of modifiedCookieValues){
        resCookies.set(cookie);
    }
    // Set the original cookies as the final values.
    for (const cookie of returnedCookies){
        resCookies.set(cookie);
    }
    return true;
}
class MutableRequestCookiesAdapter {
    static wrap(cookies, onUpdateCookies) {
        const responseCookies = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()){
            responseCookies.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = new Set();
        const updateResponseCookies = ()=>{
            // TODO-APP: change method of getting workStore
            const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
            if (workStore) {
                workStore.pathWasRevalidated = true;
            }
            const allCookies = responseCookies.getAll();
            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));
            if (onUpdateCookies) {
                const serializedCookies = [];
                for (const cookie of modifiedValues){
                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                    tempCookies.set(cookie);
                    serializedCookies.push(tempCookies.toString());
                }
                onUpdateCookies(serializedCookies);
            }
        };
        const wrappedCookies = new Proxy(responseCookies, {
            get (target, prop, receiver) {
                switch(prop){
                    // A special symbol to get the modified cookie values
                    case SYMBOL_MODIFY_COOKIE_VALUES:
                        return modifiedValues;
                    // TODO: Throw error if trying to set a cookie after the response
                    // headers have been set.
                    case 'delete':
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.delete(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    case 'set':
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.set(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
        return wrappedCookies;
    }
}
function createCookiesWithMutableAccessCheck(requestStore) {
    const wrappedCookies = new Proxy(requestStore.mutableCookies, {
        get (target, prop, receiver) {
            switch(prop){
                case 'delete':
                    return function(...args) {
                        ensureCookiesAreStillMutable(requestStore, 'cookies().delete');
                        target.delete(...args);
                        return wrappedCookies;
                    };
                case 'set':
                    return function(...args) {
                        ensureCookiesAreStillMutable(requestStore, 'cookies().set');
                        target.set(...args);
                        return wrappedCookies;
                    };
                default:
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
        }
    });
    return wrappedCookies;
}
function areCookiesMutableInCurrentPhase(requestStore) {
    return requestStore.phase === 'action';
}
/** Ensure that cookies() starts throwing on mutation
 * if we changed phases and can no longer mutate.
 *
 * This can happen when going:
 *   'render' -> 'after'
 *   'action' -> 'render'
 * */ function ensureCookiesAreStillMutable(requestStore, _callingExpression) {
    if (!areCookiesMutableInCurrentPhase(requestStore)) {
        // TODO: maybe we can give a more precise error message based on callingExpression?
        throw new ReadonlyRequestCookiesError();
    }
}
function responseCookiesToRequestCookies(responseCookies) {
    const requestCookies = new _cookies.RequestCookies(new Headers());
    for (const cookie of responseCookies.getAll()){
        requestCookies.set(cookie);
    }
    return requestCookies;
} //# sourceMappingURL=request-cookies.js.map
}),
"[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createDedupedByCallsiteServerErrorLoggerDev", {
    enumerable: true,
    get: function() {
        return createDedupedByCallsiteServerErrorLoggerDev;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const errorRef = {
    current: null
};
// React.cache is currently only available in canary/experimental React channels.
const cache = typeof _react.cache === 'function' ? _react.cache : (fn)=>fn;
// When Cache Components is enabled, we record these as errors so that they
// are captured by the dev overlay as it's more critical to fix these
// when enabled.
const logErrorOrWarn = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.warn;
// We don't want to dedupe across requests.
// The developer might've just attempted to fix the warning so we should warn again if it still happens.
const flushCurrentErrorIfNew = cache((key)=>{
    try {
        logErrorOrWarn(errorRef.current);
    } finally{
        errorRef.current = null;
    }
});
function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
    return function logDedupedError(...args) {
        const message = getMessage(...args);
        if ("TURBOPACK compile-time truthy", 1) {
            var _stack;
            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
            if (callStackFrames === undefined || callStackFrames.length < 4) {
                logErrorOrWarn(message);
            } else {
                // Error:
                //   logDedupedError
                //   asyncApiBeingAccessedSynchronously
                //   <userland callsite>
                // TODO: This breaks if sourcemaps with ignore lists are enabled.
                const key = callStackFrames[4];
                errorRef.current = message;
                flushCurrentErrorIfNew(key);
            }
        } else //TURBOPACK unreachable
        ;
    };
} //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
}),
"[project]/node_modules/next/dist/server/request/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isRequestAPICallableInsideAfter: null,
    throwForSearchParamsAccessInUseCache: null,
    throwWithStaticGenerationBailoutError: null,
    throwWithStaticGenerationBailoutErrorWithDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isRequestAPICallableInsideAfter: function() {
        return isRequestAPICallableInsideAfter;
    },
    throwForSearchParamsAccessInUseCache: function() {
        return throwForSearchParamsAccessInUseCache;
    },
    throwWithStaticGenerationBailoutError: function() {
        return throwWithStaticGenerationBailoutError;
    },
    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
    }
});
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
const _aftertaskasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)");
function throwWithStaticGenerationBailoutError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E576",
        enumerable: false,
        configurable: true
    });
}
function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \`dynamic = "error"\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E543",
        enumerable: false,
        configurable: true
    });
}
function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {
    const error = Object.defineProperty(new Error(`Route ${workStore.route} used "searchParams" inside "use cache". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await "searchParams" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
        value: "E779",
        enumerable: false,
        configurable: true
    });
    Error.captureStackTrace(error, constructorOpt);
    workStore.invalidDynamicUsageError ??= error;
    throw error;
}
function isRequestAPICallableInsideAfter() {
    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/server/request/cookies.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cookies", {
    enumerable: true,
    get: function() {
        return cookies;
    }
});
const _requestcookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-rsc] (ecmascript)");
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-rsc] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
function cookies() {
    const callingExpression = 'cookies';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "cookies" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                value: "E88",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // cookies object without tracking
            const underlyingCookies = createEmptyCookies();
            return makeUntrackedExoticCookies(underlyingCookies);
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`cookies\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E549",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'cache':
                    const error = Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                        value: "E398",
                        enumerable: false,
                        configurable: true
                    });
                    Error.captureStackTrace(error, cookies);
                    workStore.invalidDynamicUsageError ??= error;
                    throw error;
                case 'unstable-cache':
                    throw Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                        value: "E157",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender':
                    return makeHangingCookies(workStore, workUnitStore);
                case 'prerender-client':
                    const exportName = '`cookies`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // We need track dynamic access here eagerly to keep continuity with
                    // how cookies has worked in PPR without cacheComponents.
                    return (0, _dynamicrendering.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);
                case 'prerender-legacy':
                    // We track dynamic access here so we don't need to wrap the cookies
                    // in individual property access tracking.
                    return (0, _dynamicrendering.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);
                case 'prerender-runtime':
                    return (0, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, makeUntrackedCookies(workUnitStore.cookies));
                case 'private-cache':
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                    return makeUntrackedExoticCookies(workUnitStore.cookies);
                case 'request':
                    (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);
                    let underlyingCookies;
                    if ((0, _requestcookies.areCookiesMutableInCurrentPhase)(workUnitStore)) {
                        // We can't conditionally return different types here based on the context.
                        // To avoid confusion, we always return the readonly type here.
                        underlyingCookies = workUnitStore.userspaceMutableCookies;
                    } else {
                        underlyingCookies = workUnitStore.cookies;
                    }
                    if ("TURBOPACK compile-time truthy", 1) {
                        // Semantically we only need the dev tracking when running in `next dev`
                        // but since you would never use next dev with production NODE_ENV we use this
                        // as a proxy so we can statically exclude this code from production builds.
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);
                    } else //TURBOPACK unreachable
                    ;
                default:
                    workUnitStore;
            }
        }
    }
    // If we end up here, there was no work store or work unit store present.
    (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(callingExpression);
}
function createEmptyCookies() {
    return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));
}
const CachedCookies = new WeakMap();
function makeHangingCookies(workStore, prerenderStore) {
    const cachedPromise = CachedCookies.get(prerenderStore);
    if (cachedPromise) {
        return cachedPromise;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`cookies()`');
    CachedCookies.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedCookies(underlyingCookies) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = Promise.resolve(underlyingCookies);
    CachedCookies.set(underlyingCookies, promise);
    return promise;
}
function makeUntrackedExoticCookies(underlyingCookies) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = Promise.resolve(underlyingCookies);
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesIterator.bind(underlyingCookies)
        },
        size: {
            get () {
                return underlyingCookies.size;
            }
        },
        get: {
            value: underlyingCookies.get.bind(underlyingCookies)
        },
        getAll: {
            value: underlyingCookies.getAll.bind(underlyingCookies)
        },
        has: {
            value: underlyingCookies.has.bind(underlyingCookies)
        },
        set: {
            value: underlyingCookies.set.bind(underlyingCookies)
        },
        delete: {
            value: underlyingCookies.delete.bind(underlyingCookies)
        },
        clear: {
            value: typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)
        },
        toString: {
            value: underlyingCookies.toString.bind(underlyingCookies)
        }
    });
    return promise;
}
function makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingCookies);
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...cookies()` or similar iteration';
                syncIODev(route, expression);
                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesIterator.call(underlyingCookies);
            },
            writable: false
        },
        size: {
            get () {
                const expression = '`cookies().size`';
                syncIODev(route, expression);
                return underlyingCookies.size;
            }
        },
        get: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().get()`';
                } else {
                    expression = `\`cookies().get(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.get.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        getAll: {
            value: function getAll() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().getAll()`';
                } else {
                    expression = `\`cookies().getAll(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.getAll.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        has: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().has()`';
                } else {
                    expression = `\`cookies().has(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.has.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        set: {
            value: function set() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().set()`';
                } else {
                    const arg = arguments[0];
                    if (arg) {
                        expression = `\`cookies().set(${describeNameArg(arg)}, ...)\``;
                    } else {
                        expression = '`cookies().set(...)`';
                    }
                }
                syncIODev(route, expression);
                return underlyingCookies.set.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        delete: {
            value: function() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().delete()`';
                } else if (arguments.length === 1) {
                    expression = `\`cookies().delete(${describeNameArg(arguments[0])})\``;
                } else {
                    expression = `\`cookies().delete(${describeNameArg(arguments[0])}, ...)\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.delete.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        clear: {
            value: function clear() {
                const expression = '`cookies().clear()`';
                syncIODev(route, expression);
                // @ts-ignore clear is defined in RequestCookies implementation but not in the type
                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesClear.call(underlyingCookies, promise);
            },
            writable: false
        },
        toString: {
            value: function toString() {
                const expression = '`cookies().toString()` or implicit casting';
                syncIODev(route, expression);
                return underlyingCookies.toString.apply(underlyingCookies, arguments);
            },
            writable: false
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the
// sync access without actually defining the cookies properties on the promise.
function makeUntrackedCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingCookies);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...cookies()` or similar iteration');
                        break;
                    }
                case 'size':
                case 'get':
                case 'getAll':
                case 'has':
                case 'set':
                case 'delete':
                case 'clear':
                case 'toString':
                    {
                        warnForSyncAccess(route, `\`cookies().${prop}\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the cookies object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedCookies.set(underlyingCookies, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? `'${arg.name}'` : typeof arg === 'string' ? `'${arg}'` : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'request':
                if (workUnitStore.prerenderPhase === true) {
                    // When we're rendering dynamically in dev, we need to advance out of
                    // the Prerender environment when we read Request data synchronously.
                    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);
                }
                break;
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createCookiesAccessError);
function createCookiesAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`cookies()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E223",
        enumerable: false,
        configurable: true
    });
}
function polyfilledResponseCookiesIterator() {
    return this.getAll().map((c)=>[
            c.name,
            c
        ]).values();
}
function polyfilledResponseCookiesClear(returnable) {
    for (const cookie of this.getAll()){
        this.delete(cookie.name);
    }
    return returnable;
} //# sourceMappingURL=cookies.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HeadersAdapter: null,
    ReadonlyHeadersError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HeadersAdapter: function() {
        return HeadersAdapter;
    },
    ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
class ReadonlyHeadersError extends Error {
    constructor(){
        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');
    }
    static callable() {
        throw new ReadonlyHeadersError();
    }
}
class HeadersAdapter extends Headers {
    constructor(headers){
        // We've already overridden the methods that would be called, so we're just
        // calling the super constructor to ensure that the instanceof check works.
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                // Because this is just an object, we expect that all "get" operations
                // are for properties. If it's a "get" for a symbol, we'll just return
                // the symbol.
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return undefined.
                if (typeof original === 'undefined') return;
                // If the original casing exists, return the value.
                return _reflect.ReflectAdapter.get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, use the prop as the key.
                return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.has(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return false.
                if (typeof original === 'undefined') return false;
                // If the original casing exists, return true.
                return _reflect.ReflectAdapter.has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return true.
                if (typeof original === 'undefined') return true;
                // If the original casing exists, delete the property.
                return _reflect.ReflectAdapter.deleteProperty(target, original);
            }
        });
    }
    /**
   * Seals a Headers instance to prevent modification by throwing an error when
   * any mutating method is called.
   */ static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'append':
                    case 'delete':
                    case 'set':
                        return ReadonlyHeadersError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
    /**
   * Merges a header value into a string. This stores multiple values as an
   * array, so we need to merge them into a string.
   *
   * @param value a header value
   * @returns a merged header value (a string)
   */ merge(value) {
        if (Array.isArray(value)) return value.join(', ');
        return value;
    }
    /**
   * Creates a Headers instance from a plain object or a Headers instance.
   *
   * @param headers a plain object or a Headers instance
   * @returns a headers instance
   */ static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === 'string') {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== 'undefined') return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== 'undefined';
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
} //# sourceMappingURL=headers.js.map
}),
"[project]/node_modules/next/dist/server/request/headers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "headers", {
    enumerable: true,
    get: function() {
        return headers;
    }
});
const _headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-rsc] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
function headers() {
    const callingExpression = 'headers';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "headers" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                value: "E367",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // headers object without tracking
            const underlyingHeaders = _headers.HeadersAdapter.seal(new Headers({}));
            return makeUntrackedExoticHeaders(underlyingHeaders);
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'cache':
                    {
                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                            value: "E304",
                            enumerable: false,
                            configurable: true
                        });
                        Error.captureStackTrace(error, headers);
                        workStore.invalidDynamicUsageError ??= error;
                        throw error;
                    }
                case 'private-cache':
                    {
                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside "use cache: private". Accessing "headers" inside a private cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                            value: "E742",
                            enumerable: false,
                            configurable: true
                        });
                        Error.captureStackTrace(error, headers);
                        workStore.invalidDynamicUsageError ??= error;
                        throw error;
                    }
                case 'unstable-cache':
                    throw Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                        value: "E127",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender':
                case 'prerender-client':
                case 'prerender-runtime':
                case 'prerender-ppr':
                case 'prerender-legacy':
                case 'request':
                    break;
                default:
                    workUnitStore;
            }
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`headers\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E525",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                case 'prerender-runtime':
                    return makeHangingHeaders(workStore, workUnitStore);
                case 'prerender-client':
                    const exportName = '`headers`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender (no cacheComponents)
                    // We are prerendering with PPR. We need track dynamic access here eagerly
                    // to keep continuity with how headers has worked in PPR without cacheComponents.
                    // TODO consider switching the semantic to throw on property access instead
                    return (0, _dynamicrendering.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);
                case 'prerender-legacy':
                    // Legacy Prerender
                    // We are in a legacy static generation mode while prerendering
                    // We track dynamic access here so we don't need to wrap the headers in
                    // individual property access tracking.
                    return (0, _dynamicrendering.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);
                case 'request':
                    (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);
                    if ("TURBOPACK compile-time truthy", 1) {
                        // Semantically we only need the dev tracking when running in `next dev`
                        // but since you would never use next dev with production NODE_ENV we use this
                        // as a proxy so we can statically exclude this code from production builds.
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                        return makeUntrackedExoticHeadersWithDevWarnings(workUnitStore.headers, workStore == null ? void 0 : workStore.route);
                    } else //TURBOPACK unreachable
                    ;
                    //TURBOPACK unreachable
                    ;
                default:
                    workUnitStore;
            }
        }
    }
    // If we end up here, there was no work store or work unit store present.
    (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(callingExpression);
}
const CachedHeaders = new WeakMap();
function makeHangingHeaders(workStore, prerenderStore) {
    const cachedHeaders = CachedHeaders.get(prerenderStore);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`headers()`');
    CachedHeaders.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedHeaders(underlyingHeaders) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = Promise.resolve(underlyingHeaders);
    CachedHeaders.set(underlyingHeaders, promise);
    return promise;
}
function makeUntrackedExoticHeaders(underlyingHeaders) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = Promise.resolve(underlyingHeaders);
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: underlyingHeaders.append.bind(underlyingHeaders)
        },
        delete: {
            value: underlyingHeaders.delete.bind(underlyingHeaders)
        },
        get: {
            value: underlyingHeaders.get.bind(underlyingHeaders)
        },
        has: {
            value: underlyingHeaders.has.bind(underlyingHeaders)
        },
        set: {
            value: underlyingHeaders.set.bind(underlyingHeaders)
        },
        getSetCookie: {
            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)
        },
        forEach: {
            value: underlyingHeaders.forEach.bind(underlyingHeaders)
        },
        keys: {
            value: underlyingHeaders.keys.bind(underlyingHeaders)
        },
        values: {
            value: underlyingHeaders.values.bind(underlyingHeaders)
        },
        entries: {
            value: underlyingHeaders.entries.bind(underlyingHeaders)
        },
        [Symbol.iterator]: {
            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)
        }
    });
    return promise;
}
function makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingHeaders);
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: function append() {
                const expression = `\`headers().append(${describeNameArg(arguments[0])}, ...)\``;
                syncIODev(route, expression);
                return underlyingHeaders.append.apply(underlyingHeaders, arguments);
            }
        },
        delete: {
            value: function _delete() {
                const expression = `\`headers().delete(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);
            }
        },
        get: {
            value: function get() {
                const expression = `\`headers().get(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.get.apply(underlyingHeaders, arguments);
            }
        },
        has: {
            value: function has() {
                const expression = `\`headers().has(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.has.apply(underlyingHeaders, arguments);
            }
        },
        set: {
            value: function set() {
                const expression = `\`headers().set(${describeNameArg(arguments[0])}, ...)\``;
                syncIODev(route, expression);
                return underlyingHeaders.set.apply(underlyingHeaders, arguments);
            }
        },
        getSetCookie: {
            value: function getSetCookie() {
                const expression = '`headers().getSetCookie()`';
                syncIODev(route, expression);
                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);
            }
        },
        forEach: {
            value: function forEach() {
                const expression = '`headers().forEach(...)`';
                syncIODev(route, expression);
                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);
            }
        },
        keys: {
            value: function keys() {
                const expression = '`headers().keys()`';
                syncIODev(route, expression);
                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);
            }
        },
        values: {
            value: function values() {
                const expression = '`headers().values()`';
                syncIODev(route, expression);
                return underlyingHeaders.values.apply(underlyingHeaders, arguments);
            }
        },
        entries: {
            value: function entries() {
                const expression = '`headers().entries()`';
                syncIODev(route, expression);
                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);
            }
        },
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...headers()` or similar iteration';
                syncIODev(route, expression);
                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);
            }
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the
// sync access without actually defining the headers properties on the promise.
function makeUntrackedHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingHeaders);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...headers()` or similar iteration');
                        break;
                    }
                case 'append':
                case 'delete':
                case 'get':
                case 'has':
                case 'set':
                case 'getSetCookie':
                case 'forEach':
                case 'keys':
                case 'values':
                case 'entries':
                    {
                        warnForSyncAccess(route, `\`headers().${prop}\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the headers object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedHeaders.set(underlyingHeaders, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'string' ? `'${arg}'` : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'request':
                if (workUnitStore.prerenderPhase === true) {
                    // When we're rendering dynamically in dev, we need to advance out of
                    // the Prerender environment when we read Request data synchronously.
                    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);
                }
                break;
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createHeadersAccessError);
function createHeadersAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`headers()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E277",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=headers.js.map
}),
"[project]/node_modules/next/dist/server/request/draft-mode.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "draftMode", {
    enumerable: true,
    get: function() {
        return draftMode;
    }
});
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
function draftMode() {
    const callingExpression = 'draftMode';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!workStore || !workUnitStore) {
        (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(callingExpression);
    }
    switch(workUnitStore.type){
        case 'prerender-runtime':
            // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky
            return (0, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, createOrGetCachedDraftMode(workUnitStore.draftMode, workStore));
        case 'request':
            return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore);
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
            // Inside of `"use cache"` or `unstable_cache`, draft mode is available if
            // the outmost work unit store is a request store (or a runtime prerender),
            // and if draft mode is enabled.
            const draftModeProvider = (0, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, workUnitStore);
            if (draftModeProvider) {
                return createOrGetCachedDraftMode(draftModeProvider, workStore);
            }
        // Otherwise, we fall through to providing an empty draft mode.
        // eslint-disable-next-line no-fallthrough
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
            // Return empty draft mode
            return createOrGetCachedDraftMode(null, workStore);
        default:
            return workUnitStore;
    }
}
function createOrGetCachedDraftMode(draftModeProvider, workStore) {
    const cacheKey = draftModeProvider ?? NullDraftMode;
    const cachedDraftMode = CachedDraftModes.get(cacheKey);
    if (cachedDraftMode) {
        return cachedDraftMode;
    }
    let promise;
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        const route = workStore == null ? void 0 : workStore.route;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);
    } else {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftMode(draftModeProvider);
    }
    CachedDraftModes.set(cacheKey, promise);
    return promise;
}
const NullDraftMode = {};
const CachedDraftModes = new WeakMap();
function createExoticDraftMode(underlyingProvider) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    promise.enable = instance.enable.bind(instance);
    promise.disable = instance.disable.bind(instance);
    return promise;
}
function createExoticDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            const expression = '`draftMode().isEnabled`';
            syncIODev(route, expression);
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(promise, 'enable', {
        value: function get() {
            const expression = '`draftMode().enable()`';
            syncIODev(route, expression);
            return instance.enable.apply(instance, arguments);
        }
    });
    Object.defineProperty(promise, 'disable', {
        value: function get() {
            const expression = '`draftMode().disable()`';
            syncIODev(route, expression);
            return instance.disable.apply(instance, arguments);
        }
    });
    return promise;
}
// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync
// access without actually defining the draftMode properties on the promise.
function createDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case 'isEnabled':
                    warnForSyncAccess(route, `\`draftMode().${prop}\``);
                    break;
                case 'enable':
                case 'disable':
                    {
                        warnForSyncAccess(route, `\`draftMode().${prop}()\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the draftMode object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    return proxiedPromise;
}
class DraftMode {
    constructor(provider){
        this._provider = provider;
    }
    get isEnabled() {
        if (this._provider !== null) {
            return this._provider.isEnabled;
        }
        return false;
    }
    enable() {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        trackDynamicDraftMode('draftMode().enable()', this.enable);
        if (this._provider !== null) {
            this._provider.enable();
        }
    }
    disable() {
        trackDynamicDraftMode('draftMode().disable()', this.disable);
        if (this._provider !== null) {
            this._provider.disable();
        }
    }
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'request':
                if (workUnitStore.prerenderPhase === true) {
                    // When we're rendering dynamically in dev, we need to advance out of
                    // the Prerender environment when we read Request data synchronously.
                    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);
                }
                break;
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createDraftModeAccessError);
function createDraftModeAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`draftMode()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E377",
        enumerable: false,
        configurable: true
    });
}
function trackDynamicDraftMode(expression, constructorOpt) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        if ((workUnitStore == null ? void 0 : workUnitStore.phase) === 'after') {
            throw Object.defineProperty(new Error(`Route ${workStore.route} used "${expression}" inside \`after\`. The enabled status of draftMode can be read inside \`after\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                value: "E348",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E553",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'cache':
                case 'private-cache':
                    {
                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used "${expression}" inside "use cache". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                            value: "E246",
                            enumerable: false,
                            configurable: true
                        });
                        Error.captureStackTrace(error, constructorOpt);
                        workStore.invalidDynamicUsageError ??= error;
                        throw error;
                    }
                case 'unstable-cache':
                    throw Object.defineProperty(new Error(`Route ${workStore.route} used "${expression}" inside a function cached with "unstable_cache(...)". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                        value: "E259",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender':
                case 'prerender-runtime':
                    {
                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used ${expression} without first calling \`await connection()\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`), "__NEXT_ERROR_CODE", {
                            value: "E126",
                            enumerable: false,
                            configurable: true
                        });
                        return (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(workStore.route, expression, error, workUnitStore);
                    }
                case 'prerender-client':
                    const exportName = '`draftMode`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    return (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, workUnitStore.dynamicTracking);
                case 'prerender-legacy':
                    workUnitStore.revalidate = 0;
                    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${workStore.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                        value: "E558",
                        enumerable: false,
                        configurable: true
                    });
                    workStore.dynamicUsageDescription = expression;
                    workStore.dynamicUsageStack = err.stack;
                    throw err;
                case 'request':
                    (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);
                    break;
                default:
                    workUnitStore;
            }
        }
    }
} //# sourceMappingURL=draft-mode.js.map
}),
"[project]/node_modules/next/headers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports.cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/cookies.js [app-rsc] (ecmascript)").cookies;
module.exports.headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/headers.js [app-rsc] (ecmascript)").headers;
module.exports.draftMode = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/draft-mode.js [app-rsc] (ecmascript)").draftMode;
}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This function ensures that all the exported values are valid server actions,
// during the runtime. By definition all actions are required to be async
// functions, but here we can only check that they are functions.
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureServerEntryExports", {
    enumerable: true,
    get: function() {
        return ensureServerEntryExports;
    }
});
function ensureServerEntryExports(actions) {
    for(let i = 0; i < actions.length; i++){
        const action = actions[i];
        if (typeof action !== 'function') {
            throw Object.defineProperty(new Error(`A "use server" file can only export async functions, found ${typeof action}.\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`), "__NEXT_ERROR_CODE", {
                value: "E352",
                enumerable: false,
                configurable: true
            });
        }
    }
} //# sourceMappingURL=action-validate.js.map
}),
];

//# sourceMappingURL=node_modules_4b6e0f30._.js.map